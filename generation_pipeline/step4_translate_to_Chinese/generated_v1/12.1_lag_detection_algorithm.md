# 滞后检测算法

**Learning Point**: 12.1 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 3.3 (Equi-Join), 3.4 (LAG function), understanding of signal processing
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Lag Detection Algorithm**: The core business logic of MarketLag project that identifies when information (RSS signals) changes significantly but market prices (Polymarket) do not respond, indicating a potential information lag.

**Signal Delta**: The change in RSS signal between two consecutive time windows. Calculated as `signal(t) - signal(t-1)`.

**Price Delta**: The change in Polymarket price between two consecutive time windows. Calculated as `price(t) - price(t-1)`.

**Lag Flag**: Boolean indicator that a lag has been detected. True when `signal_delta > 1.0 AND abs(price_delta) < 0.02`.

**Threshold Values**:
- Signal delta threshold: 1.0 (signal increased by at least 1.0)
- Price delta threshold: 0.02 (price changed by less than 2%)

---

## Plain Language Explanation

将 lag detection 想象成交通灯系统：

- **Signal Delta** = 信息变化："新闻提及显著增加"
- **Price Delta** = 市场反应："但价格没有太大变化"
- **Lag Flag** = 告警："存在滞后 - 信息已变化但市场未反应"

**算法**：如果信息变化很大（signal_delta > 1.0）但价格变化不大（abs(price_delta) < 0.02），则将其标记为潜在的 lag。

---

## Analogy

想象您正在监控一只股票：
- **Signal Delta** = 关于公司的突发新闻（大变化）
- **Price Delta** = 股价变动（小变化）
- **Lag** = 新闻已发布但股价尚未反应（机会）

MarketLag 检测信息和市场反应之间的这种滞后。

---

## Relationship to Already Learned Topics

- **3.3 Equi-Join**：将 RSS signals 与价格连接（lag detection 的前提条件）
- **3.4 LAG Function**：使用 LAG 计算 signal_delta
- **12.2 Confidence Score**：量化 lag signals 的可靠性
- **Signal Processing**：整个项目的核心算法

---

## Pseudocode (From Project Design)

Based on MarketLag project design:

```sql
-- Lag detection algorithm (simplified)
WITH joined_data AS (
    SELECT
        market_slug,
        window_start,
        rss_signal,
        price,
        price_delta,
        -- Calculate signal_delta using LAG
        (rss_signal - LAG(rss_signal)
         OVER (PARTITION BY market_slug ORDER BY window_start)) as signal_delta
    FROM rss_signals_hourly r
    INNER JOIN polymarket_price_hourly p
    ON r.market_slug = p.market_slug
      AND r.window_start = p.event_time
)
SELECT
    market_slug,
    window_start,
    signal_delta,
    price_delta,
    -- Lag detection logic
    CASE
        WHEN signal_delta > 1.0 AND ABS(price_delta) < 0.02
        THEN true
        ELSE false
    END as lag_flag
FROM joined_data;
```

---

## Source Code References

**Project Design**: `generation_pipeline/step1_output_project_design/output_project_design_v5.md`

**Implementation**: This algorithm is implemented in MarketLag Job 3 Flink SQL query.

---

## Signal Delta Calculation: signal(t) - signal(t-1)

### Formula

```
signal_delta = signal(current_window) - signal(previous_window)
```

### Implementation in Flink SQL

```sql
(rss_signal - LAG(rss_signal)
 OVER (PARTITION BY market_slug ORDER BY window_start)) as signal_delta
```

**工作原理**：
1. **LAG function**：获取前一个窗口的 signal 值
2. **PARTITION BY market_slug**：按市场计算 delta（不跨市场）
3. **ORDER BY window_start**：按时间排序以获取前一个窗口
4. **减法**：当前 - 前一个 = Delta

**Example**:
- Window 1 (14:00): signal = 2.5
- Window 2 (15:00): signal = 4.0
- signal_delta = 4.0 - 2.5 = 1.5

---

## Price Delta Comparison: abs(price_delta) < threshold (0.02 = 2%)

### Formula

```
abs(price_delta) < 0.02
```

**Threshold**: 0.02 = 2% price change

### 为什么使用此阈值？

- **小变化**：价格变化小于 2%
- **稳定价格**：市场没有显著反应
- **Lag 指标**：信息已变化但价格未变化

**Example**:
- Previous price: 0.50
- Current price: 0.51
- price_delta = 0.01
- abs(price_delta) = 0.01 < 0.02 ✓ (price stable)

---

## Lag Flag Logic: signal_delta > 1.0 AND abs(price_delta) < 0.02

### Complete Logic

```sql
CASE
    WHEN signal_delta > 1.0 AND ABS(price_delta) < 0.02
    THEN true
    ELSE false
END as lag_flag
```

### Conditions

1. **signal_delta > 1.0**：信息显著变化（signal 至少增加 1.0）
2. **abs(price_delta) < 0.02**：价格变化不大（变化小于 2%）

**两个条件都必须为真**，lag_flag 才为 true。

### Example Scenarios

**Scenario 1: Lag Detected** ✓
- signal_delta = 1.5 (> 1.0 ✓)
- price_delta = 0.01 (abs < 0.02 ✓)
- lag_flag = true

**Scenario 2: No Lag** ✗
- signal_delta = 0.5 (< 1.0 ✗)
- price_delta = 0.01
- lag_flag = false

**Scenario 3: No Lag (Price Reacted)** ✗
- signal_delta = 1.5 (> 1.0 ✓)
- price_delta = 0.05 (abs > 0.02 ✗)
- lag_flag = false

---

## MarketLag Job 3 Implementation

```sql
SELECT
    r.market_slug,
    r.window_start,
    r.source_weighted_signal as rss_signal,
    p.price,
    p.price_delta,
    -- Calculate signal_delta
    (r.source_weighted_signal - LAG(r.source_weighted_signal)
      OVER (PARTITION BY r.market_slug ORDER BY r.window_start)) as signal_delta,
    -- Lag detection
    CASE
        WHEN (r.source_weighted_signal - LAG(r.source_weighted_signal)
              OVER (PARTITION BY r.market_slug ORDER BY r.window_start)) > 1.0
          AND ABS(p.price_delta) < 0.02
        THEN true
        ELSE false
    END as lag_flag
FROM rss_signals_hourly r
INNER JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start = p.event_time
WHERE r.source_weighted_signal IS NOT NULL
  AND p.price IS NOT NULL;
```

---

## Minimum Viable Code

```sql
-- Simplified lag detection
WITH signals AS (
    SELECT
        market_slug,
        window_start,
        signal,
        LAG(signal) OVER (PARTITION BY market_slug ORDER BY window_start) as prev_signal
    FROM rss_signals_hourly
),
prices AS (
    SELECT
        market_slug,
        event_time,
        price,
        price_delta
    FROM polymarket_price_hourly
),
joined AS (
    SELECT
        s.market_slug,
        s.window_start,
        s.signal - s.prev_signal as signal_delta,
        p.price_delta
    FROM signals s
    INNER JOIN prices p
    ON s.market_slug = p.market_slug
      AND s.window_start = p.event_time
)
SELECT
    market_slug,
    window_start,
    signal_delta,
    price_delta,
    CASE
        WHEN signal_delta > 1.0 AND ABS(price_delta) < 0.02
        THEN true
        ELSE false
    END as lag_flag
FROM joined;
```

---

## Common Mistakes

1. **错误的 LAG 窗口**：
   - ❌ LAG 不使用 PARTITION BY（混合市场）
   - ✅ 始终使用 PARTITION BY market_slug

2. **错误的阈值**：
   - ❌ 在不理解的情况下使用不同的阈值
   - ✅ 理解为什么选择 1.0 和 0.02（可调参数）

3. **缺少 NULL 处理**：
   - ❌ LAG 对第一个窗口返回 NULL（导致错误）
   - ✅ 处理 NULL：`COALESCE(LAG(...), 0)`

4. **不理解 AND 逻辑**：
   - ❌ 认为 OR 而不是 AND
   - ✅ 两个条件都必须为真（signal 上升 AND 价格稳定）

5. **price_delta 已计算**：
   - ❌ 在 Flink 中重新计算 price_delta
   - ✅ price_delta 在 Lambda producer 中计算（第 7.4 节）

---

## Mind Trigger: When to Think About This

在以下情况下考虑 lag detection 算法：
- **实现 Job 3**：MarketLag 项目的核心逻辑
- **调整阈值**：1.0 和 0.02 是可调参数
- **理解业务逻辑**：这是整个项目检测的内容
- **调试 lag signals**：理解算法有助于调试误报
- **Confidence scoring**：第 12.2 节使用 lag detection 结果

**在 MarketLag 项目中**：这是在 Job 3 中实现的核心算法。检测 RSS signals 显著增加但 Polymarket 价格未反应的情况，表示信息滞后。结果与 confidence scores 一起存储在 Supabase 中（第 12.2 节）。

---

## Summary

Lag detection 算法识别信息（RSS signals）显著变化但市场价格未反应的情况。Signal delta（signal(t) - signal(t-1)）测量信息变化。Price delta 测量市场反应。当 signal_delta > 1.0 AND abs(price_delta) < 0.02 时，lag flag 为 true。这是 MarketLag 项目的核心业务逻辑，在 Job 3 Flink SQL 查询中实现。

