# Flink SQL 时间连接

**Learning Point**: 3.2 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.3 (Table API/SQL), 3.3 (Equi-Join), understanding of time-based joins
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Temporal Join**: 使用时间匹配两个表中行的 join 操作。支持将流与版本化表（随时间变化的表）进行 join。

**Event-Time Temporal Join**: 使用 event time 进行 join（AS OF SYSTEM TIME）。将流事件与该事件时间戳处的表版本进行匹配。

**Interval Join**: 在时间边界内进行 join（例如，±5 分钟）。匹配时间戳在指定间隔内的行。

**Regular Join vs Temporal Join**: Regular join 仅按 key 匹配，temporal join 按 key 和时间匹配。

---

## Plain Language Explanation

将 temporal join 想象成时间旅行匹配：

- **Temporal Join** = 基于时间的匹配："与此事件时间点的表版本匹配"
- **Event-Time Temporal Join** = 历史查找："此事件发生时价格是多少？"
- **Interval Join** = 模糊时间匹配："匹配彼此在 5 分钟内的事件"

**为什么需要**：MarketLag 可以使用 temporal joins，但实际上使用 equi-join，因为数据已预先对齐到小时。

---

## Analogy

如果您了解 **SQL AS OF**（temporal queries），Flink temporal joins 类似：
- SQL `AS OF TIMESTAMP` = Flink event-time temporal join
- 两者都查找表的历史版本

关键区别：Flink temporal joins 在无界流上连续工作。

---

## Relationship to Already Learned Topics

- **1.3 Table API/SQL**: Temporal joins 使用 Flink SQL 语法
- **3.3 Equi-Join**: 不同的 join 类型（MarketLag 使用 equi-join，而非 temporal）
- **1.4 Time Concepts**: Temporal joins 使用 event time
- **SQL**: 您已经了解 temporal queries - Flink 将其扩展到流处理

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```sql
-- Event-time temporal join (simplified)
SELECT *
FROM stream_table s
LEFT JOIN versioned_table FOR SYSTEM_TIME AS OF s.event_time AS v
ON s.key = v.key
-- Matches stream event with table version at event's timestamp
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecTemporalJoin.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecTemporalJoin.java

---

## Regular Join vs Temporal Join

### Regular Join (Equi-Join)

仅按 key 匹配：

```sql
SELECT *
FROM table1 t1
INNER JOIN table2 t2
ON t1.key = t2.key
```

**使用场景**：当两个表都是流且需要精确的 key 匹配时。

**MarketLag**: 使用 regular equi-join（第 3.3 节），因为数据已预先对齐。

### Temporal Join

按 key 和时间匹配：

```sql
SELECT *
FROM stream_table s
LEFT JOIN versioned_table FOR SYSTEM_TIME AS OF s.event_time AS v
ON s.key = v.key
```

**使用场景**：当 join 流与版本化表（随时间变化的表）时。

**MarketLag**: 可以使用 temporal join，但使用 equi-join，因为价格已对齐到小时。

---

## Event-Time Temporal Join (AS OF SYSTEM TIME)

### Syntax

```sql
SELECT *
FROM stream_table s
LEFT JOIN versioned_table FOR SYSTEM_TIME AS OF s.event_time AS v
ON s.key = v.key
```

**工作原理**：
1. 对于每个流事件，获取其 event_time
2. 查找该时间戳处的 versioned_table 版本
3. 按 key 进行 join

**示例**：将流事件与事件时间点的价格表版本进行 join。

### Use Case

当您有：
- **Stream**: 带时间戳的事件
- **Versioned Table**: 随时间变化的表（例如，价格历史）

**MarketLag**: 如果价格存储为版本化表，可以使用此方法，但价格是流格式。

---

## Interval Join: Joining Streams Within Time Bounds

### Syntax

```sql
SELECT *
FROM stream1 s1
JOIN stream2 s2
ON s1.key = s2.key
  AND s1.event_time BETWEEN s2.event_time - INTERVAL '5' MINUTE
                        AND s2.event_time + INTERVAL '5' MINUTE
```

**工作原理**：匹配时间戳在 ±5 分钟内的行。

**使用场景**：当数据可能略微不对齐时（例如，网络延迟）。

**MarketLag**: 不使用，因为数据已预先对齐到 UTC 小时。

---

## Why MarketLag Uses Equi-Join, Not Temporal Join

### Data Alignment

MarketLag 数据已预先对齐：
- **RSS signals**: 对齐到 UTC 小时边界（window_start）
- **Polymarket prices**: 对齐到 UTC 小时边界（event_time）
- **精确匹配**: window_start = event_time（精确对齐）

**结果**：Equi-join 完美工作 - 不需要 temporal join。

### If Data Were Misaligned

如果价格未对齐：
- **Temporal Join**: 可以使用 event-time temporal join
- **Interval Join**: 可以使用 ±5 分钟的 interval join

**但是**：MarketLag 对齐数据，因此 equi-join 更简单、更高效。

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;

public class TemporalJoinDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);

        // Create stream table
        tableEnv.executeSql(
            "CREATE TABLE events (" +
            "  key STRING," +
            "  event_time TIMESTAMP(3)," +
            "  value DOUBLE" +
            ") WITH ('connector' = 'kafka', ...)"
        );

        // Create versioned table
        tableEnv.executeSql(
            "CREATE TABLE prices (" +
            "  key STRING," +
            "  price DOUBLE," +
            "  update_time TIMESTAMP(3)," +
            "  PRIMARY KEY (key) NOT ENFORCED," +
            "  WATERMARK FOR update_time AS update_time" +
            ") WITH ('connector' = 'jdbc', ...)"
        );

        // Temporal join
        tableEnv.executeSql(
            "SELECT " +
            "  e.key," +
            "  e.event_time," +
            "  e.value," +
            "  p.price " +
            "FROM events e " +
            "LEFT JOIN prices FOR SYSTEM_TIME AS OF e.event_time AS p " +
            "ON e.key = p.key"
        );

        env.execute("Temporal Join Demo");
    }
}
```

---

## Common Mistakes

1. **在 equi-join 足够时使用 temporal join**：
   - ❌ 对预先对齐的数据使用 temporal join
   - ✅ 当数据对齐时使用 equi-join（MarketLag 模式）

2. **错误的时间列**：
   - ❌ 使用 processing time 而不是 event time
   - ✅ 对 temporal joins 使用 event time

3. **不理解版本化表**：
   - ❌ 对常规表使用 temporal join
   - ✅ Temporal join 需要版本化表（随时间变化）

4. **Interval 太大**：
   - ❌ 使用 ±1 小时 interval（太大，匹配太多）
   - ✅ 使用适当的 interval（例如，±5 分钟）

5. **性能问题**：
   - ❌ Temporal join 可能很昂贵
   - ✅ 尽可能使用 equi-join（更简单、更快）

---

## Mind Trigger: When to Think About This

在以下情况下考虑 temporal joins：
- **与版本化表 join**: 需要将流与随时间变化的表进行 join
- **数据不对齐**: 数据未完美对齐，需要模糊匹配
- **历史查找**: 需要在事件时间查找表版本
- **理解 join 类型**: 第 12.5 节介绍 join 类型选择
- **MarketLag 设计**: 理解为什么使用 equi-join 而不是 temporal join

**在 MarketLag 项目中**: 使用 equi-join（第 3.3 节）而不是 temporal join，因为数据已预先对齐到 UTC 小时。理解 temporal joins 有助于理解为什么 equi-join 是正确的选择。

---

## Summary

Flink SQL temporal joins 支持流和版本化表之间的基于时间的匹配。Event-time temporal join 将流事件与事件时间戳处的表版本进行匹配。Interval join 在时间边界内匹配行。MarketLag 使用 equi-join 而不是 temporal join，因为数据已预先对齐。理解 temporal joins 有助于选择正确的 join 类型（第 12.5 节）。
