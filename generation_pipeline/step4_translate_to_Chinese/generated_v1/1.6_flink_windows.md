# Flink 窗口

**Learning Point**: 1.6 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.4 (Time Concepts), 1.5 (Watermarks), 理解聚合
**Version**: Flink 2.2.0

---

## 工程化定义

**Window**: 一种基于时间或计数将无界流数据分组为有限桶的机制。窗口支持对流的时间有界子集进行聚合。

**Tumbling Window**: 非重叠、固定大小的窗口，每个事件恰好属于一个窗口。窗口大小等于窗口滑动。

**Sliding Window**: 重叠窗口，事件可以属于多个窗口。窗口滑动小于窗口大小。

**Session Window**: 按活动周期对事件进行分组的窗口。当在指定的间隔持续时间内没有事件到达时，窗口关闭。

**Window Assignment**: 根据事件的时间戳确定事件属于哪个窗口的过程。

**Window Function**: 应用于窗口内事件的计算（aggregate、process、reduce）。

---

## 通俗解释

将窗口想象成流数据的时间桶：

- **Tumbling Window** = 非重叠桶：[0-1hr), [1-2hr), [2-3hr) - 每个事件恰好进入一个桶
- **Sliding Window** = 重叠桶：[0-1hr), [0.5-1.5hr), [1-2hr) - 事件可以在多个桶中
- **Session Window** = 基于活动的桶：对接近到达的事件进行分组，出现间隔时关闭桶

**为什么需要**: 流是无限的 - 您无法聚合"所有数据"。窗口让您可以聚合"过去一小时的所有数据"或"这 5 分钟期间的所有数据"。

---

## 类比理解

如果您了解 **SQL 窗口函数**（您了解），Flink 窗口类似但用于流处理：
- SQL `OVER (PARTITION BY ... ORDER BY ... ROWS BETWEEN ...)` = Flink 窗口
- SQL 对分区的聚合 = Flink 对窗口的聚合

关键区别：SQL 窗口用于有界数据，Flink 窗口用于持续产生结果的无界流。

---

## 与已学内容的关系

- **1.4 Time Concepts**: 窗口使用事件时间（或处理时间）来分配事件
- **1.5 Watermarks**: 窗口使用 watermark 来确定何时关闭并发出结果
- **1.3 Table API/SQL**: Flink SQL 有窗口函数（TUMBLE、HOP、SESSION）
- **Aggregations**: 您从 SQL 中了解聚合 - 窗口支持按时间聚合

---

## 伪代码（基于源码）

Based on Flink 2.2.0 source code:

```java
// Window (simplified)
class TumblingWindow {
    long windowSize;  // e.g., 1 hour

    long getWindowStart(long timestamp) {
        // Align to window boundary
        return (timestamp / windowSize) * windowSize;
    }

    long getWindowEnd(long timestamp) {
        return getWindowStart(timestamp) + windowSize;
    }

    boolean belongsToWindow(Event event, long windowStart) {
        long eventTime = event.getTimestamp();
        return eventTime >= windowStart && eventTime < windowStart + windowSize;
    }
}

// Window assignment (simplified)
class WindowAssigner {
    List<Window> assignWindows(Event event, long timestamp) {
        long windowStart = alignToWindow(timestamp);
        return Collections.singletonList(new TimeWindow(windowStart, windowStart + size));
    }
}
```

---

## 源码参考

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/windows/TimeWindow.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/windows/TimeWindow.java

**Key Classes**:
- `TimeWindow`: Represents a time-based window
- `WindowAssigner`: Assigns events to windows
- `WindowFunction`: Function applied to window contents

---

## 窗口类型

### 1. Tumbling Windows (MarketLag Project Uses This)

**Definition**: 固定大小、非重叠的窗口。

**Example**: 1 小时滚动窗口
- Window 1: [00:00, 01:00)
- Window 2: [01:00, 02:00)
- Window 3: [02:00, 03:00)

**MarketLag Use Case**: RSS 信号聚合 - 聚合每小时的所有 RSS 事件。

```java
// DataStream API
stream.keyBy(Event::getKey)
    .window(TumblingEventTimeWindows.of(Time.hours(1)))
    .aggregate(new MyAggregateFunction());
```

```sql
-- Flink SQL (MarketLag Job 1)
SELECT
    market_slug,
    TUMBLE_START(published_at, INTERVAL '1' HOUR) as window_start,
    TUMBLE_END(published_at, INTERVAL '1' HOUR) as window_end,
    COUNT(*) as mention_count,
    SUM(keyword_score) as keyword_score
FROM rss_events
GROUP BY market_slug, TUMBLE(published_at, INTERVAL '1' HOUR);
```

### 2. Sliding Windows

**Definition**: Fixed-size windows that slide by a smaller interval (overlapping).

**Example**: 1-hour windows sliding every 30 minutes
- Window 1: [00:00, 01:00)
- Window 2: [00:30, 01:30)
- Window 3: [01:00, 02:00)

**Use Case**: Moving averages, trend analysis.

```java
stream.keyBy(Event::getKey)
    .window(SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(30)))
    .aggregate(new MyAggregateFunction());
```

### 3. Session Windows

**Definition**: Windows that group events by activity periods, close when gap exceeds threshold.

**Example**: Session gap = 5 minutes
- Events at 10:00, 10:02, 10:03 → One session
- Gap of 6 minutes
- Events at 10:09 → New session

**Use Case**: User session analysis, grouping related events.

```java
stream.keyBy(Event::getUserId)
    .window(EventTimeSessionWindows.withGap(Time.minutes(5)))
    .aggregate(new MyAggregateFunction());
```

---

## Tumbling Window Configuration and Semantics

### Window Size

Window size determines how events are grouped:
- **1 hour**: All events in same UTC hour → one window
- **5 minutes**: All events in same 5-minute period → one window

### Window Alignment

Windows align to time boundaries:
- **Hour-aligned**: Windows start at :00 minutes (00:00, 01:00, 02:00...)
- **Custom alignment**: Can offset (e.g., start at :15 minutes)

**MarketLag Project**: 1-hour windows aligned to UTC hour boundaries (00:00, 01:00, 02:00...).

### Window Semantics

- **Inclusive start, exclusive end**: Window [14:00, 15:00) includes 14:00:00 but not 15:00:00
- **Event assignment**: Event with timestamp T belongs to window [floor(T/windowSize)*windowSize, floor(T/windowSize)*windowSize + windowSize)

---

## 窗口分配：事件如何分配到窗口

### Event-Time Windows

1. Extract event timestamp from event
2. Calculate window start: `windowStart = floor(timestamp / windowSize) * windowSize`
3. Assign event to window [windowStart, windowStart + windowSize)

**Example**:
- Event timestamp: 14:30:00
- Window size: 1 hour
- Window start: floor(14:30 / 1hr) * 1hr = 14:00
- Assigned to: [14:00, 15:00)

### Processing-Time Windows

1. Use current processing time (system clock)
2. Calculate window start based on processing time
3. Assign event to window

**Note**: Processing-time windows are non-deterministic (results vary with processing speed).

---

## 窗口函数：聚合、处理与归约

### 1. Aggregate Function

Incremental aggregation - maintains accumulator, efficient for large windows.

```java
public class CountAggregate implements AggregateFunction<Event, Long, Long> {
    @Override
    public Long createAccumulator() {
        return 0L;
    }

    @Override
    public Long add(Event value, Long accumulator) {
        return accumulator + 1;
    }

    @Override
    public Long getResult(Long accumulator) {
        return accumulator;
    }

    @Override
    public Long merge(Long a, Long b) {
        return a + b;
    }
}
```

### 2. Process Window Function

Full window access - receives all events in window, more flexible but less efficient.

```java
public class MyProcessWindowFunction
    extends ProcessWindowFunction<Event, Result, String, TimeWindow> {

    @Override
    public void process(String key, Context ctx,
                       Iterable<Event> elements,
                       Collector<Result> out) {
        // Process all events in window
        long count = 0;
        for (Event e : elements) {
            count++;
        }
        out.collect(new Result(key, ctx.window().getStart(), count));
    }
}
```

### 3. Reduce Function

Simple reduction - combines two events into one, incremental.

```java
stream.window(...)
    .reduce((e1, e2) -> new Event(
        e1.getKey(),
        e1.getValue() + e2.getValue()
    ));
```

**MarketLag Project**: Uses aggregate functions (COUNT, SUM, AVG) in Flink SQL.

---

## 窗口触发器与驱逐策略

### Triggers

Determine when window results are emitted:

- **Event-time trigger**: Fires when watermark passes window end
- **Processing-time trigger**: Fires at fixed intervals
- **Count trigger**: Fires when N events in window
- **Custom trigger**: User-defined logic

**Default**: Event-time windows trigger when watermark >= window end.

### Eviction Policies

Remove events from window buffer:

- **Time-based**: Remove events older than X
- **Count-based**: Keep only last N events
- **Custom**: User-defined logic

---

## 最小可用代码

```java
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.api.common.functions.AggregateFunction;

public class WindowDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        DataStream<Event> events = env.fromElements(
            new Event("A", 1000L, 10),
            new Event("A", 2000L, 20),
            new Event("A", 3000L, 30),
            new Event("B", 1500L, 15),
            new Event("B", 2500L, 25)
        );

        // Assign timestamps and watermarks
        DataStream<Event> withTimestamps = events.assignTimestampsAndWatermarks(
            WatermarkStrategy
                .<Event>forBoundedOutOfOrderness(Duration.ofSeconds(1))
                .withTimestampAssigner((e, ts) -> e.getTimestamp())
        );

        // 2-second tumbling windows
        withTimestamps
            .keyBy(Event::getKey)
            .window(TumblingEventTimeWindows.of(Time.seconds(2)))
            .aggregate(new AggregateFunction<Event, Long, Long>() {
                @Override
                public Long createAccumulator() { return 0L; }

                @Override
                public Long add(Event value, Long acc) { return acc + value.getValue(); }

                @Override
                public Long getResult(Long acc) { return acc; }

                @Override
                public Long merge(Long a, Long b) { return a + b; }
            })
            .print();

        env.execute("Window Demo");
    }
}
```

---

## 常见错误

1. **错误的窗口类型**:
   - ❌ 需要滚动窗口时使用滑动窗口
   - ✅ 对于非重叠聚合使用滚动窗口（MarketLag 使用此方式）

2. **不为事件时间窗口设置 watermark**:
   - ❌ 没有 watermark 的事件时间窗口永远不会触发
   - ✅ 始终设置 watermark（第 1.5 节）

3. **窗口对齐问题**:
   - ❌ 由于未对齐，事件进入错误的窗口
   - ✅ 确保时间戳对齐到窗口边界（第 1.4 节）

4. **混淆窗口开始/结束**:
   - ❌ 使用包含结束而不是排除结束
   - ✅ 记住：[start, end) - 包含开始，排除结束

5. **低效的窗口函数**:
   - ❌ 在 AggregateFunction 足够时使用 ProcessWindowFunction
   - ✅ 对于简单聚合使用 AggregateFunction（更高效）

---

## 触发点：什么时候想到这个概念

在以下情况下考虑 Flink 窗口：
- **按时间聚合**: MarketLag 作业 1 每小时聚合 RSS 事件
- **对流数据进行分组**: 需要将无界流分组为有限桶
- **SQL 中的窗口函数**: 第 3.1 节涵盖 TUMBLE 窗口语法
- **窗口对齐**: 确保事件进入正确的窗口
- **性能调优**: 窗口大小影响延迟和状态大小

**在 MarketLag 项目中**: 作业 1 使用 1 小时滚动窗口来聚合 RSS 信号。窗口对齐到 UTC 小时边界。当 watermark 超过窗口结束时间时发出结果。

---

## 小结

窗口将无界流分组为有限的时间桶。滚动窗口（MarketLag 中使用）是非重叠且固定大小的。事件根据其时间戳分配到窗口。窗口函数（aggregate、process、reduce）计算结果。当 watermark 超过窗口结束时，窗口触发。理解窗口对于流处理应用中的基于时间的聚合至关重要。

