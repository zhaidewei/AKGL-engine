# 价格差值计算实现

**Learning Point**: 7.4 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 7.2 (Polymarket API)、7.3 (Computation Placement)、AWS DynamoDB 基础知识
**Version**: Python 3.9+, DynamoDB

---

## Definition (Engineering Language)

**Price Delta Calculation**: 计算当前值和先前值之间的价格变化。公式：`price_delta = current_price - prev_price`。

**State Management for Previous Price**: 存储先前的价格值以进行 delta 计算。选项：DynamoDB（MarketLag 使用此选项）、S3 或内存（不持久化）。

**First-Time Handling**: 当不存在先前价格时的特殊情况。MarketLag 为第一个数据点设置 `delta = 0`。

**DynamoDB Pattern**: 将 `{market_slug|outcome: prev_price}` 存储为键值对，并带有 TTL 以自动清理。

---

## Plain Language Explanation

将价格 delta 想象成跟踪股票价格变化：

- **Price Delta** = 价格变化："价格从 $0.50 变为 $0.55，delta = +$0.05"
- **Previous Price** = 最后已知价格："记住最后价格是 $0.50"
- **First Time** = 没有历史："第一次看到这个市场，delta = 0"

**Why Needed**: MarketLag 需要 price_delta 来检测价格何时不变化（lag 检测算法，第 12.1 节）。

---

## Analogy

如果您了解 **time series analysis**（您了解），价格 delta 是类似的：
- Time series diff = Price delta（两者都计算变化）
- Previous value storage = State management（两者都需要记住先前的值）
- First value = First-time handling（两者都需要特殊情况）

关键区别：价格 delta 在 producer（Lambda）中计算，而不是在 Flink 中。

---

## Relationship to Already Learned Topics

- **7.2 Polymarket API**: 从 API 获取当前价格
- **7.3 Computation Placement**: 在 producer（Lambda）中计算 delta
- **12.1 Lag Detection**: 在 lag 检测算法中使用 price_delta
- **DynamoDB**: 您已经从 AWS 了解 DynamoDB - 用于状态存储

---

## Price Delta Computation: current_price - prev_price

### Formula

```
price_delta = current_price - prev_price
```

### Implementation

```python
def calculate_delta(current_price, prev_price):
    """
    Calculate price delta.

    Args:
        current_price: Current price from API
        prev_price: Previous price from storage (None if first time)

    Returns:
        float: Price delta
    """
    if prev_price is None:
        return 0.0  # First time, no previous price
    else:
        return float(current_price) - float(prev_price)
```

**MarketLag**: 在 Lambda producer 中使用此公式。

---

## State Management for Previous Price: DynamoDB, S3, or In-Memory

### Option 1: DynamoDB (MarketLag Uses This)

**Pros**:
- **Persistent**: 在 Lambda 重启后仍然存在
- **Scalable**: 自动处理许多市场
- **TTL Support**: 自动清理旧数据
- **Fast**: 低延迟读写

**Cons**:
- **Cost**: 按读写付费
- **External Dependency**: 额外的基础设施

**MarketLag**: 使用 DynamoDB 存储先前价格。

### Option 2: S3

**Pros**:
- **Cheap**: 非常低的存储成本
- **Durable**: 高持久性

**Cons**:
- **Slow**: 比 DynamoDB 更高的延迟
- **Not Real-Time**: 更适合批处理

**MarketLag**: 不使用（DynamoDB 对于实时处理更快）。

### Option 3: In-Memory

**Pros**:
- **Fast**: 无网络调用
- **Simple**: 无外部依赖

**Cons**:
- **Not Persistent**: 在 Lambda 重启时丢失
- **Not Scalable**: 受 Lambda 内存限制

**MarketLag**: 不使用（需要持久化）。

---

## First-Time Handling: delta = 0 for First Data Point

### Problem

第一次看到市场时，不存在先前价格。

**Solution**: 为第一个数据点设置 `delta = 0`。

### Implementation

```python
if prev_price is None:
    price_delta = 0.0  # First time, no change
else:
    price_delta = current_price - prev_price
```

**MarketLag**: 使用此模式 - 第一个价格 delta = 0。

### Alternative: Skip First Point

```python
if prev_price is None:
    return None  # Skip first point, no delta to calculate
else:
    price_delta = current_price - prev_price
```

**MarketLag**: 不跳过 - 为第一个点发送 delta = 0。

---

## DynamoDB Pattern: Store `{market_slug|outcome: prev_price}` with TTL

### Table Structure

**Table Name**: `polymarket_previous_prices`

**Key Schema**:
- **Partition Key**: `key` (String) - 格式：`{market_slug}|{outcome}`

**Attributes**:
- `price` (Number) - 先前价格值
- `updated_at` (String) - ISO 8601 时间戳
- `ttl` (Number) - 用于自动清理的 TTL 时间戳

### Implementation

```python
import boto3
from decimal import Decimal
from datetime import datetime, timedelta
import pytz

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('polymarket_previous_prices')

def get_previous_price(market_slug, outcome):
    """
    Get previous price from DynamoDB.

    Args:
        market_slug: Market slug
        outcome: "YES" or "NO"

    Returns:
        float or None: Previous price, or None if not found
    """
    key = f"{market_slug}|{outcome}"

    try:
        response = table.get_item(Key={'key': key})
        item = response.get('Item')
        if item:
            return float(item['price'])
        return None
    except Exception as e:
        # Handle error (log, return None)
        print(f"Error getting previous price: {e}")
        return None

def update_previous_price(market_slug, outcome, price):
    """
    Update previous price in DynamoDB.

    Args:
        market_slug: Market slug
        outcome: "YES" or "NO"
        price: Current price to store
    """
    key = f"{market_slug}|{outcome}"
    now = datetime.now(pytz.UTC)
    ttl = int((now + timedelta(days=30)).timestamp())  # 30-day TTL

    table.put_item(Item={
        'key': key,
        'price': Decimal(str(price)),
        'updated_at': now.isoformat(),
        'ttl': ttl
    })
```

**MarketLag**: 使用此 DynamoDB 模式存储先前价格。

---

## Minimum Viable Code

```python
import boto3
from decimal import Decimal
from datetime import datetime, timedelta
import pytz

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('polymarket_previous_prices')

def calculate_and_store_price_delta(market_slug, outcome, current_price):
    """
    Calculate price delta and update DynamoDB.

    Args:
        market_slug: Market slug
        outcome: "YES" or "NO"
        current_price: Current price from API

    Returns:
        float: Price delta
    """
    # Get previous price
    key = f"{market_slug}|{outcome}"
    response = table.get_item(Key={'key': key})
    prev_price = response.get('Item', {}).get('price', None)

    # Calculate delta
    if prev_price is None:
        price_delta = 0.0  # First time
    else:
        price_delta = float(current_price) - float(prev_price)

    # Update DynamoDB with current price
    now = datetime.now(pytz.UTC)
    ttl = int((now + timedelta(days=30)).timestamp())

    table.put_item(Item={
        'key': key,
        'price': Decimal(str(current_price)),
        'updated_at': now.isoformat(),
        'ttl': ttl
    })

    return price_delta

# Usage in Lambda
current_price = 0.65  # From Polymarket API
price_delta = calculate_and_store_price_delta(
    "fed-hike-january",
    "YES",
    current_price
)

# Send to Kafka
send_to_kafka({
    'market_slug': 'fed-hike-january',
    'outcome': 'YES',
    'price': current_price,
    'price_delta': price_delta,
    'event_time': datetime.now(pytz.UTC).isoformat()
})
```

---

## Common Mistakes

1. **Not handling first-time case**:
   - ❌ 当 prev_price 为 None 时 `price_delta = current_price - prev_price`（错误）
   - ✅ 检查 None：`if prev_price is None: delta = 0.0`

2. **Not updating DynamoDB**:
   - ❌ 计算 delta 但忘记存储当前价格
   - ✅ 计算后始终更新 DynamoDB

3. **Wrong key format**:
   - ❌ 仅使用 market_slug（无法区分 YES/NO）
   - ✅ 使用 `{market_slug}|{outcome}` 格式

4. **Not setting TTL**:
   - ❌ DynamoDB items 永不过期（成本增长）
   - ✅ 设置 TTL（例如 30 天）以自动清理

5. **Type conversion errors**:
   - ❌ 混合使用 Decimal 和 float（DynamoDB 使用 Decimal）
   - ✅ 为 DynamoDB 转换为 Decimal：`Decimal(str(price))`

---

## Mind Trigger: When to Think About This

在以下情况下考虑价格 delta 计算：
- **实现 Lambda producer**: MarketLag 在 Lambda 中计算 price_delta
- **管理状态**: 使用 DynamoDB 存储先前价格
- **首次处理**: 为第一个数据点设置 delta = 0
- **Lag 检测**: 第 12.1 节在算法中使用 price_delta
- **计算放置**: 第 7.3 节涵盖为什么选择 producer-side

**在 MarketLag 项目中**: 在 Lambda producer 中使用 DynamoDB 计算 price_delta。首次设置 delta = 0。价格 delta 用于 lag 检测算法（第 12.1 节）。理解价格 delta 计算对于数据准备至关重要。

---

## Summary

价格 delta 计算计算当前价格和先前价格之间的变化。MarketLag 在 Lambda producer（不在 Flink）中计算 price_delta。使用 DynamoDB 存储先前价格，键格式为 `{market_slug}|{outcome}`。首次处理设置 delta = 0。理解价格 delta 计算对于 Flink 处理之前的数据准备至关重要。
