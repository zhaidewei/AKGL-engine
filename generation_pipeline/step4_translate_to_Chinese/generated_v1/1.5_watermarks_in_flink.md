# Flink 中的 Watermark

**Learning Point**: 1.5 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.4 (Time Concepts), 理解事件时间处理
**Version**: Flink 2.2.0

---

## 工程化定义

**Watermark**: 流经数据流的特殊时间戳，表示不应再到达早于该 watermark 的事件。Watermark 使 Flink 能够确定何时可以关闭时间窗口并发出结果。

**Watermark Delay**: Flink 等待延迟到达事件的最大时间量。在 watermark 之后到达的事件被视为"延迟"，并根据允许的延迟策略处理。

**Watermark Generation**: 创建 watermark 的过程，可以是周期性的（固定间隔）或基于标点符号的（基于数据特征）。

---

## 通俗解释

将 watermark 想象成"不接受延迟条目"的截止日期：

- **Watermark** = 一个标记，表示"我们已经收到了直到这个时间的所有事件"
- **Watermark Delay** = 在声明"不再有延迟事件"之前我们等待多长时间（例如，等待 5 分钟以接收延迟数据）
- **Late Data** = 在 watermark 之后到达的事件（就像在截止日期后提交作业）

**为什么需要**: 在分布式系统中，事件可能乱序到达。Watermark 告诉 Flink"我们确信已经看到了时间 T 的所有事件，因此可以关闭时间 T 的窗口并发出结果。"

---

## 类比理解

想象一个餐厅厨房准备每小时餐点批次：

- **Watermark** = 厨房计时器："我们已经收到了下午 2 点批次的所有订单，开始烹饪"
- **Watermark Delay (5 min)** = 宽限期："再等 5 分钟，以防有人打电话下延迟订单"
- **Late Orders** = 宽限期后到达的订单："抱歉，该批次已经在烹饪了"

没有 watermark，厨房会永远等待，永远不知道何时开始烹饪。有了 watermark，它知道"我们已经等得够久了，开始烹饪。"

---

## 与已学内容的关系

- **1.4 Time Concepts**: Watermark 与事件时间一起工作 - 它们是事件时间域中的时间戳
- **1.6 Windows**: 窗口使用 watermark 来确定何时触发（关闭并发出结果）
- **Kafka**: 来自 Kafka 分区的乱序数据需要 watermark 以实现正确的窗口化
- **Distributed Systems**: 网络延迟导致乱序到达 - watermark 处理这种情况

---

## 伪代码（基于源码）

基于 Flink 2.2.0 源代码：

```java
// Watermark (simplified)
class Watermark {
    long timestamp;  // "Event-time progress: events <= this time are assumed complete (late may still arrive)"
}

// PeriodicWatermarkGenerator (bounded out-of-orderness)
class PeriodicWatermarkGenerator implements WatermarkGenerator<Event> {
    long maxTimestampSeen = Long.MIN_VALUE;
    long outOfOrderness = 5 * 60 * 1000;  // 5 minutes
    long lastEmittedWatermark = Long.MIN_VALUE;

    @Override
    public void onEvent(Event event, long eventTimestamp, WatermarkOutput output) {
        maxTimestampSeen = Math.max(maxTimestampSeen, eventTimestamp);
    }

    @Override
    public void onPeriodicEmit(WatermarkOutput output) {
        if (maxTimestampSeen == Long.MIN_VALUE) {
            return; // 还没有事件 -> 不发出
        }

        long candidate = maxTimestampSeen - outOfOrderness;

        // 确保单调性
        long wm = Math.max(lastEmittedWatermark, candidate);
        lastEmittedWatermark = wm;

        output.emitWatermark(new Watermark(wm));
    }
}

// 相对于 watermark 的延迟（简化版）
boolean isLate(Event e, long currentWatermark) {
    return e.getTimestamp() <= currentWatermark; // "<=" vs "<" 是实现细节；概念是"落后于 watermark"
}
```

---

## 源码参考

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/watermark/Watermark.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/watermark/Watermark.java

**关键类**:
- `Watermark`: watermark 时间戳
- `WatermarkGenerator`: 生成 watermark 的接口
- `WatermarkStrategy`: watermark 生成策略

---

## Watermark 概念：代表什么

时间戳为 `T` 的 watermark 表示：
- "我们相信时间戳 < T 的所有事件都已收到"
- "时间戳 >= T 的事件可能仍会到达"
- "在 T 之前结束的窗口可以关闭并发出结果"

**示例**:
- 当前 watermark: 14:05:00
- 这意味着："我们已经看到了直到 14:00:00 的所有事件（14:05 - 5 分钟延迟）"
- 窗口 [14:00:00, 15:00:00) 可以在 watermark >= 15:00:00 时关闭

---

## Watermark 生成策略

### 1. 周期性 Watermark（最常见）

以固定间隔生成 watermark（例如，每 200 毫秒）。

```java
WatermarkStrategy.<Event>forBoundedOutOfOrderness(Duration.ofMinutes(5))
    .withTimestampAssigner((event, timestamp) -> event.getEventTime());
```

**工作原理**:
1. 跟踪到目前为止看到的最大事件时间戳
2. 每 200 毫秒，发出 watermark = max_timestamp - delay
3. 无限期继续

**使用场景**: MarketLag 项目使用此方式 - RSS 事件延迟 5 分钟。

### 2. 事件驱动的 Watermark

基于数据特征生成 watermark（例如，特殊标记事件）。

```java
// 事件驱动的 watermark：仅在看到批次结束标记时推进
class PunctuatedWmGen implements WatermarkGenerator<Event> {
    long maxTsSeen = Long.MIN_VALUE;   // 到目前为止观察到的最大事件时间
    long lastWm = Long.MIN_VALUE;      // 最后发出的 watermark（必须单调递增）

    void onEvent(Event e, long ts, WatermarkOutput out) {
        maxTsSeen = max(maxTsSeen, ts);

        if (e.isEndOfBatch()) {
            long wm = max(lastWm, maxTsSeen);  // 确保单调性
            lastWm = wm;
            out.emitWatermark(new Watermark(wm));
        }
    }

    void onPeriodicEmit(WatermarkOutput out) {
        // 不执行任何操作（事件驱动 = 无周期性发出）
    }
}

// 策略配置（简化版）
WatermarkStrategy<Event> strat =
    WatermarkStrategy.forGenerator(ctx -> new PunctuatedWmGen())
        .withTimestampAssigner((e, ignored) -> e.getTimestamp());
```

**使用场景**: 当您有明确标记指示"此时间段不再有数据"时。

---

## Watermark 在算子中的传播

Watermark 流经算子图：

```
Source → Map → Filter → Window → Sink
  WM1      WM1    WM1     WM1     WM1
```

**关键点**:
- Watermark 被广播到所有下游算子
- 每个算子转发所有输入中的最小 watermark
- 算子可以延迟 watermark（例如，为连接操作缓冲）

**示例**:
- Source 发出 watermark 14:05
- Map 算子接收它，处理事件，转发 watermark 14:05
- Window 算子接收它，检查是否有窗口可以关闭

---

## 允许延迟与延迟数据处理

### 允许延迟

即使在窗口**首次触发**后，Flink 仍然可以在宽限期内接受延迟数据：

```java
.window(TumblingEventTimeWindows.of(Time.hours(1)))
.allowedLateness(Time.minutes(10))  // 在窗口结束后 10 分钟内仍接受延迟数据
```

**工作原理**:

* 对于窗口 `[14:00, 15:00)`:
* 当 `watermark >= 15:00` 时，窗口**首次触发**并发出结果
* 允许延迟 = 10 分钟
* 时间戳在 `[14:00, 15:00)` 范围内且在 `watermark = 15:10` **之前**到达的事件仍会被接受
* 当此类延迟事件到达时，窗口**重新触发并更新其结果**
* 当 `watermark >= 15:10` 时，窗口状态被**清理**

### 延迟数据处理选项

1. **更新结果**（允许延迟时的默认行为）:

   * 在允许延迟期间内的延迟事件会被添加到窗口
   * 窗口**重新触发**并发出更新的结果
   * 结果在**主输出**上发出

2. **侧输出（超出允许延迟的延迟）**:

   * 在允许延迟期间**之后**到达的事件被视为*超出允许延迟的延迟*
   * 此类事件**不会**进入窗口，可以发送到侧输出：

   ```java
   OutputTag<Event> lateTag = new OutputTag<Event>("late"){};
   windowedStream.sideOutputLateData(lateTag);
   ```

3. **丢弃**（不允许延迟且无侧输出）:

   * 延迟数据被静默丢弃
   * 当延迟数据不重要时使用

---

## Flink SQL 中的 Watermark 配置

### 基本 Watermark 声明

```sql
CREATE TABLE rss_events (
    title STRING,
    published_at TIMESTAMP(3),  -- Event time column
    source STRING,
    WATERMARK FOR published_at AS published_at - INTERVAL '5' MINUTE
) WITH (...);
```

**语法**: `WATERMARK FOR time_column AS time_column - INTERVAL 'N' MINUTE`

**MarketLag Project**: Uses 5-minute watermark delay:
```sql
WATERMARK FOR published_at AS published_at - INTERVAL '5' MINUTE
```

这意味着："在看到事件后等待 5 分钟，然后才认为较早的窗口已完成。"

---

## 最小可用代码

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import java.time.Duration;

public class WatermarkDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // 创建带有乱序事件的源
        DataStream<Event> events = env.addSource(new SourceFunction<Event>() {
            @Override
            public void run(SourceContext<Event> ctx) throws Exception {
                // 事件乱序到达
                ctx.collectWithTimestamp(new Event("A", 1000L), 1000L);  // 时间 1s
                ctx.collectWithTimestamp(new Event("C", 3000L), 3000L);  // 时间 3s（提前到达！）
                ctx.collectWithTimestamp(new Event("B", 2000L), 2000L);  // 时间 2s（延迟到达！）
                ctx.collectWithTimestamp(new Event("D", 4000L), 4000L);  // 时间 4s
            }
        });

        // 分配带有 1 秒延迟的 watermark
        DataStream<Event> withWatermarks = events.assignTimestampsAndWatermarks(
            WatermarkStrategy
                .<Event>forBoundedOutOfOrderness(Duration.ofSeconds(1))
                .withTimestampAssigner((event, timestamp) -> event.getTimestamp())
        );

        // 窗口聚合（当 watermark 超过窗口结束时将触发）
        withWatermarks
            .keyBy(Event::getKey)
            .window(TumblingEventTimeWindows.of(Time.seconds(2)))
            .sum("value")
            .print();

        env.execute("Watermark Demo");
    }
}
```

---

## Watermark 延迟调优

### 延迟过小
- ❌ 窗口过早关闭，大量延迟事件
- ❌ 结果不完整，需要频繁更新
- **症状**: 高延迟数据率

### 延迟过大
- ❌ 窗口保持打开时间过长，高延迟
- ❌ 结果不必要地延迟
- **症状**: 高端到端延迟

### 最优延迟
- ✅ 完整性和延迟之间的平衡
- ✅ 基于数据源特征（网络延迟、处理延迟）
- **MarketLag 项目**: 对于 RSS feed，5 分钟是合理的（网络延迟、API 轮询间隔）

---

## 常见错误

1. **不为事件时间窗口设置 watermark**:
   - ❌ 使用没有 watermark 的事件时间窗口
   - ✅ 使用事件时间窗口时始终设置 watermark

2. **错误的 watermark 延迟**:
   - ❌ 使用 0 延迟（窗口立即关闭，错过延迟数据）
   - ✅ 根据数据源特征设置延迟（MarketLag 使用 5 分钟）

3. **SQL 中的 watermark 语法错误**:
   - ❌ `WATERMARK FOR time_col AS time_col - 5 MINUTE` (缺少 INTERVAL)
   - ✅ `WATERMARK FOR time_col AS time_col - INTERVAL '5' MINUTE`

4. **不处理延迟数据**:
   - ❌ 忽略延迟数据，得到不完整的结果
   - ✅ 对延迟数据使用允许的延迟或侧输出

5. **Watermark 不传播**:
   - ❌ 自定义算子阻塞 watermark
   - ✅ 确保算子正确转发 watermark

---

## 触发点：什么时候想到这个概念

在以下情况下考虑 watermark：
- **设置事件时间窗口**: 第 1.6 节需要 watermark 来触发窗口
- **处理乱序数据**: Kafka 分区、网络延迟导致乱序到达
- **调整延迟与完整性**: 平衡窗口延迟与数据完整性
- **调试窗口问题**: 窗口未触发？检查 watermark 生成
- **配置 Flink SQL**: CREATE TABLE 语句需要 WATERMARK 声明

**在 MarketLag 项目中**: 所有三个作业都使用 5 分钟 watermark 延迟。RSS 事件和 Polymarket 价格都在其表定义中声明了 watermark。当 watermark 超过窗口结束时间时，窗口触发。

---

## 小结

Watermark 使 Flink 能够确定事件时间窗口何时可以关闭。它们表示"不应再到达此时间之前的事件"，并且是周期性或事件驱动生成的。Watermark 延迟（MarketLag 中为 5 分钟）平衡了延迟和完整性。Watermark 对于事件时间窗口化（第 1.6 节）至关重要，必须在 Flink SQL 表定义中声明。

