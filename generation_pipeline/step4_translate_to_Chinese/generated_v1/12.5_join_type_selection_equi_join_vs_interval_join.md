# 连接类型选择：等值连接 vs 区间连接

**Learning Point**: 12.5 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 3.2 (Temporal Joins), 3.3 (Equi-Join), understanding of join semantics
**Version**: Flink 2.2.0

---

## 工程化定义

**Equi-Join**: A join operation that matches rows using exact equality on join keys. Both sides of the join condition must have equal values for the join to succeed.

**Interval Join**: A join operation that matches rows within a time interval (e.g., ±5 minutes). Rows are matched if their timestamps are within the specified interval.

**Data Alignment**: The degree to which timestamps from different sources are aligned to the same boundaries (e.g., UTC hour boundaries).

**Join Type Selection**: Choosing the appropriate join type based on data characteristics and requirements.

---

## 通俗解释

将 join 类型想象成匹配策略：

- **Equi-Join** = 精确匹配："匹配键完全相等的行"
- **Interval Join** = 模糊匹配："匹配时间戳在 5 分钟内的行"
- **Data Alignment** = 时间戳对齐程度："时间戳是否对齐到相同边界？"

**为什么重要**：MarketLag 使用 equi-join，因为数据已预对齐到 UTC 小时。理解何时使用哪种 join 类型有助于做出正确选择。

---

## 类比理解

如果您了解 **database joins**（您了解），Flink join 类型类似：
- SQL INNER JOIN = Flink equi-join（都精确匹配）
- SQL time-based join = Flink interval join（都模糊时间匹配）

关键区别：Flink joins 在无界流上连续工作。

---

## 与已学内容的关系

- **3.3 Equi-Join**：MarketLag 使用 equi-join（在第 3.3 节中涵盖）
- **3.2 Temporal Joins**：不同的 join 类型（MarketLag 中未使用）
- **1.4 Time Concepts**：Data alignment 影响 join 类型选择
- **SQL Joins**：您已经了解 joins - Flink 扩展到流处理

---

## 伪代码（基于源码）

Based on Flink 2.2.0 source code:

```sql
-- Equi-join (simplified)
SELECT *
FROM table1 t1
INNER JOIN table2 t2
ON t1.key = t2.key
  AND t1.time = t2.time  -- Exact match
-- Matches only when keys and times are exactly equal

-- Interval join (simplified)
SELECT *
FROM table1 t1
JOIN table2 t2
ON t1.key = t2.key
  AND t1.time BETWEEN t2.time - INTERVAL '5' MINUTE
                  AND t2.time + INTERVAL '5' MINUTE
-- Matches when keys match and times are within ±5 minutes
```

---

## 源码参考

**Project Design**: `generation_pipeline/step1_output_project_design/output_project_design_v5.md`

**Implementation**: MarketLag Job 3 uses equi-join (section 3.3).

---

## 等值 Join：基于 Join 键的精确匹配

### Characteristics

- **Exact Match**: Both join keys must be exactly equal
- **Efficient**: Simple, fast, can be optimized
- **Deterministic**: Always produces same results

### MarketLag Pattern

```sql
SELECT *
FROM rss_signals_hourly r
INNER JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start = p.event_time
```

**Key Points**:
- **market_slug**: Exact match (same market)
- **window_start = event_time**: Exact match (both aligned to UTC hours)

**Why It Works**: Data is pre-aligned to UTC hour boundaries, so exact match is possible.

---

## Interval Join: Join Within Time Bounds

### Characteristics

- **Fuzzy Match**: Timestamps within interval (e.g., ±5 minutes)
- **Handles Misalignment**: Works when data is not perfectly aligned
- **More Complex**: Requires interval calculation

### Example

```sql
SELECT *
FROM stream1 s1
JOIN stream2 s2
ON s1.key = s2.key
  AND s1.event_time BETWEEN s2.event_time - INTERVAL '5' MINUTE
                        AND s2.event_time + INTERVAL '5' MINUTE
```

**Use Case**: When data may be slightly misaligned (network delays, processing delays).

**MarketLag**: Not used because data is pre-aligned.

---

## Decision Factor: Data Alignment

### Pre-Aligned Data (MarketLag Pattern)

**Characteristics**:
- Timestamps aligned to boundaries (UTC hours)
- Exact matches possible
- Predictable join results

**Choice**: **Equi-Join** (simpler, more efficient)

**MarketLag**:
- RSS signals: window_start aligned to UTC hours
- Polymarket prices: event_time aligned to UTC hours
- **Result**: Equi-join works perfectly

### Misaligned Data

**Characteristics**:
- Timestamps not perfectly aligned
- Slight variations (seconds, minutes)
- Exact matches may miss valid pairs

**Choice**: **Interval Join** (handles misalignment)

**Example**: If prices arrived 2 minutes after signals, interval join would still match them.

---

## Pros and Cons

### Equi-Join

**Pros**:
- Simple, efficient
- Exact matching
- Deterministic results
- Easy to understand

**Cons**:
- Requires pre-aligned data
- Misses matches if data misaligned

**MarketLag**: Uses equi-join because data is pre-aligned.

### Interval Join

**Pros**:
- Handles slight misalignment
- More flexible
- Works with network delays

**Cons**:
- More complex
- May match unintended pairs
- Performance overhead

**MarketLag**: Not used because data is pre-aligned.

---

## 最小可用代码

```sql
-- Equi-join (MarketLag pattern)
SELECT
    r.market_slug,
    r.window_start,
    r.source_weighted_signal as rss_signal,
    p.price,
    p.price_delta
FROM rss_signals_hourly r
INNER JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start = p.event_time  -- Exact match
WHERE r.source_weighted_signal IS NOT NULL
  AND p.price IS NOT NULL;

-- Interval join (alternative, not used in MarketLag)
SELECT
    r.market_slug,
    r.window_start,
    r.source_weighted_signal as rss_signal,
    p.price,
    p.price_delta
FROM rss_signals_hourly r
JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start BETWEEN p.event_time - INTERVAL '5' MINUTE
                          AND p.event_time + INTERVAL '5' MINUTE
WHERE r.source_weighted_signal IS NOT NULL
  AND p.price IS NOT NULL;
```

---

## 常见错误

1. **在 equi-join 足够时使用 interval join**：
   - ❌ 对预对齐数据使用 interval join
   - ✅ 当数据对齐时使用 equi-join（MarketLag 模式）

2. **在数据未对齐时使用 equi-join**：
   - ❌ 对未对齐数据使用 equi-join（错过匹配）
   - ✅ 当数据未完全对齐时使用 interval join

3. **不理解 data alignment**：
   - ❌ 不检查数据是否对齐
   - ✅ 在选择 join 类型之前验证 data alignment

4. **错误的间隔大小**：
   - ❌ 使用 ±1 小时间隔（太大，匹配太多）
   - ✅ 使用适当的间隔（例如，±5 分钟）

5. **性能问题**：
   - ❌ 不考虑性能影响
   - ✅ Equi-join 更高效，尽可能使用

---

## 触发点：什么时候想到这个概念

在以下情况下考虑 join 类型选择：
- **设计 joins**：MarketLag Job 3 将 signals 与价格连接
- **Data alignment**：理解数据是否预对齐
- **选择 join 类型**：Equi-join vs interval join 决策
- **性能优化**：Equi-join 更高效
- **理解 MarketLag 设计**：为什么使用 equi-join

**在 MarketLag 项目中**：使用 equi-join，因为 RSS signals（window_start）和 Polymarket 价格（event_time）都对齐到 UTC 小时边界。精确匹配是可能的，并且比 interval join 更高效。理解 join 类型选择有助于理解 MarketLag 的设计决策。

---

## 小结

Join 类型选择取决于 data alignment。Equi-join 在精确相等时匹配，对预对齐数据高效。Interval join 在时间范围内匹配，处理未对齐情况。MarketLag 使用 equi-join，因为数据已预对齐到 UTC 小时。理解 join 类型选择有助于为每个用例选择正确的 join。

