# Flink 状态后端

**Learning Point**: 1.8 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.7 (State Types), 理解存储系统
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**State Backend**: Flink 用于存储和管理算子状态的存储系统和机制。State backend 决定状态存储位置（内存、文件系统、数据库）以及如何访问。

**MemoryStateBackend**: 在 Java 堆内存中存储状态。快速但受可用内存限制。作业失败时状态丢失。

**FsStateBackend**: 在文件系统（本地或分布式）中存储状态。状态持久化到磁盘，在 TaskManager 重启后存活，但在 JobManager 失败时不存活。

**RocksDBStateBackend**: 在 RocksDB（嵌入式键值存储）中存储状态。状态持久化到磁盘，支持大状态大小，用于生产环境。**MarketLag 项目在 Confluent Cloud 中使用此方式**。

**State TTL (Time To Live)**: 在指定持续时间后自动使状态过期的配置。防止状态无限增长。

---

## Plain Language Explanation

将 state backend 想象成数据的不同存储选项：

- **MemoryStateBackend** = RAM：快速但临时，断电时丢失
- **FsStateBackend** = 本地硬盘：持久但较慢，重启后存活
- **RocksDBStateBackend** = 数据库：持久，处理大量数据，可用于生产

**为什么重要**: 您的状态可能会变得很大（例如，为许多市场存储 max_signal_delta）。您需要一个能够处理大小并持久化状态以实现容错的 backend。

---

## Analogy

如果您了解 **Redis vs PostgreSQL**（您了解），state backend 类似：
- MemoryStateBackend = Redis（内存中，快速，大小有限）
- FsStateBackend = 本地文件存储（持久，中等速度）
- RocksDBStateBackend = PostgreSQL（持久，处理大数据，可用于生产）

关键区别：Flink 自动管理 state backend - 您只需配置使用哪一个。

---

## Relationship to Already Learned Topics

- **1.7 State Types**: State backend 存储状态（ValueState、MapState 等）
- **1.10 Checkpoints**: State backend 决定如何对状态进行 checkpoint
- **RocksDB**: 您可能从其他系统了解 RocksDB - Flink 使用嵌入式版本
- **Storage Systems**: 与您已经了解的 S3、文件系统类似的概念

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// StateBackend interface (simplified)
interface StateBackend {
    <K, V> KeyedStateBackend<K> createKeyedStateBackend(...);
    OperatorStateBackend createOperatorStateBackend(...);
}

// RocksDBStateBackend (simplified) - Used in MarketLag
class RocksDBStateBackend implements StateBackend {
    String dbPath;  // Where RocksDB stores data

    @Override
    public KeyedStateBackend createKeyedStateBackend(...) {
        // Create RocksDB instance
        RocksDB db = RocksDB.open(dbPath);
        return new RocksDBKeyedStateBackend(db);
    }
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateBackend.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateBackend.java

**Key Classes**:
- `RocksDBStateBackend`: 基于 RocksDB 的 state backend
- `FsStateBackend`: 基于文件系统的 state backend
- `MemoryStateBackend`: 基于内存的 state backend

---

## State Backend Types

### 1. MemoryStateBackend

**Storage**: Java 堆内存
**Persistence**: 失败时丢失
**Size Limit**: 受堆内存限制
**Use Case**: 开发、测试、小状态

```java
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
env.setStateBackend(new MemoryStateBackend());
```

**Limitations**:
- TaskManager 崩溃时状态丢失
- 受可用堆内存限制
- 不适合生产环境

### 2. FsStateBackend

**Storage**: 文件系统（本地或分布式，如 HDFS）
**Persistence**: 在 TaskManager 重启后存活
**Size Limit**: 受磁盘空间限制
**Use Case**: 中等状态、本地部署

```java
env.setStateBackend(new FsStateBackend("hdfs://namenode:port/flink/checkpoints"));
```

**Characteristics**:
- 状态持久化到文件系统
- 对于小状态比 RocksDB 更快
- 活动状态访问仍受内存限制

### 3. RocksDBStateBackend (MarketLag Uses This)

**Storage**: RocksDB（嵌入式键值存储）+ 文件系统
**Persistence**: 在故障后存活，在 Confluent Cloud 中 checkpoint 到 S3
**Size Limit**: 非常大（受磁盘限制）
**Use Case**: 生产环境、大状态

```java
env.setStateBackend(new RocksDBStateBackend("file:///path/to/rocksdb"));
```

**Characteristics**:
- 支持非常大的状态（GB 到 TB）
- 当状态超过内存时溢出到磁盘
- 在 Confluent Cloud 中自动使用
- **MarketLag Project**: 在 Confluent Cloud 中使用此方式存储 MapState（max_signal_delta）

---

## State Backend Selection: When to Use Which

| Backend | State Size | Persistence | Use Case |
|---------|------------|-------------|----------|
| **MemoryStateBackend** | < 100 MB | No | 开发、测试 |
| **FsStateBackend** | < 10 GB | Yes (local) | 中等状态、本地部署 |
| **RocksDBStateBackend** | > 10 GB | Yes (distributed) | **生产环境、大状态（MarketLag）** |

**MarketLag Project**: 在 Confluent Cloud 中使用 RocksDBStateBackend，因为：
- 状态可能变得很大（许多市场/结果的 MapState）
- 需要持久化以实现容错
- Confluent Cloud 自动配置 RocksDB

---

## RocksDB Configuration (Confluent Cloud)

Confluent Cloud automatically configures RocksDB, but understanding configuration helps:

### Memory Configuration

```java
// RocksDB memory settings (Confluent Cloud handles this)
RocksDBStateBackend backend = new RocksDBStateBackend("s3://checkpoints");
backend.setDbStoragePath("/tmp/rocksdb");  // Local RocksDB data
// Memory managed by Confluent Cloud based on CFU allocation
```

**Confluent Cloud**: Allocates RocksDB memory based on CFU (Compute Flink Unit) allocation. 2 CFU for MVP provides sufficient memory for state.

### Write Buffers

RocksDB uses write buffers to batch writes:
- **Write Buffer Size**: How much data to buffer before writing
- **Write Buffer Count**: Number of write buffers
- **Confluent Cloud**: Optimizes these automatically

---

## State TTL (Time To Live) Configuration

State TTL 自动使旧状态过期以防止无限增长。

### TTL Configuration

```java
// Configure TTL for state (MarketLag uses 7 days)
StateTtlConfig ttlConfig = StateTtlConfig
    .newBuilder(Time.days(7))  // Expire after 7 days
    .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)  // Update TTL on write
    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)  // Don't return expired
    .build();

// Apply to state descriptor
MapStateDescriptor<String, Double> descriptor =
    new MapStateDescriptor<>("maxSignalDelta", String.class, Double.class);
descriptor.enableTimeToLive(ttlConfig);
```

**MarketLag Project**: 为存储 max_signal_delta 的 MapState 使用 7 天 TTL。旧状态在 7 天后过期。

### TTL Update Strategies

1. **OnCreateAndWrite**: 在创建或写入状态时更新 TTL
2. **OnReadAndWrite**: 在读取和写入时都更新 TTL（保持频繁访问的状态存活）

**MarketLag Project**: 使用 OnCreateAndWrite - TTL 仅在更新状态时延长。

---

## Minimum Viable Code

```java
import org.apache.flink.contrib.streaming.state.RocksDBStateBackend;
import org.apache.flink.runtime.state.StateBackend;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.time.Time;

public class StateBackendDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // Configure RocksDB state backend
        RocksDBStateBackend rocksDB = new RocksDBStateBackend("file:///tmp/rocksdb");
        env.setStateBackend(rocksDB);

        // Configure state with TTL
        StateTtlConfig ttlConfig = StateTtlConfig
            .newBuilder(Time.days(7))
            .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
            .build();

        // Use in ProcessFunction
        stream.keyBy(...)
            .process(new KeyedProcessFunction<...>() {
                private MapState<String, Double> state;

                @Override
                public void open(Configuration config) {
                    MapStateDescriptor<String, Double> descriptor =
                        new MapStateDescriptor<>("state", String.class, Double.class);
                    descriptor.enableTimeToLive(ttlConfig);
                    state = getRuntimeContext().getMapState(descriptor);
                }
            });

        env.execute("State Backend Demo");
    }
}
```

---

## State Backend in Flink SQL

In Flink SQL, state backend is configured at environment level:

```sql
-- State backend configured in table environment, not in SQL
-- Set via: tableEnv.getConfig().getConfiguration().setString("state.backend", "rocksdb");
```

**Confluent Cloud**: Automatically uses RocksDBStateBackend - no configuration needed.

---

## Common Mistakes

1. **在生产环境中使用 MemoryStateBackend**:
   - ❌ 失败时状态丢失
   - ✅ 生产环境使用 RocksDBStateBackend（Confluent Cloud 这样做）

2. **不配置 TTL**:
   - ❌ 状态无限增长
   - ✅ 对于可能增长的状态始终设置 TTL（MarketLag 使用 7 天）

3. **RocksDB 内存不足**:
   - ❌ 大状态时出现 OOM 错误
   - ✅ 在 Confluent Cloud 中分配足够的 CFU（MVP 为 2 CFU）

4. **用例的 state backend 选择错误**:
   - ❌ 对于非常大的状态使用 FsStateBackend
   - ✅ 对于大状态使用 RocksDBStateBackend（MarketLag 模式）

5. **不理解 checkpoint 存储**:
   - ❌ 混淆 state backend 存储与 checkpoint 存储
   - ✅ State backend = 活动状态所在位置，checkpoint 存储 = 保存快照的位置（Confluent Cloud 中为 S3）

---

## Mind Trigger: When to Think About This

在以下情况下考虑 state backend：
- **部署到生产环境**: MarketLag 在 Confluent Cloud 中使用 RocksDB
- **状态大小规划**: 估算状态大小以选择适当的 backend
- **配置 TTL**: 第 4.2 节涵盖 MarketLag 的 TTL 配置
- **Checkpoint 配置**: 第 1.10 节 - state backend 影响 checkpoint 性能
- **故障排查状态问题**: OOM、状态访问缓慢 - 检查 backend 配置

**在 MarketLag 项目中**: Confluent Cloud 自动使用 RocksDBStateBackend。状态（max_signal_delta 的 MapState）存储在 RocksDB 中，checkpoint 到 S3。7 天 TTL 防止无限增长。

---

## Summary

Flink 提供三种 state backend：MemoryStateBackend（开发）、FsStateBackend（中等状态）和 RocksDBStateBackend（生产、大状态）。MarketLag 在 Confluent Cloud 中使用 RocksDBStateBackend，它会自动配置。State TTL（MarketLag 中为 7 天）防止状态无限增长。理解 state backend 有助于状态大小规划、性能调优和容错配置。

