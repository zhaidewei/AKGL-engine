# 状态 TTL 配置

**Learning Point**: 4.2 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.7 (State Types), 1.8 (State Backend), 1.9 (State Access)
**Version**: Flink 2.2.0

---

## 工程化定义

**State TTL (Time To Live)**: 在指定持续时间后自动使状态过期的配置。通过删除旧状态条目防止状态无限增长。

**TTL Update Strategy**: 何时更新 TTL 时间戳：
- **OnCreateAndWrite**: 在创建或写入状态时更新 TTL
- **OnReadAndWrite**: 在读取和写入操作时都更新 TTL

**State Cleanup**: 自动删除过期的状态条目。Flink 定期清理过期状态。

**TTL Configuration**: 为状态描述符设置 TTL 持续时间和更新策略。

---

## 通俗解释

将 State TTL 视为过期日期：

- **TTL** = 过期日期："此状态在 7 天后过期"
- **Update Strategy** = 何时刷新："写入时更新过期日期"或"读取或写入时更新"
- **Cleanup** = 自动删除："自动删除过期状态"

**为什么需要**: MarketLag 在 MapState 中存储 max_signal_delta。没有 TTL，状态会无限增长。7 天 TTL 仅保留最近的历史记录。

---

## 类比理解

如果您了解 **Redis TTL** 或 **缓存过期**（您了解），Flink State TTL 类似：
- Redis TTL = Flink State TTL（两者都在持续时间后过期）
- Cache expiration = State TTL（两者都防止无限增长）

关键区别：Flink TTL 与状态后端和检查点集成。

---

## 与已学内容的关系

- **1.7 State Types**: TTL 适用于所有状态类型（ValueState、MapState 等）
- **1.8 State Backend**: TTL 适用于所有状态后端（MarketLag 中使用 RocksDB）
- **1.9 State Access**: TTL 影响状态访问（过期状态不可访问）
- **State Management**: TTL 对于防止状态无限增长至关重要

---

## 伪代码（基于源码）

Based on Flink 2.2.0 source code:

```java
// StateTtlConfig (simplified)
class StateTtlConfig {
    Time ttl;  // Duration (e.g., 7 days)
    UpdateType updateType;  // OnCreateAndWrite or OnReadAndWrite
    StateVisibility visibility;  // NeverReturnExpired or ReturnExpiredIfNotCleanedUp
}

// TTL state (simplified)
class TtlState<T> {
    T value;
    long expirationTime;

    boolean isExpired() {
        return System.currentTimeMillis() > expirationTime;
    }
}
```

---

## 源码参考

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-runtime/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-runtime/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java

---

## TTL Configuration: When to Expire State

### Basic TTL Configuration

```java
StateTtlConfig ttlConfig = StateTtlConfig
    .newBuilder(Time.days(7))  // Expire after 7 days
    .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)
    .build();
```

**MarketLag Project**: 对存储 max_signal_delta 的 MapState 使用 7 天 TTL。

### TTL Duration Options

```java
Time.days(7)      // 7 days
Time.hours(24)    // 24 hours
Time.minutes(60)  // 60 minutes
Time.seconds(30)  // 30 seconds
```

**选择依据**: 需要历史数据多长时间。MarketLag 使用 7 天作为历史基线。

---

## TTL Update Strategies: OnCreateAndWrite, OnReadAndWrite

### OnCreateAndWrite (MarketLag Uses This)

仅在创建或写入状态时更新 TTL：

```java
.setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
```

**行为**:
- 创建状态 → TTL 设置为 now + 7 天
- 写入状态 → TTL 更新为 now + 7 天
- 读取状态 → TTL 不更新（自上次写入后 7 天过期）

**Use Case**: 当您希望状态在不活动后过期时（MarketLag 模式）。

**Example**:
- Day 1: 写入 max_signal_delta = 2.0 → Day 8 过期
- Day 2: 读取 max_signal_delta → 仍为 Day 8 过期（未更新）
- Day 5: 写入 max_signal_delta = 3.0 → Day 12 过期（已更新）

### OnReadAndWrite

在读取和写入时都更新 TTL：

```java
.setUpdateType(StateTtlConfig.UpdateType.OnReadAndWrite)
```

**行为**：
- 创建状态 → TTL 设置为 now + 7 天
- 写入状态 → TTL 更新为 now + 7 天
- 读取状态 → TTL 更新为 now + 7 天（刷新）

**使用场景**：当您希望保持频繁访问的状态存活时。

**示例**：
- Day 1: 写入 max_signal_delta = 2.0 → Day 8 过期
- Day 2: 读取 max_signal_delta → Day 9 过期（已更新）
- Day 5: 读取 max_signal_delta → Day 12 过期（已更新）

---

## State Cleanup: Expired State Removal

### Automatic Cleanup

Flink 自动清理过期状态：
- **Periodic Cleanup**: 定期运行以删除过期条目
- **Lazy Cleanup**: 在访问时检查过期（如果尚未清理，可能返回过期状态）

### State Visibility

控制是否返回过期状态：

```java
// Never return expired state (default)
.setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)

// Return expired if not cleaned up yet (for debugging)
.setStateVisibility(StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp)
```

**MarketLag Project**: 使用 NeverReturnExpired（默认）。

---

## Example: Setting 7-Day TTL for MapState Storing max_signal_delta

### Complete Configuration

```java
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.time.Time;

public class MarketLagStateConfig {
    public static StateTtlConfig createTtlConfig() {
        return StateTtlConfig
            .newBuilder(Time.days(7))  // 7-day TTL
            .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)  // Update on write
            .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)  // Don't return expired
            .build();
    }

    public static MapStateDescriptor<String, Double> createMaxSignalDeltaDescriptor() {
        MapStateDescriptor<String, Double> descriptor =
            new MapStateDescriptor<>("maxSignalDelta", String.class, Double.class);
        descriptor.enableTimeToLive(createTtlConfig());  // Enable TTL
        return descriptor;
    }
}
```

### Usage in ProcessFunction

```java
public class ConfidenceCalculator extends KeyedProcessFunction<String, Event, Result> {
    private MapState<String, Double> maxSignalDeltaState;

    @Override
    public void open(Configuration config) {
        // Use descriptor with TTL
        MapStateDescriptor<String, Double> descriptor =
            MarketLagStateConfig.createMaxSignalDeltaDescriptor();
        maxSignalDeltaState = getRuntimeContext().getMapState(descriptor);
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        String outcome = event.getOutcome();
        double signalDelta = event.getSignalDelta();

        // Read state (expired entries automatically not returned)
        Double currentMax = maxSignalDeltaState.get(outcome);

        // Update state (TTL refreshed)
        if (currentMax == null || signalDelta > currentMax) {
            maxSignalDeltaState.put(outcome, signalDelta);  // TTL set to now + 7 days
        }
    }
}
```

---

## 最小可用代码

```java
import org.apache.flink.api.common.state.*;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.time.Time;

public class TTLDemo {
    public static class TTLProcessFunction extends KeyedProcessFunction<String, Event, Result> {
        private MapState<String, Double> state;

        @Override
        public void open(Configuration config) {
            // Configure TTL
            StateTtlConfig ttlConfig = StateTtlConfig
                .newBuilder(Time.days(7))
                .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
                .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)
                .build();

            // Create descriptor with TTL
            MapStateDescriptor<String, Double> descriptor =
                new MapStateDescriptor<>("state", String.class, Double.class);
            descriptor.enableTimeToLive(ttlConfig);

            state = getRuntimeContext().getMapState(descriptor);
        }

        @Override
        public void processElement(Event event, Context ctx, Collector<Result> out) {
            // State automatically expires after 7 days from last write
            Double value = state.get(event.getKey());
            if (value == null) {
                state.put(event.getKey(), event.getValue());  // TTL set
            }
        }
    }
}
```

---

## 常见错误

1. **未设置 TTL**:
   - ❌ 状态无限增长
   - ✅ 始终为可能增长的状态设置 TTL（MapState、ListState）

2. **TTL 持续时间错误**:
   - ❌ 太短（丢失需要的历史）或太长（浪费内存）
   - ✅ 根据用例选择（MarketLag 使用 7 天）

3. **更新策略错误**:
   - ❌ 在需要 OnCreateAndWrite 时使用 OnReadAndWrite
   - ✅ 理解区别：OnCreateAndWrite 在不活动后过期

4. **未启用 TTL**:
   - ❌ 创建描述符时未调用 enableTimeToLive()
   - ✅ 始终调用：`descriptor.enableTimeToLive(ttlConfig)`

5. **期望立即清理**:
   - ❌ 期望立即删除过期状态
   - ✅ 清理是周期性的，可能有延迟

---

## 触发点：什么时候想到这个概念

在以下情况下考虑 State TTL：
- **存储历史数据**: MarketLag 使用 7 天 TTL 存储 max_signal_delta
- **防止无限增长**: MapState、ListState 在没有 TTL 的情况下可能增长
- **状态管理**: 第 1.7 节（状态类型）、第 1.9 节（状态访问）
- **内存优化**: TTL 有助于管理状态大小
- **历史基线**: MarketLag 使用 7 天历史进行置信度计算

**在 MarketLag 项目中**: 对每个 outcome 存储 max_signal_delta 的 MapState 使用 7 天 TTL。TTL 防止状态无限增长，同时保留最近的历史记录以进行置信度分数归一化。TTL 配置为 OnCreateAndWrite 策略。

---

## 小结

State TTL 在指定持续时间后自动使状态过期，防止无限增长。TTL 更新策略：OnCreateAndWrite（写入时更新）或 OnReadAndWrite（读取/写入时更新）。Flink 自动清理过期状态。MarketLag 对存储 max_signal_delta 的 MapState 使用 7 天 TTL。理解 TTL 对于管理长时间运行的流应用程序中的状态大小和内存至关重要。

