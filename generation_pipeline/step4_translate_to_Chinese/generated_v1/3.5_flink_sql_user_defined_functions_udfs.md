# Flink SQL 用户定义函数 (UDF)

**Learning Point**: 3.5 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.3 (Table API/SQL), Java/Python basics, understanding of functions
**Version**: Flink 2.2.0

---

## 工程化定义

**User-Defined Function (UDF)**: 用户编写的可在 Flink SQL 查询中使用的自定义函数。使用特定领域逻辑扩展 Flink SQL。

**Scalar UDF**: 接受一个或多个输入值并返回单个输出值的 UDF。用于转换（例如，字符串操作、计算）。

**Table UDF**: 返回表（多行）的 UDF。用于表值函数（例如，将字符串拆分为行）。

**UDF Registration**: 在 Flink TableEnvironment 中注册 UDF，以便可以在 SQL 查询中使用。

**UDF Usage in SQL**: 在 SQL 查询中像内置函数一样调用已注册的 UDF。

---

## 通俗解释

将 UDFs 想象成 SQL 中的自定义函数：

- **Scalar UDF** = 自定义函数："计算 confidence score" 或 "格式化时间戳"
- **Table UDF** = 表生成器："将字符串拆分为行" 或 "生成时间序列"
- **Registration** = 使函数可用："注册函数以便 SQL 可以使用它"

**为什么需要**：如果逻辑对 SQL 来说太复杂，MarketLag 可能需要 UDFs 进行 confidence 计算或信号处理。

---

## 类比理解

如果您了解 **SQL UDFs** 或 **Python functions**（您了解），Flink UDFs 类似：
- SQL CREATE FUNCTION = Flink UDF 注册
- Python def function = Flink UDF 实现

关键区别：Flink UDFs 在无界流上工作，连续处理记录。

---

## 与已学内容的关系

- **1.3 Table API/SQL**: UDFs extend Flink SQL capabilities
- **12.2 Confidence Score**: UDFs could implement confidence calculation
- **Java/Python**: UDFs are written in Java or Python
- **Functions**: You already know functions - UDFs are custom functions

---

## 伪代码（基于源码）

Based on Flink 2.2.0 source code:

```java
// Scalar UDF (simplified)
class ScalarFunction {
    Object eval(Object... args) {
        // Custom logic
        return result;
    }
}

// UDF registration (simplified)
tableEnv.createTemporaryFunction("my_udf", new MyScalarFunction());
```

---

## 源码参考

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/functions/ScalarFunction.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/functions/ScalarFunction.java

---

## 标量 UDF：简单转换

### Java Scalar UDF

```java
import org.apache.flink.table.functions.ScalarFunction;

public class ConfidenceUDF extends ScalarFunction {
    public double eval(double signalDelta, double maxSignalDelta,
                      double priceDelta, double sourceWeight) {
        // Confidence calculation (section 12.2)
        double signalFactor = (signalDelta / maxSignalDelta) * 0.5;
        double priceFactor = (1 - Math.abs(priceDelta)) * 0.3;
        double sourceFactor = sourceWeight * 0.2;
        return Math.min(1.0, signalFactor + priceFactor + sourceFactor);
    }
}
```

### Registration

```java
tableEnv.createTemporaryFunction("calculate_confidence", new ConfidenceUDF());
```

### Usage in SQL

```sql
SELECT
    market_slug,
    calculate_confidence(signal_delta, max_signal_delta, price_delta, source_weight) as confidence
FROM joined_data;
```

**MarketLag**: Could use UDF for confidence calculation if SQL becomes too complex.

---

## 表 UDF：返回表的函数

### Java Table UDF

```java
import org.apache.flink.table.functions.TableFunction;

public class SplitUDF extends TableFunction<Row> {
    public void eval(String str, String delimiter) {
        String[] parts = str.split(delimiter);
        for (String part : parts) {
            collect(Row.of(part));
        }
    }
}
```

### Registration

```java
tableEnv.createTemporaryFunction("split_string", new SplitUDF());
```

### Usage in SQL

```sql
SELECT
    market_slug,
    word
FROM events,
LATERAL TABLE(split_string(keywords, ',')) AS T(word);
```

---

## 在 SQL 中注册与使用 UDF

### Registration Methods

**Temporary Function** (Session-scoped):
```java
tableEnv.createTemporaryFunction("my_udf", new MyUDF());
```

**Permanent Function** (Catalog-scoped):
```java
tableEnv.createFunction("my_udf", new MyUDF());
```

**MarketLag**: Uses temporary functions for project-specific logic.

### Usage in SQL

Once registered, use UDF like built-in function:

```sql
SELECT
    my_udf(column1, column2) as result
FROM table;
```

---

## 最小可用代码

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;
import org.apache.flink.table.functions.ScalarFunction;

public class UDFDemo {
    // Define UDF
    public static class MultiplyUDF extends ScalarFunction {
        public double eval(double a, double b) {
            return a * b;
        }
    }

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);

        // Register UDF
        tableEnv.createTemporaryFunction("multiply", new MultiplyUDF());

        // Use in SQL
        tableEnv.executeSql(
            "SELECT " +
            "  value1," +
            "  value2," +
            "  multiply(value1, value2) as product " +
            "FROM input_table"
        );

        env.execute("UDF Demo");
    }
}
```

---

## 常见错误

1. **未注册 UDF**：
   - ❌ 在 SQL 中使用 UDF 但未注册
   - ✅ 始终注册：`tableEnv.createTemporaryFunction(...)`

2. **错误的函数类型**：
   - ❌ 对表值函数使用 ScalarFunction
   - ✅ 对表值函数使用 TableFunction

3. **类型不匹配**：
   - ❌ UDF 期望 INT 但接收 STRING
   - ✅ 确保类型匹配：使用正确的 Flink 类型

4. **性能问题**：
   - ❌ 复杂的 UDF 逻辑导致性能问题
   - ✅ 优化 UDF 逻辑，对于复杂逻辑考虑 ProcessFunction

5. **未处理 nulls**：
   - ❌ UDF 在 NULL 输入时崩溃
   - ✅ 处理 NULL：`if (arg == null) return null;`

---

## 触发点：什么时候想到这个概念

在以下情况下考虑 UDFs：
- **复杂计算**：如果 SQL 太复杂，confidence 计算可能需要 UDF
- **自定义转换**：需要 SQL 中不可用的转换
- **可重用逻辑**：希望在多个查询中重用逻辑
- **信号处理**：MarketLag 可能需要 UDFs 进行信号处理
- **ProcessFunction 的替代**：UDFs 提供 SQL 友好的替代方案

**在 MarketLag 项目中**：如果 SQL 变得太复杂，可以使用 UDFs 进行 confidence 计算或信号处理。或者，confidence 计算可以在 ProcessFunction（第 4.1 节）中完成，或者如果可能的话保留在 SQL 中。

---

## 小结

Flink SQL UDFs 支持在 SQL 查询中使用自定义函数。Scalar UDFs 返回单个值，table UDFs 返回表。UDFs 必须在使用前注册。MarketLag 可以使用 UDFs 进行 confidence 计算或信号处理。理解 UDFs 有助于使用特定领域逻辑扩展 Flink SQL。

