# ProcessFunction 用于有状态逻辑

**Learning Point**: 4.1 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.2 (DataStream API), 1.7 (State Types), 1.9 (State Access), Java basics
**Version**: Flink 2.2.0

---

## 工程化定义

**ProcessFunction**: 提供对流处理细粒度控制的低级 Flink 算子。允许访问按元素处理、状态和计时器。

**KeyedProcessFunction**: 用于 keyed streams 的 ProcessFunction。提供对 keyed state（ValueState、MapState 等）的访问，作用域为 key。

**processElement**: 为每个传入记录调用的方法。主要处理逻辑在这里。

**onTimer**: 当注册的计时器触发时调用的方法。用于基于时间的处理（例如，超时、周期性任务）。

**Timer Registration**: 注册计时器以在特定时间戳（event time 或 processing time）触发。

---

## 通俗解释

将 ProcessFunction 想象成具有完全控制权的自定义算子：

- **ProcessFunction** = 自定义工作站：您完全控制每个项目发生的情况
- **processElement** = 处理每个项目："当事件到达时，执行此操作"
- **onTimer** = 计时器回调："当计时器触发时，执行该操作"
- **State Access** = 内存：记住事件之间的信息

**为什么需要**：MarketLag Job 3 可能需要 ProcessFunction 进行带历史状态的 confidence 计算（max_signal_delta 存储在 MapState 中）。

---

## 类比理解

如果您了解 **Spark 的 mapPartitions** 或 **自定义 UDFs**（您了解），ProcessFunction 类似：
- Spark mapPartitions = Flink ProcessFunction（两者都提供细粒度控制）
- 自定义 UDF = ProcessFunction（两者都允许自定义逻辑）

关键区别：ProcessFunction 具有内置的状态和计时器支持，使其对状态处理更强大。

---

## 与已学内容的关系

- **1.2 DataStream API**: ProcessFunction 是一个 DataStream 算子
- **1.7 State Types**: ProcessFunction 访问状态（ValueState、MapState）
- **1.9 State Access**: 如何在 ProcessFunction 中读取/写入状态
- **1.6 Windows**: ProcessFunction 为基于时间的处理提供窗口的替代方案

---

## 伪代码（基于源码）

Based on Flink 2.2.0 source code:

```java
// ProcessFunction interface (simplified)
abstract class ProcessFunction<IN, OUT> {
    void processElement(IN value, Context ctx, Collector<OUT> out);
    void onTimer(long timestamp, OnTimerContext ctx, Collector<OUT> out);
}

// KeyedProcessFunction (simplified)
abstract class KeyedProcessFunction<K, IN, OUT> extends ProcessFunction<IN, OUT> {
    RuntimeContext getRuntimeContext();  // Access to state
    TimerService timerService();  // Access to timers
}
```

---

## 源码参考

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/ProcessFunction.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/ProcessFunction.java

---

## ProcessFunction Interface: processElement, onTimer

### processElement

Called for each incoming record:

```java
@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    // Process each event
    // Access state
    // Register timers
    // Emit results
}
```

**参数**：
- **event**: 传入记录
- **ctx**: 上下文（访问时间戳、计时器服务）
- **out**: 用于发出结果的 Collector

### onTimer

当注册的计时器触发时调用：

```java
@Override
public void onTimer(long timestamp, OnTimerContext ctx, Collector<Result> out) {
    // Handle timer
    // Access state
    // Emit results
}
```

**使用场景**：超时、周期性任务、清理。

---

## KeyedProcessFunction for Keyed State Access

### KeyedProcessFunction vs ProcessFunction

**KeyedProcessFunction**: 用于 keyed streams（在 keyBy 之后），提供 keyed state 访问。

```java
stream.keyBy(Event::getKey)
    .process(new KeyedProcessFunction<String, Event, Result>() {
        // Can access keyed state (ValueState, MapState, etc.)
    });
```

**ProcessFunction**: 用于非 keyed streams，提供 operator state 访问。

```java
stream.process(new ProcessFunction<Event, Result>() {
    // Can access operator state (ListState, etc.)
});
```

**MarketLag Job 3**: Uses KeyedProcessFunction (keyed by market_slug|outcome) to access MapState.

---

## Timer Registration and Firing

### Registering Timers

```java
@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    // Register event-time timer
    long timerTime = event.getTimestamp() + 3600000;  // 1 hour later
    ctx.timerService().registerEventTimeTimer(timerTime);

    // Register processing-time timer
    ctx.timerService().registerProcessingTimeTimer(System.currentTimeMillis() + 3600000);
}
```

### Timer Firing

```java
@Override
public void onTimer(long timestamp, OnTimerContext ctx, Collector<Result> out) {
    // Timer fired at 'timestamp'
    // Access state
    // Emit results
}
```

**Use Cases**:
- Timeouts: Clean up state after inactivity
- Periodic tasks: Emit results periodically
- Delayed processing: Process after delay

---

## MarketLag 作业 3 模式：置信度计算

```java
public class ConfidenceCalculator extends KeyedProcessFunction<String, Event, Result> {
    private MapState<String, Double> maxSignalDeltaState;  // outcome -> max_delta

    @Override
    public void open(Configuration config) {
        MapStateDescriptor<String, Double> descriptor =
            new MapStateDescriptor<>("maxSignalDelta", String.class, Double.class);
        maxSignalDeltaState = getRuntimeContext().getMapState(descriptor);
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        String outcome = event.getOutcome();
        double signalDelta = event.getSignalDelta();

        // Read state
        Double currentMax = maxSignalDeltaState.get(outcome);

        // Update state
        if (currentMax == null || signalDelta > currentMax) {
            maxSignalDeltaState.put(outcome, signalDelta);
            currentMax = signalDelta;
        }

        // Calculate confidence (section 12.2)
        double confidence = calculateConfidence(signalDelta, currentMax,
                                                event.getPriceDelta(),
                                                event.getSourceWeightAvg());

        out.collect(new Result(event.getMarket(), confidence));
    }
}
```

**Note**: MarketLag may implement confidence calculation in Flink SQL instead of ProcessFunction, but ProcessFunction provides more control.

---

## 最小可用代码

```java
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.api.common.state.*;
import org.apache.flink.configuration.Configuration;

public class ProcessFunctionDemo {
    public static class MyProcessFunction extends KeyedProcessFunction<String, Event, Result> {
        private ValueState<Double> lastValue;

        @Override
        public void open(Configuration config) {
            ValueStateDescriptor<Double> descriptor =
                new ValueStateDescriptor<>("lastValue", Double.class);
            lastValue = getRuntimeContext().getState(descriptor);
        }

        @Override
        public void processElement(Event event, Context ctx, Collector<Result> out) {
            // Read state
            Double prev = lastValue.value();

            // Process
            if (prev != null) {
                double delta = event.getValue() - prev;
                out.collect(new Result(event.getKey(), delta));
            }

            // Update state
            lastValue.update(event.getValue());

            // Register timer (example)
            ctx.timerService().registerEventTimeTimer(event.getTimestamp() + 3600000);
        }

        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<Result> out) {
            // Timer fired
            // Cleanup or periodic task
        }
    }
}
```

---

## 常见错误

1. **未对流进行 keying**：
   - ❌ 使用 KeyedProcessFunction 但没有 keyBy
   - ✅ 始终对流进行 keying：`stream.keyBy(...).process(...)`

2. **状态未初始化**：
   - ❌ 在调用 open() 之前访问状态
   - ✅ 在 open() 方法中初始化状态

3. **未检查 null**：
   - ❌ `state.value()` 没有 null 检查
   - ✅ 始终检查：`if (state.value() != null) { ... }`

4. **计时器未注册**：
   - ❌ 期望 onTimer 但没有注册计时器
   - ✅ 在 processElement 中注册计时器：`ctx.timerService().registerEventTimeTimer(...)`

5. **错误的计时器类型**：
   - ❌ 对 processing-time 流使用 event-time 计时器
   - ✅ 使计时器类型与时间特征匹配

---

## 触发点：什么时候想到这个概念

在以下情况下考虑 ProcessFunction：
- **自定义状态逻辑**：MarketLag Job 3 可能使用 ProcessFunction 进行 confidence 计算
- **细粒度控制**：需要比 SQL 提供的更多控制
- **基于计时器的处理**：需要超时、周期性任务
- **复杂状态管理**：需要手动管理状态（用于 max_signal_delta 的 MapState）
- **性能**：对于复杂逻辑，ProcessFunction 可能比 SQL 更高效

**在 MarketLag 项目中**：Job 3 可能使用 ProcessFunction 计算 confidence scores，使用 MapState 存储 max_signal_delta。或者，confidence 计算可以在 Flink SQL 中完成。ProcessFunction 提供更多控制和灵活性。

---

## 小结

ProcessFunction 提供对流处理的细粒度控制，可访问状态和计时器。KeyedProcessFunction 启用 keyed state 访问。processElement 处理每个记录，onTimer 处理计时器回调。MarketLag Job 3 可能使用 ProcessFunction 进行带 MapState 的 confidence 计算。理解 ProcessFunction 对于超越 SQL 能力的自定义状态逻辑至关重要。

