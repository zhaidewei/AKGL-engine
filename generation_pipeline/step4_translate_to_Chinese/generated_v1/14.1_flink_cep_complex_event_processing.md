# Flink CEP（复杂事件处理）

**Learning Point**: 14.1 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.2 (DataStream API), understanding of pattern matching
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Flink CEP (Complex Event Processing)**: A library for detecting event patterns in data streams. Enables pattern-based event detection.

**Pattern Definition**: Defining event sequences to detect (e.g., "signal increase followed by price stagnation").

**Pattern Matching**: Flink CEP matches patterns against event streams and emits matches.

**Why Not Used in MVP**: MarketLag uses SQL-based approach instead of CEP for lag detection. CEP is an alternative approach.

---

## Plain Language Explanation

将 Flink CEP 想象成模式检测器：

- **Pattern Definition** = 模式模板："检测此事件序列"
- **Pattern Matching** = 模式检测器："在流中查找匹配"
- **Alternative Approach** = 不同方法："CEP vs 基于 SQL 的方法"

**为什么未使用**：MarketLag 使用 SQL（更简单）而不是 CEP（更复杂）进行 lag detection。

---

## Analogy

如果您了解 **regex pattern matching**（您了解），Flink CEP 类似：
- Regex pattern = CEP pattern（都定义模式）
- Regex matching = CEP matching（都查找匹配）
- String matching = Event stream matching（都匹配数据）

关键区别：CEP 匹配流中的事件序列，而不是文本模式。

---

## Relationship to Already Learned Topics

- **1.2 DataStream API**：CEP 使用 DataStream API
- **12.1 Lag Detection**：CEP 可用于 lag detection（SQL 的替代方案）
- **Pattern Matching**：您已经了解模式匹配 - CEP 将其扩展到流

---

## Pattern Definition: Detecting Event Sequences

### Basic Pattern

**Pattern**: "Signal increase followed by price stagnation"

**CEP Definition**:
```java
Pattern<Event, ?> pattern = Pattern.<Event>begin("signal_increase")
    .where(new SimpleCondition<Event>() {
        @Override
        public boolean filter(Event event) {
            return event.getSignalDelta() > 1.0;
        }
    })
    .next("price_stagnation")
    .where(new SimpleCondition<Event>() {
        @Override
        public boolean filter(Event event) {
            return Math.abs(event.getPriceDelta()) < 0.02;
        }
    });
```

**MarketLag**: Could use this pattern for lag detection (not used in MVP).

---

## Pattern Matching: Detecting Lag Patterns

### CEP Pattern for Lag Detection

**Pattern**: "High signal_delta AND low price_delta"

**Implementation**:
```java
Pattern<JoinedEvent, ?> lagPattern = Pattern.<JoinedEvent>begin("high_signal")
    .where(new SimpleCondition<JoinedEvent>() {
        @Override
        public boolean filter(JoinedEvent event) {
            return event.getSignalDelta() > 1.0;
        }
    })
    .next("low_price_change")
    .where(new SimpleCondition<JoinedEvent>() {
        @Override
        public boolean filter(JoinedEvent event) {
            return Math.abs(event.getPriceDelta()) < 0.02;
        }
    })
    .within(Time.hours(1));  // Within 1 hour

// Apply pattern to stream
PatternStream<JoinedEvent> patternStream = CEP.pattern(joinedStream, lagPattern);

// Process matches
DataStream<LagSignal> lagSignals = patternStream.select(new PatternSelectFunction<JoinedEvent, LagSignal>() {
    @Override
    public LagSignal select(Map<String, List<JoinedEvent>> pattern) {
        JoinedEvent highSignal = pattern.get("high_signal").get(0);
        JoinedEvent lowPrice = pattern.get("low_price_change").get(0);
        return new LagSignal(highSignal.getMarket(), true);
    }
});
```

**MarketLag**: Could use CEP for lag detection (not used in MVP, uses SQL instead).

---

## Why Not Used in MVP: SQL-Based Approach

### SQL Approach (MarketLag Uses)

**Advantages**:
- **Simpler**: SQL is easier to write and maintain
- **Declarative**: Expresses intent clearly
- **Less Code**: Less boilerplate than CEP

**MarketLag**: Uses SQL for lag detection:
```sql
SELECT
    market_slug,
    signal_delta,
    price_delta,
    CASE
        WHEN signal_delta > 1.0 AND ABS(price_delta) < 0.02 THEN true
        ELSE false
    END as lag_flag
FROM joined_events
```

### CEP Approach (Alternative)

**Advantages**:
- **Pattern-Based**: Natural for complex event sequences
- **Temporal Patterns**: Better for time-based patterns
- **Flexible**: More control over pattern matching

**Disadvantages**:
- **More Complex**: Requires more code
- **Less Familiar**: Team may not know CEP

**MarketLag**: Did not use CEP (chose SQL for simplicity).

---

## Minimum Viable Code

```java
import org.apache.flink.cep.PatternStream;
import org.apache.flink.cep.pattern.Pattern;
import org.apache.flink.cep.pattern.conditions.SimpleCondition;

public class CEPLagDetection {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // Create stream
        DataStream<JoinedEvent> stream = ...;

        // Define pattern
        Pattern<JoinedEvent, ?> pattern = Pattern.<JoinedEvent>begin("high_signal")
            .where(new SimpleCondition<JoinedEvent>() {
                @Override
                public boolean filter(JoinedEvent event) {
                    return event.getSignalDelta() > 1.0;
                }
            })
            .next("low_price")
            .where(new SimpleCondition<JoinedEvent>() {
                @Override
                public boolean filter(JoinedEvent event) {
                    return Math.abs(event.getPriceDelta()) < 0.02;
                }
            })
            .within(Time.hours(1));

        // Apply pattern
        PatternStream<JoinedEvent> patternStream = CEP.pattern(stream, pattern);

        // Process matches
        DataStream<LagSignal> lagSignals = patternStream.select(new PatternSelectFunction<JoinedEvent, LagSignal>() {
            @Override
            public LagSignal select(Map<String, List<JoinedEvent>> pattern) {
                // Create lag signal
                return new LagSignal(...);
            }
        });

        env.execute("CEP Lag Detection");
    }
}
```

---

## Common Mistakes

1. **在 SQL 足够时使用 CEP**：
   - ❌ 对简单模式过度使用 CEP
   - ✅ 对简单模式使用 SQL，对复杂序列使用 CEP

2. **不理解模式语义**：
   - ❌ 错误的模式定义（不匹配预期模式）
   - ✅ 理解 CEP 模式语义（begin、next、within）

3. **不处理模式超时**：
   - ❌ 模式永远不完成（缺少 within 子句）
   - ✅ 使用 within() 设置模式超时

4. **不测试模式**：
   - ❌ 模式未测试，可能无法正确匹配
   - ✅ 使用已知数据测试模式

5. **不考虑性能**：
   - ❌ 复杂模式可能很慢
   - ✅ 考虑性能影响

---

## Mind Trigger: When to Think About This

在以下情况下考虑 Flink CEP：
- **复杂事件序列**：需要检测复杂事件模式
- **时间模式**：具有时间约束的模式
- **替代方法**：考虑 CEP 作为 SQL 的替代方案
- **基于模式的逻辑**：适合基于模式的检测
- **MVP 中未使用**：MarketLag 使用 SQL 而不是 CEP

**在 MarketLag 项目中**：CEP 可用于 lag detection（SQL 的替代方案），但在 MVP 中未使用。理解 CEP 有助于评估替代方法。CEP 是可选的，但对复杂事件处理场景有帮助。

---

## Summary

Flink CEP 支持在流中进行基于模式的事件检测。定义模式以检测事件序列。在流上匹配模式。MarketLag 可以使用 CEP 进行 lag detection（SQL 的替代方案），但选择 SQL 以简化。CEP 是可选的，但对复杂事件处理场景有帮助。理解 CEP 有助于评估替代方法。

