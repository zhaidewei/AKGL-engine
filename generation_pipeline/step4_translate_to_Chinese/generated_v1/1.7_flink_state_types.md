# Flink 状态类型

**Learning Point**: 1.7 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.2 (DataStream API), 理解键值存储
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Flink State**: 按键（键控状态）或按算子（算子状态）存储的可变数据，在记录处理过程中持续存在。状态支持有状态的流处理，其中算子行为依赖于先前看到的数据。

**ValueState**: 每个键存储单个值。可以读取和更新该值。

**ListState**: 每个键存储值列表。可以追加值，可以检索整个列表。

**MapState**: 每个键存储键值映射。支持对映射进行 put、get 和 contains 操作。

**ReducingState**: 每个键存储单个聚合值。新值使用 reduce 函数与现有值组合。

**Keyed State**: 作用域为键的状态，仅在键控流中可访问（在 keyBy 之后）。

**Operator State**: 作用域为算子实例的状态，在非键控流中可访问。

---

## Plain Language Explanation

将 Flink 状态想象成每个处理单元的内存库：

- **ValueState** = 每个键的单个存储盒："存储市场 X 的最后价格"
- **ListState** = 每个键的列表存储盒："存储市场 X 看到的所有价格"
- **MapState** = 每个键的字典存储盒："存储市场 X 每个结果的 max_signal_delta"（在 MarketLag 作业 3 中使用）
- **ReducingState** = 每个键的累加器盒："保持市场 X 的运行总和"

**Keyed State**: 每个键（例如，market_slug）都有自己的状态。具有相同键的事件访问相同的状态。

**Operator State**: 每个算子实例一个状态，在所有键之间共享。

---

## Analogy

如果您了解 **Redis** 或 **DynamoDB**（您从 AWS 经验中了解），Flink 状态类似：
- Redis 键值存储 = Flink ValueState（每个键一个值）
- Redis hash = Flink MapState（每个键的键值映射）
- Redis list = Flink ListState（每个键的列表）

关键区别：Flink 状态是自动管理的，会进行 checkpoint，并在故障时恢复。

---

## Relationship to Already Learned Topics

- **1.2 DataStream API**: 状态在 ProcessFunction 中访问（第 4.1 节）
- **1.8 State Backend**: 状态存储在 state backend 中（MarketLag 中使用 RocksDB）
- **1.9 State Access**: 如何读写状态（接下来介绍）
- **1.10 Checkpoints**: 状态包含在 checkpoint 中以实现容错
- **Key-Value Stores**: 与您已经了解的 DynamoDB、Redis 类似的概念

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// ValueState (simplified)
interface ValueState<T> {
    T value();  // Get current value
    void update(T value);  // Update value
    void clear();  // Clear state
}

// MapState (simplified) - Used in MarketLag Job 3
interface MapState<UK, UV> {
    UV get(UK key);  // Get value for map key
    void put(UK key, UV value);  // Put value for map key
    boolean contains(UK key);  // Check if key exists
    void remove(UK key);  // Remove key
    Iterable<Map.Entry<UK, UV>> entries();  // Get all entries
}

// ListState (simplified)
interface ListState<T> {
    void add(T value);  // Add to list
    Iterable<T> get();  // Get all values
    void update(List<T> values);  // Replace entire list
    void clear();  // Clear list
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-runtime/src/main/java/org/apache/flink/runtime/state/ValueState.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-runtime/src/main/java/org/apache/flink/runtime/state/ValueState.java

**Key Classes**:
- `ValueState`: 单值状态
- `MapState`: 键值映射状态（在 MarketLag 中使用）
- `ListState`: 列表状态
- `ReducingState`: 聚合状态

---

## ValueState: Single Value Per Key

**Use Case**: 存储最新值、先前值或单个聚合结果。

**Example**: 为每个市场存储最后价格
```java
public class PriceTracker extends KeyedProcessFunction<String, Event, Result> {
    private ValueState<Double> lastPriceState;

    @Override
    public void open(Configuration config) {
        ValueStateDescriptor<Double> descriptor =
            new ValueStateDescriptor<>("lastPrice", Double.class);
        lastPriceState = getRuntimeContext().getState(descriptor);
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        Double lastPrice = lastPriceState.value();  // Get current state
        if (lastPrice != null) {
            double delta = event.getPrice() - lastPrice;
            out.collect(new Result(event.getMarket(), delta));
        }
        lastPriceState.update(event.getPrice());  // Update state
    }
}
```

---

## ListState: List of Values Per Key

**Use Case**: 存储值的历史记录，维护有序列表。

**Example**: 为每个市场存储最后 N 个价格
```java
private ListState<Double> priceHistoryState;

@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    ListState<Double> history = priceHistoryState;
    history.add(event.getPrice());  // Append to list

    // Keep only last 10
    List<Double> prices = new ArrayList<>();
    for (Double price : history.get()) {
        prices.add(price);
    }
    if (prices.size() > 10) {
        prices = prices.subList(prices.size() - 10, prices.size());
        history.update(prices);
    }
}
```

---

## MapState: Key-Value Map Per Key (MarketLag Job 3 Uses This)

**Use Case**: 存储由辅助键键控的多个值。**MarketLag 为每个市场的每个结果存储 max_signal_delta**。

**Example**: 为每个结果存储最大信号增量
```java
public class ConfidenceCalculator extends KeyedProcessFunction<String, Event, Result> {
    private MapState<String, Double> maxSignalDeltaState;  // outcome -> max_delta

    @Override
    public void open(Configuration config) {
        MapStateDescriptor<String, Double> descriptor =
            new MapStateDescriptor<>("maxSignalDelta", String.class, Double.class);
        maxSignalDeltaState = getRuntimeContext().getMapState(descriptor);
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        String outcome = event.getOutcome();  // e.g., "YES" or "NO"
        Double currentMax = maxSignalDeltaState.get(outcome);  // Get current max

        double signalDelta = event.getSignalDelta();
        if (currentMax == null || signalDelta > currentMax) {
            maxSignalDeltaState.put(outcome, signalDelta);  // Update max
        }

        // Use for confidence calculation (section 12.2)
        double confidence = calculateConfidence(signalDelta, currentMax);
        out.collect(new Result(event.getMarket(), confidence));
    }
}
```

**MarketLag Job 3**: Uses MapState to store `max_signal_delta` keyed by `market_slug|outcome` for confidence score calculation.

---

## ReducingState: Aggregated Value Per Key

**Use Case**: 维护运行聚合（sum、min、max）而不存储所有值。

**Example**: 价格的运行总和
```java
private ReducingState<Double> sumState;

@Override
public void open(Configuration config) {
    ReducingStateDescriptor<Double> descriptor =
        new ReducingStateDescriptor<>("sum",
            (a, b) -> a + b,  // Reduce function
            Double.class);
    sumState = getRuntimeContext().getReducingState(descriptor);
}

@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    sumState.add(event.getPrice());  // Automatically reduces with existing value
    Double currentSum = sumState.get();
    out.collect(new Result(event.getMarket(), currentSum));
}
```

---

## Keyed State vs Operator State

### Keyed State
- **Scope**: 每个键（在 keyBy 之后）
- **Access**: 仅在键控流中（KeyedProcessFunction 等）
- **Partitioning**: 状态按键分区，每个键的状态在一个子任务上
- **Use Case**: 最常见 - 按键聚合、按键历史

```java
// Keyed state - each market_slug has its own state
stream.keyBy(Event::getMarketSlug)
    .process(new KeyedProcessFunction<...>() {
        private ValueState<Double> state;  // One state per market_slug
    });
```

### Operator State
- **Scope**: 每个算子实例
- **Access**: 在任何算子中（非键控）
- **Partitioning**: 状态分布在算子实例之间
- **Use Case**: 罕见 - 算子级元数据、source 偏移量

```java
// Operator state - shared across all keys
stream.process(new ProcessFunction<...>() {
    private ListState<String> operatorState;  // One state per operator instance
});
```

**MarketLag Project**: 使用键控状态（由 market_slug|outcome 键控的 MapState）。

---

## Minimum Viable Code

```java
import org.apache.flink.api.common.state.*;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;

public class StateTypesDemo {
    public static class StatefulProcessor extends KeyedProcessFunction<String, Event, Result> {
        private ValueState<Double> lastValue;
        private MapState<String, Integer> counts;

        @Override
        public void open(Configuration config) {
            // ValueState
            ValueStateDescriptor<Double> valueDesc =
                new ValueStateDescriptor<>("lastValue", Double.class);
            lastValue = getRuntimeContext().getState(valueDesc);

            // MapState
            MapStateDescriptor<String, Integer> mapDesc =
                new MapStateDescriptor<>("counts", String.class, Integer.class);
            counts = getRuntimeContext().getMapState(mapDesc);
        }

        @Override
        public void processElement(Event event, Context ctx, Collector<Result> out) {
            // Read ValueState
            Double prev = lastValue.value();
            if (prev != null) {
                double delta = event.getValue() - prev;
                out.collect(new Result(event.getKey(), "delta", delta));
            }
            lastValue.update(event.getValue());

            // Read/Write MapState
            String category = event.getCategory();
            Integer count = counts.get(category);
            if (count == null) count = 0;
            counts.put(category, count + 1);

            out.collect(new Result(event.getKey(), "count", (double)count));
        }
    }
}
```

---

## State Type Selection Guide

| State Type | Use When | MarketLag Example |
|------------|----------|-------------------|
| **ValueState** | Single value per key | Last price, previous signal |
| **ListState** | History of values | Last N prices, event history |
| **MapState** | Multiple values keyed by secondary key | **max_signal_delta per outcome** (Job 3) |
| **ReducingState** | Running aggregate | Running sum, min, max |
| **AggregatingState** | Complex aggregation | Custom aggregation logic |

**MarketLag Job 3**: Uses MapState to store `max_signal_delta` for each `market_slug|outcome` combination.

---

## Common Mistakes

1. **错误的状态类型**:
   - ❌ 在 ValueState 足够时使用 ListState（浪费）
   - ✅ 选择满足要求的最简单状态类型

2. **不检查 null**:
   - ❌ 不检查 null 就使用 `state.value()`
   - ✅ 始终检查：`if (state.value() != null) { ... }`

3. **状态未初始化**:
   - ❌ 在调用 open() 之前访问状态
   - ✅ 在 open() 方法中初始化状态

4. **在非键控流中使用键控状态**:
   - ❌ 不使用 keyBy 就使用键控状态
   - ✅ 键控状态需要先使用 keyBy()

5. **状态大小无限增长**:
   - ❌ 不清理旧状态
   - ✅ 使用 State TTL（第 4.2 节）使旧状态过期

---

## Mind Trigger: When to Think About This

在以下情况下考虑 Flink 状态类型：
- **存储按键数据**: 需要记住每个键的信息
- **实现有状态逻辑**: 第 4.1 节 ProcessFunction 使用状态
- **选择状态类型**: MarketLag 作业 3 使用 MapState（每个结果的 max_signal_delta）
- **State backend 选择**: 第 1.8 节介绍状态存储位置
- **状态访问模式**: 第 1.9 节介绍如何读写状态

**在 MarketLag 项目中**: 作业 3 使用 MapState 存储历史 max_signal_delta 以进行置信度计算。状态由 market_slug|outcome 键控，TTL 为 7 天（第 4.2 节）。

---

## Summary

Flink 提供多种状态类型：ValueState（单值）、ListState（列表）、MapState（键值映射 - 在 MarketLag 中使用）和 ReducingState（聚合）。状态可以是键控的（按键）或算子级的。MapState 在 MarketLag 作业 3 中用于存储每个结果的 max_signal_delta。理解状态类型有助于为每个用例选择正确的类型，并优化状态大小和访问模式。

