# Flink Local Testing

**Learning Point**: 10.1 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.1 (Flink Architecture), 1.2 (DataStream API), Java basics
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Flink Local Testing**: Testing Flink applications in a local environment (single JVM) without a Flink cluster. Uses LocalEnvironment for execution.

**LocalEnvironment Setup**: Creating a Flink execution environment that runs in the same JVM as the test. No cluster needed.

**Test Data Generation**: Creating test streams with known data for testing Flink operators and logic.

**Unit Testing Flink Operators**: Testing individual operators (map, filter, etc.) in isolation.

**Testing Stateful Functions**: Verifying stateful operators (ProcessFunction, windows) work correctly, including state verification.

---

## Plain Language Explanation

将 Flink 本地测试想象成在车库中测试汽车：

- **LocalEnvironment** = 车库："在您自己的环境中测试，不需要赛道"
- **Test Data** = 测试场景："创建已知数据进行测试"
- **Unit Testing** = 组件测试："分别测试每个部分"
- **State Testing** = 内存测试："测试状态是否正确记住"

**Why Needed**: MarketLag 需要在部署到 Confluent Cloud 之前在本地测试 Flink 作业。

---

## Analogy

如果您了解 **unit testing**（您了解），Flink 本地测试是类似的：
- Unit tests = Flink local tests（两者都在隔离中测试）
- Test data = Mock data（两者都使用已知数据）
- Assertions = Result verification（两者都验证正确性）

关键区别：Flink 使用无界数据测试流处理逻辑。

---

## Relationship to Already Learned Topics

- **1.1 Flink Architecture**: LocalEnvironment 在单个 JVM 中运行
- **1.2 DataStream API**: 在本地测试 DataStream 操作
- **4.1 ProcessFunction**: 在本地测试 ProcessFunction 逻辑
- **Testing**: 您已经了解测试 - Flink 测试应用相同的原则

---

## LocalEnvironment Setup for Testing

### Basic Setup

```java
import org.apache.flink.streaming.api.environment.LocalStreamEnvironment;

public class FlinkLocalTest {
    @Test
    public void testLocalEnvironment() throws Exception {
        // Create local environment
        StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();

        // Set parallelism for testing
        env.setParallelism(1);  // Single thread for deterministic testing

        // Your test logic
        DataStream<String> stream = env.fromElements("test1", "test2");
        stream.print();

        env.execute("Local Test");
    }
}
```

**MarketLag**: Uses LocalEnvironment for testing before deployment.

---

## Test Data Generation: Creating Test Streams

### From Collections

```java
// Create test stream from collection
DataStream<Event> testStream = env.fromElements(
    new Event("market1", 1.0, 1000L),
    new Event("market1", 2.0, 2000L),
    new Event("market2", 1.5, 3000L)
);
```

### From Test Sources

```java
// Create test source
DataStream<Event> testStream = env.addSource(new SourceFunction<Event>() {
    @Override
    public void run(SourceContext<Event> ctx) throws Exception {
        // Emit test data
        ctx.collect(new Event("market1", 1.0, 1000L));
        ctx.collect(new Event("market1", 2.0, 2000L));
    }

    @Override
    public void cancel() {}
});
```

**MarketLag**: Generates test data for RSS events and Polymarket prices.

---

## Unit Testing Flink Operators

### Testing Map Operator

```java
@Test
public void testMapOperator() throws Exception {
    StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();
    env.setParallelism(1);

    DataStream<String> input = env.fromElements("hello", "world");
    DataStream<String> output = input.map(s -> s.toUpperCase());

    // Collect results
    List<String> results = new ArrayList<>();
    output.addSink(new SinkFunction<String>() {
        @Override
        public void invoke(String value, Context context) {
            results.add(value);
        }
    });

    env.execute();

    // Verify results
    assertEquals(Arrays.asList("HELLO", "WORLD"), results);
}
```

**MarketLag**: Tests operators like keyword scoring, signal calculation.

---

## Testing Stateful Functions: State Verification

### Testing ProcessFunction with State

```java
@Test
public void testProcessFunctionState() throws Exception {
    StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();
    env.setParallelism(1);

    DataStream<Event> input = env.fromElements(
        new Event("market1", 1.0),
        new Event("market1", 2.0)
    );

    // Test ProcessFunction
    DataStream<Result> output = input
        .keyBy(Event::getMarket)
        .process(new MyProcessFunction());

    // Collect and verify
    List<Result> results = new ArrayList<>();
    output.addSink(new SinkFunction<Result>() {
        @Override
        public void invoke(Result value, Context context) {
            results.add(value);
        }
    });

    env.execute();

    // Verify state was used correctly
    assertEquals(2, results.size());
    // Verify delta calculation
    assertEquals(1.0, results.get(1).getDelta(), 0.001);
}
```

**MarketLag**: Tests ProcessFunction (if used) for confidence calculation with state.

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.sink.SinkFunction;
import org.junit.Test;
import java.util.ArrayList;
import java.util.List;
import static org.junit.Assert.assertEquals;

public class FlinkLocalTestingDemo {
    @Test
    public void testWindowAggregation() throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();
        env.setParallelism(1);

        // Create test data
        DataStream<Event> events = env.fromElements(
            new Event("market1", 1.0, 1000L),
            new Event("market1", 2.0, 2000L),
            new Event("market1", 3.0, 3000L)
        );

        // Assign timestamps
        DataStream<Event> withTimestamps = events.assignTimestampsAndWatermarks(
            WatermarkStrategy
                .<Event>forBoundedOutOfOrderness(Duration.ofSeconds(1))
                .withTimestampAssigner((e, ts) -> e.getTimestamp())
        );

        // Window aggregation
        DataStream<Result> windowed = withTimestamps
            .keyBy(Event::getMarket)
            .window(TumblingEventTimeWindows.of(Time.seconds(2)))
            .aggregate(new MyAggregateFunction());

        // Collect results
        List<Result> results = new ArrayList<>();
        windowed.addSink(new SinkFunction<Result>() {
            @Override
            public void invoke(Result value, Context context) {
                results.add(value);
            }
        });

        env.execute();

        // Verify results
        assertEquals(2, results.size());  // Two windows
    }
}
```

---

## Common Mistakes

1. **Not setting parallelism to 1**:
   - ❌ Parallelism > 1 (non-deterministic results)
   - ✅ Set parallelism = 1 for deterministic testing

2. **Not collecting results**:
   - ❌ Using print() (can't verify programmatically)
   - ✅ Use SinkFunction to collect results for verification

3. **Not assigning timestamps**:
   - ❌ Testing event-time windows without timestamps
   - ✅ Always assign timestamps for event-time testing

4. **Not waiting for execution**:
   - ❌ Not calling env.execute() (test completes before processing)
   - ✅ Always call env.execute() in tests

5. **Not verifying state**:
   - ❌ Only verifying output, not state
   - ✅ Verify state values in stateful functions

---

## Mind Trigger: When to Think About This

Think about Flink local testing when:
- **Developing Flink jobs**: Test locally before deployment
- **Debugging logic**: Local testing helps debug issues
- **Validating logic**: Verify operators work correctly
- **State verification**: Test stateful functions with state
- **Integration testing**: Section 10.2 covers integration testing

**In MarketLag project**: Tests all three jobs locally before deploying to Confluent Cloud. Tests window aggregation (Job 1), joins (Job 3), and stateful logic. Understanding local testing is essential for development and debugging.

---

## Summary

Flink local testing enables testing Flink applications in a local environment without a cluster. Use LocalEnvironment for execution. Generate test data from collections or test sources. Test operators and stateful functions, verify state. MarketLag tests all jobs locally before deployment. Understanding local testing is essential for development and debugging.

