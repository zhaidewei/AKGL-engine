# Flink SQL Equi-Join

**Learning Point**: 3.3 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.3 (Table API/SQL), SQL JOIN knowledge (you already have this)
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Equi-Join**: join 条件使用相等（=）匹配两个表中行的 join 操作。join 条件的两边必须具有相等的值才能成功 join。

**INNER JOIN**: 仅返回两个表中都有匹配的行。

**LEFT JOIN**: 返回左表的所有行，以及右表的匹配行。如果没有匹配，右表列为 NULL。

**Join Condition**: 指定如何匹配行的 ON 子句（例如，`ON left.key = right.key`）。

**Join Performance**: Equi-joins 可以使用 broadcast joins（小表）或 regular joins（两个表都很大）进行优化。

---

## Plain Language Explanation

将 equi-join 想象成匹配两个电子表格中的记录：

- **Equi-Join** = 按精确值匹配："查找 market_slug 匹配的行"
- **INNER JOIN** = 两者必须匹配：仅返回两个表中都有匹配 market_slug 的行
- **LEFT JOIN** = 左表优先：返回左表的所有行，如果可用则匹配右表

**为什么需要**：MarketLag Job 3 将 RSS signals 与 Polymarket prices 进行 join - 两者都有 market_slug，join 它们以组合 signals 和 prices。

---

## Analogy

如果您了解 **SQL JOINs**（您了解），Flink 的 equi-join 是相同的：
- SQL `INNER JOIN ... ON left.key = right.key` = Flink equi-join
- SQL `LEFT JOIN` = Flink LEFT JOIN

关键区别：Flink joins 在无界流上进行，因此它们是连续的，并在新数据到达时产生结果。

---

## Relationship to Already Learned Topics

- **1.3 Table API/SQL**: Equi-join 使用 Flink SQL 语法
- **3.2 Temporal Joins**: 不同的 join 类型（MarketLag 中未使用）
- **SQL**: 您已经了解 JOIN 语法 - Flink 使用相同的语法
- **2.2 Kafka Table Connector**: Join 从 Kafka topics 创建的表

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```sql
-- Equi-join (simplified parsing)
SELECT *
FROM left_table l
INNER JOIN right_table r
ON l.key = r.key
-- Parses to: EquiJoinOperator
-- Matches rows where left.key equals right.key
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecJoin.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecJoin.java

---

## Equi-Join Syntax: INNER JOIN, LEFT JOIN

### INNER JOIN

Returns only rows where there is a match in both tables:

```sql
SELECT
    l.market_slug,
    l.signal,
    r.price
FROM left_table l
INNER JOIN right_table r
ON l.market_slug = r.market_slug;
```

**MarketLag Job 3**: Uses INNER JOIN to combine RSS signals and prices.

### LEFT JOIN

Returns all rows from left table, matching rows from right:

```sql
SELECT
    l.market_slug,
    l.signal,
    r.price
FROM left_table l
LEFT JOIN right_table r
ON l.market_slug = r.market_slug;
```

**使用场景**：当您希望即使价格缺失也返回所有 signals 时（MarketLag 可以将其用于错误处理）。

---

## Join Conditions: ON Clause with Equality

### Single Key Join

```sql
ON left.market_slug = right.market_slug
```

匹配 market_slug 值相等的行。

### Multiple Key Join

```sql
ON left.market_slug = right.market_slug
   AND left.window_start = right.event_time
```

匹配两个条件都为真的行。

**MarketLag Job 3**: Uses both market_slug and window_start = event_time for join.

---

## Join Performance: Broadcast vs Regular Join

### Broadcast Join

When one table is small, Flink can broadcast it to all subtasks:

```sql
-- Flink automatically chooses broadcast if one table is small
SELECT *
FROM large_table l
INNER JOIN small_table s
ON l.key = s.key;
```

**优化**：小表被广播到所有子任务，避免 shuffle。

### Regular Join

当两个表都很大时，Flink 使用 regular join（两边都 shuffle）：

```sql
-- Both tables are large, regular join
SELECT *
FROM large_table1 l1
INNER JOIN large_table2 l2
ON l1.key = l2.key;
```

**MarketLag Job 3**: Both RSS signals and prices are large, uses regular join.

---

## MarketLag Job 3 Example

```sql
SELECT
    r.market_slug,
    r.window_start,
    r.source_weighted_signal as rss_signal,
    p.price,
    p.price_delta,
    (r.source_weighted_signal - LAG(r.source_weighted_signal)
      OVER (PARTITION BY r.market_slug ORDER BY r.window_start)) as signal_delta
FROM rss_signals_hourly r
INNER JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start = p.event_time
WHERE r.source_weighted_signal IS NOT NULL
  AND p.price IS NOT NULL;
```

**Key Points**:
- **INNER JOIN**: Only returns rows where both RSS signal and price exist
- **Join Keys**: `market_slug` (matches market) and `window_start = event_time` (matches time)
- **LAG Function**: Calculates signal_delta (section 3.4 covers this)

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;

public class EquiJoinDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);

        // Create left table
        tableEnv.executeSql(
            "CREATE TABLE signals (" +
            "  market_slug STRING," +
            "  window_start TIMESTAMP(3)," +
            "  signal DOUBLE" +
            ") WITH ('connector' = 'kafka', ...)"
        );

        // Create right table
        tableEnv.executeSql(
            "CREATE TABLE prices (" +
            "  market_slug STRING," +
            "  event_time TIMESTAMP(3)," +
            "  price DOUBLE" +
            ") WITH ('connector' = 'kafka', ...)"
        );

        // Equi-join
        tableEnv.executeSql(
            "CREATE TABLE joined AS " +
            "SELECT " +
            "  s.market_slug," +
            "  s.window_start," +
            "  s.signal," +
            "  p.price " +
            "FROM signals s " +
            "INNER JOIN prices p " +
            "ON s.market_slug = p.market_slug " +
            "  AND s.window_start = p.event_time"
        );

        env.execute("Equi-Join Demo");
    }
}
```

---

## Common Mistakes

1. **Join 条件不是 equi-join**：
   - ❌ `ON left.time > right.time`（不是 equi-join，使用 interval join）
   - ✅ 使用相等：`ON left.key = right.key`

2. **缺少 join keys**：
   - ❌ 仅按 market_slug join，缺少时间对齐
   - ✅ 同时按两者 join：`ON market_slug = market_slug AND window_start = event_time`

3. **NULL 处理**：
   - ❌ 未处理 join keys 中的 NULL 值
   - ✅ 过滤 NULL：`WHERE market_slug IS NOT NULL`

4. **Join 性能**：
   - ❌ 不理解 broadcast vs regular join
   - ✅ 理解 Flink 何时选择 broadcast（小表）

5. **流式 join 语义**：
   - ❌ 期望立即获得所有历史匹配
   - ✅ 流式 joins 在新数据到达时产生结果

---

## Mind Trigger: When to Think About This

在以下情况下考虑 equi-join：
- **Join 流**：MarketLag Job 3 将 RSS signals 与 prices 进行 join
- **按 key 匹配**：需要通过精确的 key 值匹配两个表中的行
- **组合数据源**：Join 来自不同 Kafka topics 的数据
- **Join 性能**：理解 broadcast vs regular join 有助于优化
- **错误处理**：LEFT JOIN 可以处理缺失数据（第 9.4 节）

**在 MarketLag 项目中**：Job 3 使用 INNER JOIN 将 RSS signals（rss_signals_hourly）与 Polymarket prices（polymarket_price_hourly）组合。按 market_slug 和 window_start = event_time 进行 join。这是组合 signals 和 prices 以进行 lag 检测的核心模式。

---

## Summary

Flink SQL equi-join 使用相等条件匹配两个表中的行。INNER JOIN 仅返回匹配的行，LEFT JOIN 返回所有左行。Join 条件使用带有等式的 ON 子句。Flink 使用 broadcast（小表）或 regular join（两个都很大）优化 joins。MarketLag Job 3 使用 INNER JOIN 按 market_slug 和时间对齐组合 RSS signals 和 prices。理解 equi-joins 对于组合来自多个流的数据至关重要。

