# Confidence Score Calculation Formula

**Learning Point**: 12.2 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 12.1 (Lag Detection), 1.7 (State Types), 1.9 (State Access), understanding of weighted formulas
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Confidence Score**: A numerical value [0, 1] that quantifies the reliability of a lag signal. Higher confidence indicates more reliable lag detection.

**Confidence Formula**: Weighted combination of three factors:
- Signal delta normalization: `(signal_delta / max_signal_delta) * 0.5`
- Price stability: `(1 - |price_delta|) * 0.3`
- Source credibility: `source_weight_avg * 0.2`

**Max Signal Delta**: Historical maximum signal delta for normalization. Stored in MapState (section 1.7) with 7-day TTL (section 4.2).

**Factor Normalization**: Scaling each factor to [0, 1] range before weighting.

---

## Plain Language Explanation

将 confidence score 想象成质量评级：

- **Signal Delta Factor**（50% 权重）："与历史最大值相比，此 signal 变化有多显著？"
- **Price Stability Factor**（30% 权重）："价格有多稳定？（更稳定 = 更高的 confidence）"
- **Source Credibility Factor**（20% 权重）："新闻来源有多可信？"

**公式**：将这三个因子与权重组合，产生 0 到 1 的 confidence score。

---

## Analogy

想象给餐厅评分：
- **食物质量**（50%）：食物有多好？（signal delta）
- **服务**（30%）：服务有多一致？（price stability）
- **氛围**（20%）：氛围有多好？（source credibility）

Confidence score 就像结合所有因子的总体评分。

---

## Relationship to Already Learned Topics

- **12.1 Lag Detection**：Confidence score 量化 lag signals
- **1.7 State Types**：使用 MapState 存储 max_signal_delta
- **1.9 State Access**：从 state 读取/写入 max_signal_delta
- **4.2 State TTL**：历史 state 的 7 天 TTL
- **Weighted Formulas**：类似于您已经了解的加权平均值

---

## Pseudocode (From Project Design)

Based on MarketLag project design:

```java
// Confidence calculation (simplified)
double calculateConfidence(
    double signalDelta,
    double maxSignalDelta,
    double priceDelta,
    double sourceWeightAvg
) {
    // Factor 1: Signal delta normalization (50% weight)
    double signalFactor = (signalDelta / maxSignalDelta) * 0.5;

    // Factor 2: Price stability (30% weight)
    double priceFactor = (1 - Math.abs(priceDelta)) * 0.3;

    // Factor 3: Source credibility (20% weight)
    double sourceFactor = sourceWeightAvg * 0.2;

    // Sum and cap at 1.0
    double confidence = Math.min(1.0, signalFactor + priceFactor + sourceFactor);

    return confidence;
}
```

---

## Source Code References

**Project Design**: `generation_pipeline/step1_output_project_design/output_project_design_v5.md`

**Implementation**: This formula is implemented in MarketLag Job 3, likely in a ProcessFunction (section 4.1) that accesses MapState (section 1.9).

---

## Confidence Score Calculation Formula

### Complete Formula

```
confidence = min(1.0,
    (signal_delta / max_signal_delta) * 0.5 +
    (1 - |price_delta|) * 0.3 +
    (source_weight_avg) * 0.2
)
```

### Formula Breakdown

1. **Signal Delta Factor** (50% weight):
   ```
   (signal_delta / max_signal_delta) * 0.5
   ```
   - Normalizes signal_delta by historical max
   - Higher signal_delta relative to max → Higher confidence

2. **Price Stability Factor** (30% weight):
   ```
   (1 - |price_delta|) * 0.3
   ```
   - More stable price (smaller |price_delta|) → Higher confidence
   - Price delta = 0 → Full 0.3 points
   - Price delta = 1 → 0 points

3. **Source Credibility Factor** (20% weight):
   ```
   source_weight_avg * 0.2
   ```
   - Higher source credibility → Higher confidence
   - Reuters (1.0) → Full 0.2 points
   - Others (0.7) → 0.14 points

4. **Final Score**:
   ```
   min(1.0, sum_of_factors)
   ```
   - Caps confidence at 1.0
   - Sum of factors can exceed 1.0, so min() ensures [0, 1] range

---

## Factor Normalization: Scaling to [0,1] Range

### Signal Delta Normalization

**Problem**: signal_delta can be any value, need to normalize to [0, 1].

**Solution**: Divide by max_signal_delta (historical maximum).

**Example**:
- signal_delta = 2.0
- max_signal_delta = 4.0
- Normalized = 2.0 / 4.0 = 0.5

**Edge Case**: If max_signal_delta = 0 (no history), use signal_delta directly or default to 0.

### Price Delta Normalization

**Problem**: |price_delta| can be > 1, need to normalize.

**Solution**: `1 - |price_delta|`, but this can be negative if |price_delta| > 1.

**Fix**: Use `max(0, 1 - |price_delta|)` to ensure non-negative.

**Example**:
- price_delta = 0.01
- Normalized = 1 - 0.01 = 0.99

### Source Weight Normalization

**Already Normalized**: source_weight_avg is already [0, 1] (Reuters=1.0, others=0.7).

---

## Historical Baseline: Using max_signal_delta for Normalization

### Storing max_signal_delta in MapState

```java
// In ProcessFunction (section 4.1)
private MapState<String, Double> maxSignalDeltaState;  // outcome -> max_delta

@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    String outcome = event.getOutcome();
    double signalDelta = event.getSignalDelta();

    // Read current max
    Double currentMax = maxSignalDeltaState.get(outcome);

    // Update if current is larger
    if (currentMax == null || signalDelta > currentMax) {
        maxSignalDeltaState.put(outcome, signalDelta);
        currentMax = signalDelta;
    }

    // Use for confidence calculation
    double confidence = calculateConfidence(signalDelta, currentMax, ...);
}
```

**MarketLag Project**: Stores max_signal_delta per outcome (YES/NO) in MapState with 7-day TTL.

---

## Minimum Viable Code

```java
public class ConfidenceCalculator {
    public double calculateConfidence(
            double signalDelta,
            double maxSignalDelta,
            double priceDelta,
            double sourceWeightAvg) {

        // Factor 1: Signal delta normalization (50%)
        double signalFactor = 0.0;
        if (maxSignalDelta > 0) {
            signalFactor = (signalDelta / maxSignalDelta) * 0.5;
        }

        // Factor 2: Price stability (30%)
        double priceFactor = Math.max(0, 1 - Math.abs(priceDelta)) * 0.3;

        // Factor 3: Source credibility (20%)
        double sourceFactor = sourceWeightAvg * 0.2;

        // Sum and cap at 1.0
        double confidence = Math.min(1.0, signalFactor + priceFactor + sourceFactor);

        return confidence;
    }
}
```

---

## Example Calculations

### Example 1: High Confidence

- signal_delta = 3.0
- max_signal_delta = 4.0
- price_delta = 0.01
- source_weight_avg = 1.0 (Reuters)

**Calculation**:
- Signal factor: (3.0 / 4.0) * 0.5 = 0.375
- Price factor: (1 - 0.01) * 0.3 = 0.297
- Source factor: 1.0 * 0.2 = 0.2
- Confidence: min(1.0, 0.375 + 0.297 + 0.2) = **0.872**

### Example 2: Medium Confidence

- signal_delta = 1.5
- max_signal_delta = 3.0
- price_delta = 0.015
- source_weight_avg = 0.7

**Calculation**:
- Signal factor: (1.5 / 3.0) * 0.5 = 0.25
- Price factor: (1 - 0.015) * 0.3 = 0.2955
- Source factor: 0.7 * 0.2 = 0.14
- Confidence: min(1.0, 0.25 + 0.2955 + 0.14) = **0.686**

### Example 3: Low Confidence

- signal_delta = 1.2
- max_signal_delta = 5.0
- price_delta = 0.03
- source_weight_avg = 0.7

**Calculation**:
- Signal factor: (1.2 / 5.0) * 0.5 = 0.12
- Price factor: (1 - 0.03) * 0.3 = 0.291
- Source factor: 0.7 * 0.2 = 0.14
- Confidence: min(1.0, 0.12 + 0.291 + 0.14) = **0.551**

---

## Common Mistakes

1. **除以零**：
   - ❌ 当 max_signal_delta = 0 时使用 `signal_delta / max_signal_delta`
   - ✅ 检查：`if (max_signal_delta > 0) { ... }`

2. **负价格因子**：
   - ❌ 当 |price_delta| > 1 时使用 `(1 - |price_delta|)`
   - ✅ 使用：`max(0, 1 - |price_delta|)`

3. **不更新 max_signal_delta**：
   - ❌ 使用过时的 max_signal_delta
   - ✅ 当 signal_delta > 当前最大值时始终更新 MapState

4. **错误的权重**：
   - ❌ 使用相等权重（每个 0.33）
   - ✅ 使用正确的权重：0.5、0.3、0.2

5. **不限制在 1.0**：
   - ❌ Confidence > 1.0
   - ✅ 始终使用 `min(1.0, sum)`

---

## Mind Trigger: When to Think About This

在以下情况下考虑 confidence score：
- **实现 Job 3**：Confidence 计算是 lag detection 的一部分
- **存储 max_signal_delta**：第 1.7 节（MapState）、第 1.9 节（state access）
- **State TTL**：第 4.2 节 - 历史 state 的 7 天 TTL
- **ProcessFunction**：第 4.1 节 - 在 ProcessFunction 中计算 confidence
- **调整权重**：0.5、0.3、0.2 是可调参数

**在 MarketLag 项目中**：Confidence score 量化 lag signals 的可靠性。在 Job 3 中使用 MapState 存储 max_signal_delta 进行计算。与 lag signals 一起存储在 Supabase 中，用于过滤和排序。

---

## Summary

Confidence score 使用加权公式量化 lag signal 可靠性：signal delta 归一化（50%）、price stability（30%）和 source credibility（20%）。Max_signal_delta 存储在 MapState 中用于归一化。公式将 confidence 限制在 1.0。这在 MarketLag Job 3 中实现，可能在访问 MapState 的 ProcessFunction 中。理解 confidence scoring 有助于过滤和排序 lag signals。

