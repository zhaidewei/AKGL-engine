# Watermarks in Flink

**Learning Point**: 1.5 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.4 (Time Concepts), 理解事件时间处理
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Watermark**: 流经数据流的特殊时间戳，表示不应再到达早于该 watermark 的事件。Watermark 使 Flink 能够确定何时可以关闭时间窗口并发出结果。

**Watermark Delay**: Flink 等待延迟到达事件的最大时间量。在 watermark 之后到达的事件被视为"延迟"，并根据允许的延迟策略处理。

**Watermark Generation**: 创建 watermark 的过程，可以是周期性的（固定间隔）或基于标点符号的（基于数据特征）。

---

## Plain Language Explanation

将 watermark 想象成"不接受延迟条目"的截止日期：

- **Watermark** = 一个标记，表示"我们已经收到了直到这个时间的所有事件"
- **Watermark Delay** = 在声明"不再有延迟事件"之前我们等待多长时间（例如，等待 5 分钟以接收延迟数据）
- **Late Data** = 在 watermark 之后到达的事件（就像在截止日期后提交作业）

**为什么需要**: 在分布式系统中，事件可能乱序到达。Watermark 告诉 Flink"我们确信已经看到了时间 T 的所有事件，因此可以关闭时间 T 的窗口并发出结果。"

---

## Analogy

想象一个餐厅厨房准备每小时餐点批次：

- **Watermark** = 厨房计时器："我们已经收到了下午 2 点批次的所有订单，开始烹饪"
- **Watermark Delay (5 min)** = 宽限期："再等 5 分钟，以防有人打电话下延迟订单"
- **Late Orders** = 宽限期后到达的订单："抱歉，该批次已经在烹饪了"

没有 watermark，厨房会永远等待，永远不知道何时开始烹饪。有了 watermark，它知道"我们已经等得够久了，开始烹饪。"

---

## Relationship to Already Learned Topics

- **1.4 Time Concepts**: Watermark 与事件时间一起工作 - 它们是事件时间域中的时间戳
- **1.6 Windows**: 窗口使用 watermark 来确定何时触发（关闭并发出结果）
- **Kafka**: 来自 Kafka 分区的乱序数据需要 watermark 以实现正确的窗口化
- **Distributed Systems**: 网络延迟导致乱序到达 - watermark 处理这种情况

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// Watermark (simplified)
class Watermark {
    long timestamp;  // "No events before this time should arrive"

    boolean isEventLate(Event event) {
        return event.getTimestamp() < this.timestamp;
    }
}

// WatermarkGenerator (simplified)
class PeriodicWatermarkGenerator implements WatermarkGenerator<Event> {
    long maxTimestamp = Long.MIN_VALUE;
    long maxOutOfOrderness = 5 * 60 * 1000;  // 5 minutes

    @Override
    public void onEvent(Event event, long eventTimestamp, WatermarkOutput output) {
        maxTimestamp = Math.max(maxTimestamp, eventTimestamp);
    }

    @Override
    public void onPeriodicEmit(WatermarkOutput output) {
        // Emit watermark: current max - delay
        long watermark = maxTimestamp - maxOutOfOrderness;
        output.emitWatermark(new Watermark(watermark));
    }
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/watermark/Watermark.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/watermark/Watermark.java

**Key Classes**:
- `Watermark`: The watermark timestamp
- `WatermarkGenerator`: Interface for generating watermarks
- `WatermarkStrategy`: Strategy for watermark generation

---

## Watermark Concept: What It Represents

时间戳为 `T` 的 watermark 表示：
- "我们相信时间戳 < T 的所有事件都已收到"
- "时间戳 >= T 的事件可能仍会到达"
- "在 T 之前结束的窗口可以关闭并发出结果"

**示例**:
- 当前 watermark: 14:05:00
- 这意味着："我们已经看到了直到 14:00:00 的所有事件（14:05 - 5 分钟延迟）"
- 窗口 [14:00:00, 15:00:00) 可以在 watermark >= 15:00:00 时关闭

---

## Watermark Generation Strategies

### 1. Periodic Watermarks (Most Common)

以固定间隔生成 watermark（例如，每 200 毫秒）。

```java
WatermarkStrategy.<Event>forBoundedOutOfOrderness(Duration.ofMinutes(5))
    .withTimestampAssigner((event, timestamp) -> event.getEventTime());
```

**工作原理**:
1. 跟踪到目前为止看到的最大事件时间戳
2. 每 200 毫秒，发出 watermark = max_timestamp - delay
3. 无限期继续

**Use Case**: MarketLag 项目使用此方式 - RSS 事件延迟 5 分钟。

### 2. Punctuated Watermarks

基于数据特征生成 watermark（例如，特殊标记事件）。

```java
WatermarkStrategy.<Event>forGenerator(ctx ->
    new PunctuatedGenerator() {
        @Override
        public void onEvent(Event event, long eventTimestamp, WatermarkOutput output) {
            if (event.isEndOfBatch()) {
                // Emit watermark when we see end-of-batch marker
                output.emitWatermark(new Watermark(eventTimestamp));
            }
        }
    }
);
```

**Use Case**: 当您有明确标记指示"此时间段不再有数据"时。

---

## Watermark Propagation Through Operators

Watermarks flow through the operator graph:

```
Source → Map → Filter → Window → Sink
  WM1      WM1    WM1     WM1     WM1
```

**Key Points**:
- Watermarks are broadcast to all downstream operators
- Each operator forwards the minimum watermark from all inputs
- Operators can delay watermarks (e.g., buffering for joins)

**Example**:
- Source emits watermark 14:05
- Map operator receives it, processes events, forwards watermark 14:05
- Window operator receives it, checks if any windows can close

---

## Allowed Lateness and Late Data Handling

### Allowed Lateness

Even after a window closes, Flink can accept late data for a grace period:

```java
.window(TumblingEventTimeWindows.of(Time.hours(1)))
.allowedLateness(Time.minutes(10))  // Accept data 10 min after window closes
```

**How it works**:
- Window closes at watermark = 15:00 (for window [14:00, 15:00))
- Allowed lateness = 10 minutes
- Late events with timestamp in [14:00, 15:00) arriving before watermark = 15:10 are still processed
- Results are updated (side output) when late data arrives

### Late Data Handling Options

1. **Update Results** (default with allowed lateness):
   - Window results are updated when late data arrives
   - Use side outputs to distinguish on-time vs late results

2. **Side Output**:
   ```java
   OutputTag<Event> lateTag = new OutputTag<Event>("late"){};
   windowedStream.sideOutputLateData(lateTag);
   ```

3. **Drop** (no allowed lateness):
   - Late data is simply dropped
   - Use when late data is not important

---

## Watermark Configuration in Flink SQL

### Basic Watermark Declaration

```sql
CREATE TABLE rss_events (
    title STRING,
    published_at TIMESTAMP(3),  -- Event time column
    source STRING,
    WATERMARK FOR published_at AS published_at - INTERVAL '5' MINUTE
) WITH (...);
```

**Syntax**: `WATERMARK FOR time_column AS time_column - INTERVAL 'N' MINUTE`

**MarketLag Project**: Uses 5-minute watermark delay:
```sql
WATERMARK FOR published_at AS published_at - INTERVAL '5' MINUTE
```

This means: "Wait 5 minutes after seeing an event before considering earlier windows complete."

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import java.time.Duration;

public class WatermarkDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // Create source with out-of-order events
        DataStream<Event> events = env.addSource(new SourceFunction<Event>() {
            @Override
            public void run(SourceContext<Event> ctx) throws Exception {
                // Events arrive out of order
                ctx.collectWithTimestamp(new Event("A", 1000L), 1000L);  // Time 1s
                ctx.collectWithTimestamp(new Event("C", 3000L), 3000L);  // Time 3s (early!)
                ctx.collectWithTimestamp(new Event("B", 2000L), 2000L);  // Time 2s (late!)
                ctx.collectWithTimestamp(new Event("D", 4000L), 4000L);  // Time 4s
            }
        });

        // Assign watermarks with 1 second delay
        DataStream<Event> withWatermarks = events.assignTimestampsAndWatermarks(
            WatermarkStrategy
                .<Event>forBoundedOutOfOrderness(Duration.ofSeconds(1))
                .withTimestampAssigner((event, timestamp) -> event.getTimestamp())
        );

        // Window aggregation (will trigger when watermark passes window end)
        withWatermarks
            .keyBy(Event::getKey)
            .window(TumblingEventTimeWindows.of(Time.seconds(2)))
            .sum("value")
            .print();

        env.execute("Watermark Demo");
    }
}
```

---

## Watermark Delay Tuning

### Too Small Delay
- ❌ Windows close too early, many late events
- ❌ Results incomplete, need frequent updates
- **Symptom**: High late data rate

### Too Large Delay
- ❌ Windows stay open too long, high latency
- ❌ Results delayed unnecessarily
- **Symptom**: High end-to-end latency

### Optimal Delay
- ✅ Balance between completeness and latency
- ✅ Based on data source characteristics (network delays, processing delays)
- **MarketLag Project**: 5 minutes is reasonable for RSS feeds (network delays, API polling intervals)

---

## Common Mistakes

1. **不为事件时间窗口设置 watermark**:
   - ❌ 使用没有 watermark 的事件时间窗口
   - ✅ 使用事件时间窗口时始终设置 watermark

2. **错误的 watermark 延迟**:
   - ❌ 使用 0 延迟（窗口立即关闭，错过延迟数据）
   - ✅ 根据数据源特征设置延迟（MarketLag 使用 5 分钟）

3. **SQL 中的 watermark 语法错误**:
   - ❌ `WATERMARK FOR time_col AS time_col - 5 MINUTE` (缺少 INTERVAL)
   - ✅ `WATERMARK FOR time_col AS time_col - INTERVAL '5' MINUTE`

4. **不处理延迟数据**:
   - ❌ 忽略延迟数据，得到不完整的结果
   - ✅ 对延迟数据使用允许的延迟或侧输出

5. **Watermark 不传播**:
   - ❌ 自定义算子阻塞 watermark
   - ✅ 确保算子正确转发 watermark

---

## Mind Trigger: When to Think About This

在以下情况下考虑 watermark：
- **设置事件时间窗口**: 第 1.6 节需要 watermark 来触发窗口
- **处理乱序数据**: Kafka 分区、网络延迟导致乱序到达
- **调整延迟与完整性**: 平衡窗口延迟与数据完整性
- **调试窗口问题**: 窗口未触发？检查 watermark 生成
- **配置 Flink SQL**: CREATE TABLE 语句需要 WATERMARK 声明

**在 MarketLag 项目中**: 所有三个作业都使用 5 分钟 watermark 延迟。RSS 事件和 Polymarket 价格都在其表定义中声明了 watermark。当 watermark 超过窗口结束时间时，窗口触发。

---

## Summary

Watermark 使 Flink 能够确定事件时间窗口何时可以关闭。它们表示"不应再到达此时间之前的事件"，并且是周期性或基于标点符号生成的。Watermark 延迟（MarketLag 中为 5 分钟）平衡了延迟和完整性。Watermark 对于事件时间窗口化（第 1.6 节）至关重要，必须在 Flink SQL 表定义中声明。

