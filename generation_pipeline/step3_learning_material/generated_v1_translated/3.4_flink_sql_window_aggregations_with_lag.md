# Flink SQL Window Aggregations with LAG

**Learning Point**: 3.4 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.3 (Table API/SQL), 3.1 (Window Functions), SQL window functions knowledge
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**LAG Function**: 访问窗口内前一行值的 Flink SQL window function。返回当前行之前 N 行的值。

**LAG with OVER Clause**: 与 OVER 子句一起使用的 LAG function，用于定义访问前行的窗口。包括 PARTITION BY 和 ORDER BY。

**PARTITION BY**: 将行分成组（分区）以进行 window function 计算。LAG 为每个分区单独计算。

**ORDER BY**: 指定每个分区内行的排序。LAG 需要它来确定"前一行"。

**Windowed Lag Calculation**: 使用 LAG 计算当前值和前一个值之间的差异（例如，signal_delta = current - previous）。

---

## Plain Language Explanation

将 LAG function 想象成回顾过去：

- **LAG** = 前一个值："前一小时的 signal 值是多少？"
- **PARTITION BY** = 分组："为每个市场单独计算 LAG"
- **ORDER BY** = 时间顺序："按时间排序以找到前一个小时"
- **Delta Calculation** = 当前 - 前一个："signal 变化了多少？"

**为什么需要**：MarketLag Job 3 使用 LAG 计算 signal_delta - 从前一个窗口到当前窗口的 signal 变化。

---

## Analogy

如果您了解 **SQL LAG function**（您了解），Flink 的 LAG 是相同的：
- SQL `LAG(value) OVER (PARTITION BY key ORDER BY time)` = Flink LAG
- 两者都在分区内访问前一行值

关键区别：Flink LAG 在无界流上工作，在新数据到达时连续产生结果。

---

## Relationship to Already Learned Topics

- **1.3 Table API/SQL**: LAG 是一个 Flink SQL 函数
- **3.1 Window Functions**: LAG 与 window aggregations 一起使用
- **12.1 Lag Detection**: LAG 计算 signal_delta 以进行 lag 检测
- **SQL Window Functions**: 您已经从 SQL 中了解 LAG

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```sql
-- LAG function (simplified)
LAG(value, offset, default) OVER (
    PARTITION BY key
    ORDER BY time
)
-- Returns: value from 'offset' rows before current row
-- Default: value to return if no previous row exists
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/functions/WindowFunction.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/functions/WindowFunction.java

---

## LAG Function: Accessing Previous Row Values

### Basic LAG Syntax

```sql
LAG(column, offset, default) OVER (
    PARTITION BY partition_key
    ORDER BY order_key
)
```

**参数**：
- **column**: 要访问前一个值的列
- **offset**: 向后查找的行数（默认：1）
- **default**: 如果不存在前一行则返回的值（默认：NULL）

### Simple LAG Example

```sql
SELECT
    market_slug,
    window_start,
    signal,
    LAG(signal) OVER (
        PARTITION BY market_slug
        ORDER BY window_start
    ) as prev_signal
FROM rss_signals_hourly;
```

**Result**:
- Row 1: signal=2.5, prev_signal=NULL (no previous row)
- Row 2: signal=4.0, prev_signal=2.5 (previous row's signal)
- Row 3: signal=3.5, prev_signal=4.0

---

## LAG with OVER Clause: Windowed Lag Calculation

### OVER Clause Components

1. **PARTITION BY**: Groups rows (e.g., by market_slug)
2. **ORDER BY**: Orders rows within partition (e.g., by window_start)

### MarketLag Job 3 Pattern

```sql
SELECT
    market_slug,
    window_start,
    signal,
    LAG(signal) OVER (
        PARTITION BY market_slug
        ORDER BY window_start
    ) as prev_signal,
    -- Calculate delta
    signal - LAG(signal) OVER (
        PARTITION BY market_slug
        ORDER BY window_start
    ) as signal_delta
FROM rss_signals_hourly;
```

**This is the exact pattern used in MarketLag Job 3**.

---

## PARTITION BY and ORDER BY in Window Functions

### PARTITION BY

Divides rows into groups. LAG is calculated separately for each group.

```sql
PARTITION BY market_slug
```

**效果**：LAG 按每个市场计算前一个值，而不是跨所有市场。

**示例**：
- Market A, Window 1: signal=2.5, prev_signal=NULL
- Market A, Window 2: signal=4.0, prev_signal=2.5（Market A 的前一个）
- Market B, Window 1: signal=1.0, prev_signal=NULL（Market B 的第一个，不是 Market A 的）

### ORDER BY

指定分区内的排序。LAG 需要它来确定"前一个"。

```sql
ORDER BY window_start
```

**效果**：按时间排序，因此 LAG 获取前一个时间窗口的值。

**重要**：对于基于时间的 LAG，必须按时间列排序。

---

## Windowed Lag Calculation: signal_delta = current - previous

### Complete Pattern

```sql
SELECT
    market_slug,
    window_start,
    signal,
    -- Calculate delta
    signal - LAG(signal) OVER (
        PARTITION BY market_slug
        ORDER BY window_start
    ) as signal_delta
FROM rss_signals_hourly;
```

### 工作原理

1. **PARTITION BY market_slug**: 按每个市场单独计算
2. **ORDER BY window_start**: 按时间排序
3. **LAG(signal)**: 获取前一个窗口的 signal
4. **signal - LAG(signal)**: 计算 delta（当前 - 前一个）

### 处理 NULL（第一行）

第一行没有前一行，因此 LAG 返回 NULL。Delta 计算：

```sql
-- Option 1: Use COALESCE to default to 0
COALESCE(signal - LAG(signal) OVER (...), 0) as signal_delta

-- Option 2: Filter out NULL
WHERE signal_delta IS NOT NULL
```

**MarketLag Job 3**: Likely filters out NULL or uses COALESCE.

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;

public class LagFunctionDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);

        // Create table
        tableEnv.executeSql(
            "CREATE TABLE signals (" +
            "  market_slug STRING," +
            "  window_start TIMESTAMP(3)," +
            "  signal DOUBLE" +
            ") WITH ('connector' = 'kafka', ...)"
        );

        // LAG calculation
        tableEnv.executeSql(
            "CREATE TABLE with_delta AS " +
            "SELECT " +
            "  market_slug," +
            "  window_start," +
            "  signal," +
            "  LAG(signal) OVER (" +
            "    PARTITION BY market_slug" +
            "    ORDER BY window_start" +
            "  ) as prev_signal," +
            "  signal - LAG(signal) OVER (" +
            "    PARTITION BY market_slug" +
            "    ORDER BY window_start" +
            "  ) as signal_delta " +
            "FROM signals"
        );

        env.execute("LAG Function Demo");
    }
}
```

---

## Common Mistakes

1. **缺少 ORDER BY**：
   - ❌ `LAG(signal) OVER (PARTITION BY market_slug)`（没有 ORDER BY）
   - ✅ 始终包含 ORDER BY：`ORDER BY window_start`

2. **错误的 PARTITION BY**：
   - ❌ 不分区（混合市场）
   - ✅ 始终按 key 分区：`PARTITION BY market_slug`

3. **NULL 处理**：
   - ❌ 未处理来自 LAG 的 NULL（第一行）
   - ✅ 使用 COALESCE 或过滤：`COALESCE(..., 0)`

4. **多次调用 LAG**：
   - ❌ 多次调用 LAG（低效）
   - ✅ 计算一次，重用：`WITH prev AS (LAG(...)) SELECT ..., prev`

5. **错误的 offset**：
   - ❌ 当您想要前一个时使用 LAG(signal, 2)（offset=1）
   - ✅ 使用 LAG(signal) 或 LAG(signal, 1) 获取前一行

---

## Mind Trigger: When to Think About This

在以下情况下考虑 LAG function：
- **计算 deltas**：MarketLag Job 3 使用 LAG 计算 signal_delta
- **时间序列分析**：需要比较当前值与前一个值
- **Window functions**：LAG 是一个 window function，与 PARTITION BY 和 ORDER BY 一起工作
- **NULL 处理**：第一行没有前一个，适当处理 NULL
- **性能**：LAG 需要排序，对于大分区可能很昂贵

**在 MarketLag 项目中**：Job 3 使用 LAG 计算 signal_delta（当前 signal - 前一个 signal）以进行 lag 检测。LAG 按 market_slug 分区并按 window_start 排序。这能够检测连续窗口之间 signal 何时发生显著变化。

---

## Summary

Flink SQL LAG function 访问窗口内前一行值。带 OVER 子句的 LAG 使用 PARTITION BY 对行进行分组，使用 ORDER BY 对它们进行排序。MarketLag Job 3 使用 LAG 计算 signal_delta（当前 - 前一个）以进行 lag 检测。理解 LAG 对于流式 SQL 中的时间序列分析和 delta 计算至关重要。

