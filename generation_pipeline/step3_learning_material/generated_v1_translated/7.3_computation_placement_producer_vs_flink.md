# Computation Placement: Producer vs Flink

**Learning Point**: 7.3 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 7.4 (Price Delta Calculation)、理解分布式系统架构
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Computation Placement**: 在何处执行计算逻辑的架构决策 - 在数据 producer（Kafka 之前）还是在 Flink（Kafka 之后）。

**Producer-Side Computation**: 在 producer（例如 Lambda 函数）中执行计算，然后写入 Kafka。需要外部状态存储（DynamoDB、S3）。

**Flink-Side Computation**: 在 Flink 算子中使用 Flink 状态管理执行计算。所有逻辑集中在 Flink 中。

**Trade-offs**: 每种方法在复杂性、状态管理和系统设计方面都有优缺点。

---

## Plain Language Explanation

将计算放置想象成选择在哪里烹饪：

- **Producer-Side** = 配送前烹饪："在 Lambda 中计算 price_delta，然后发送到 Kafka"
- **Flink-Side** = 配送后烹饪："将原始价格发送到 Kafka，在 Flink 中计算 delta"

**Why It Matters**: MarketLag 选择在 producer 端计算 price_delta 以简化 Flink 作业，但这需要 DynamoDB 来存储状态。

---

## Analogy

如果您了解 **ETL vs ELT**（您了解），计算放置是类似的：
- ETL (Extract-Transform-Load) = Producer-side（在加载前转换）
- ELT (Extract-Load-Transform) = Flink-side（先加载，后转换）

关键区别：在流处理中，"load" 是 Kafka，我们选择在哪里进行 "transform"。

---

## Relationship to Already Learned Topics

- **7.4 Price Delta**: MarketLag 在 producer 中计算 price_delta
- **8.1 AWS Lambda**: Producer-side 计算在 Lambda 中运行
- **1.7 State Types**: Flink-side 计算使用 Flink 状态
- **Architecture**: 您已经了解架构权衡

---

## Decision Factor: Where to Place Computation Logic

### Key Considerations

1. **State Management**: 在哪里存储先前的值？
2. **Complexity**: 哪个系统更好地处理复杂性？
3. **Scalability**: 哪种方法扩展性更好？
4. **Maintainability**: 哪种更容易维护？

**MarketLag Decision**: Producer-side 用于 price_delta（更简单的 Flink，需要 DynamoDB）。

---

## Producer-Side Computation: price_delta Calculation in Lambda

### Architecture

```
Lambda → DynamoDB (prev_price) → Calculate delta → Kafka (with price_delta)
```

### Pros

1. **Reduces Flink State Complexity**: Flink 不需要存储先前的价格
2. **Simpler Flink Job**: Flink 只需处理预计算的 deltas
3. **Separation of Concerns**: Lambda 处理数据准备，Flink 处理处理
4. **Easier Testing**: 可以独立测试 Lambda 和 Flink

**MarketLag**: 使用这种方法进行 price_delta 计算。

### Cons

1. **Requires External State Storage**: 需要 DynamoDB（或 S3）来存储先前的价格
2. **Additional Infrastructure**: 需要管理更多组件
3. **Potential Inconsistency**: Lambda 和 Flink 可能有不同的视图
4. **Cost**: DynamoDB 存储和读写成本

**MarketLag**: 为了更简单的 Flink 逻辑而接受这些权衡。

---

## Flink-Side Computation: Computation in Flink Operators

### Architecture

```
Lambda → Kafka (raw prices) → Flink (calculate delta using state) → Output
```

### Pros

1. **Centralized Logic**: 所有计算集中在一个地方（Flink）
2. **Flink State Management**: 使用 Flink 的内置状态管理
3. **Consistency**: 单一数据源（Flink 状态）
4. **No External Dependencies**: 不需要 DynamoDB

### Cons

1. **More Complex Flink State**: 需要在 Flink 中管理状态
2. **Larger State Size**: Flink 状态随市场数量增长
3. **Flink Complexity**: 更复杂的 Flink 作业逻辑
4. **State Management Overhead**: Flink 状态管理复杂性

**MarketLag**: 没有选择这种方法（而是选择了 producer-side）。

---

## Project Choice: price_delta Calculated in Producer (Lambda) Using DynamoDB

### MarketLag Architecture

**Decision**: 在 Lambda producer 中计算 price_delta，而不是在 Flink 中。

**Implementation**:
1. Lambda 从 Polymarket API 获取当前价格
2. Lambda 从 DynamoDB 读取先前价格
3. Lambda 计算：`price_delta = current_price - prev_price`
4. Lambda 写入 Kafka：`{price, price_delta, ...}`
5. Lambda 用当前价格更新 DynamoDB

**Why This Choice**:
- **Simpler Flink**: Flink 作业不需要管理价格历史状态
- **Separation**: Lambda 处理数据准备，Flink 处理 lag 检测
- **Scalability**: DynamoDB 自动处理状态扩展

---

## Minimum Viable Code

```python
# Producer-side computation (Lambda)
import boto3
from decimal import Decimal

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('polymarket_previous_prices')

def calculate_price_delta(market_slug, outcome, current_price):
    """
    Calculate price delta using DynamoDB for previous price.

    Args:
        market_slug: Market slug
        outcome: "YES" or "NO"
        current_price: Current price from API

    Returns:
        float: Price delta
    """
    key = f"{market_slug}|{outcome}"

    # Read previous price from DynamoDB
    response = table.get_item(Key={'key': key})
    prev_price = response.get('Item', {}).get('price', None)

    # Calculate delta
    if prev_price is None:
        price_delta = 0.0  # First time, no previous price
    else:
        price_delta = float(current_price) - float(prev_price)

    # Update DynamoDB with current price
    table.put_item(Item={
        'key': key,
        'price': Decimal(str(current_price)),
        'updated_at': datetime.now(pytz.UTC).isoformat()
    })

    return price_delta

# Usage in Lambda
current_price = get_price_from_api()
price_delta = calculate_price_delta(market_slug, outcome, current_price)

# Send to Kafka with price_delta
send_to_kafka({
    'market_slug': market_slug,
    'price': current_price,
    'price_delta': price_delta,
    'event_time': datetime.now(pytz.UTC).isoformat()
})
```

---

## Common Mistakes

1. **Not understanding trade-offs**:
   - ❌ 在不理解优缺点的情况下选择方法
   - ✅ 理解两种方法，根据需求选择

2. **Mixing approaches inconsistently**:
   - ❌ 一些计算在 producer 中，一些在 Flink 中（混乱）
   - ✅ 保持一致：为每种计算类型选择一种方法

3. **Not considering state size**:
   - ❌ 对非常大的状态使用 Flink 状态（昂贵）
   - ✅ 考虑使用外部存储（DynamoDB）处理大状态

4. **Not handling first-time case**:
   - ❌ 没有先前价格，计算失败
   - ✅ 处理首次情况：delta = 0 或跳过计算

5. **Not updating state**:
   - ❌ 计算 delta 但忘记更新先前价格
   - ✅ 计算后始终更新状态

---

## Mind Trigger: When to Think About This

在以下情况下考虑计算放置：
- **设计架构**: MarketLag 选择 producer-side 用于 price_delta
- **决定在哪里计算**: Producer vs Flink 决策
- **管理状态**: 理解状态管理权衡
- **简化 Flink 作业**: Producer-side 可以简化 Flink 逻辑
- **扩展考虑**: 理解可扩展性影响

**在 MarketLag 项目中**: 在 Lambda producer 中使用 DynamoDB 计算 price_delta。这简化了 Flink 作业，但需要 DynamoDB 基础设施。理解计算放置有助于做出架构决策。

---

## Summary

计算放置是一个架构决策：producer-side（Kafka 之前）或 Flink-side（Kafka 之后）。Producer-side 减少了 Flink 复杂性，但需要外部状态存储。Flink-side 集中逻辑，但增加了 Flink 状态复杂性。MarketLag 选择 producer-side 用于 price_delta 计算。理解权衡有助于做出正确的架构决策。
