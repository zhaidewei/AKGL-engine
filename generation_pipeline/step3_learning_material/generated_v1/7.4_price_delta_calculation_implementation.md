# Price Delta Calculation Implementation

**Learning Point**: 7.4 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 7.2 (Polymarket API), 7.3 (Computation Placement), AWS DynamoDB basics
**Version**: Python 3.9+, DynamoDB

---

## Definition (Engineering Language)

**Price Delta Calculation**: Computing the change in price between current and previous values. Formula: `price_delta = current_price - prev_price`.

**State Management for Previous Price**: Storing previous price values for delta calculation. Options: DynamoDB (MarketLag uses this), S3, or in-memory (not persistent).

**First-Time Handling**: Special case when no previous price exists. MarketLag sets `delta = 0` for first data point.

**DynamoDB Pattern**: Storing `{market_slug|outcome: prev_price}` as key-value pairs with TTL for automatic cleanup.

---

## Plain Language Explanation

Think of price delta like tracking stock price changes:

- **Price Delta** = Price change: "Price went from $0.50 to $0.55, delta = +$0.05"
- **Previous Price** = Last known price: "Remember last price was $0.50"
- **First Time** = No history: "First time seeing this market, delta = 0"

**Why Needed**: MarketLag needs price_delta to detect when prices don't change (lag detection algorithm, section 12.1).

---

## Analogy

If you know **time series analysis** (which you do), price delta is similar:
- Time series diff = Price delta (both calculate change)
- Previous value storage = State management (both need to remember previous)
- First value = First-time handling (both need special case)

Key difference: Price delta is calculated in producer (Lambda), not in Flink.

---

## Relationship to Already Learned Topics

- **7.2 Polymarket API**: Gets current price from API
- **7.3 Computation Placement**: Calculates delta in producer (Lambda)
- **12.1 Lag Detection**: Uses price_delta in lag detection algorithm
- **DynamoDB**: You already know DynamoDB from AWS - used for state storage

---

## Price Delta Computation: current_price - prev_price

### Formula

```
price_delta = current_price - prev_price
```

### Implementation

```python
def calculate_delta(current_price, prev_price):
    """
    Calculate price delta.

    Args:
        current_price: Current price from API
        prev_price: Previous price from storage (None if first time)

    Returns:
        float: Price delta
    """
    if prev_price is None:
        return 0.0  # First time, no previous price
    else:
        return float(current_price) - float(prev_price)
```

**MarketLag**: Uses this formula in Lambda producer.

---

## State Management for Previous Price: DynamoDB, S3, or In-Memory

### Option 1: DynamoDB (MarketLag Uses This)

**Pros**:
- **Persistent**: Survives Lambda restarts
- **Scalable**: Handles many markets automatically
- **TTL Support**: Automatic cleanup of old data
- **Fast**: Low latency reads/writes

**Cons**:
- **Cost**: Pay per read/write
- **External Dependency**: Additional infrastructure

**MarketLag**: Uses DynamoDB for previous price storage.

### Option 2: S3

**Pros**:
- **Cheap**: Very low storage cost
- **Durable**: High durability

**Cons**:
- **Slow**: Higher latency than DynamoDB
- **Not Real-Time**: Better for batch processing

**MarketLag**: Not used (DynamoDB is faster for real-time).

### Option 3: In-Memory

**Pros**:
- **Fast**: No network calls
- **Simple**: No external dependencies

**Cons**:
- **Not Persistent**: Lost on Lambda restart
- **Not Scalable**: Limited by Lambda memory

**MarketLag**: Not used (needs persistence).

---

## First-Time Handling: delta = 0 for First Data Point

### Problem

First time seeing a market, no previous price exists.

**Solution**: Set `delta = 0` for first data point.

### Implementation

```python
if prev_price is None:
    price_delta = 0.0  # First time, no change
else:
    price_delta = current_price - prev_price
```

**MarketLag**: Uses this pattern - first price has delta = 0.

### Alternative: Skip First Point

```python
if prev_price is None:
    return None  # Skip first point, no delta to calculate
else:
    price_delta = current_price - prev_price
```

**MarketLag**: Does not skip - sends delta = 0 for first point.

---

## DynamoDB Pattern: Store `{market_slug|outcome: prev_price}` with TTL

### Table Structure

**Table Name**: `polymarket_previous_prices`

**Key Schema**:
- **Partition Key**: `key` (String) - Format: `{market_slug}|{outcome}`

**Attributes**:
- `price` (Number) - Previous price value
- `updated_at` (String) - ISO 8601 timestamp
- `ttl` (Number) - TTL timestamp for automatic cleanup

### Implementation

```python
import boto3
from decimal import Decimal
from datetime import datetime, timedelta
import pytz

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('polymarket_previous_prices')

def get_previous_price(market_slug, outcome):
    """
    Get previous price from DynamoDB.

    Args:
        market_slug: Market slug
        outcome: "YES" or "NO"

    Returns:
        float or None: Previous price, or None if not found
    """
    key = f"{market_slug}|{outcome}"

    try:
        response = table.get_item(Key={'key': key})
        item = response.get('Item')
        if item:
            return float(item['price'])
        return None
    except Exception as e:
        # Handle error (log, return None)
        print(f"Error getting previous price: {e}")
        return None

def update_previous_price(market_slug, outcome, price):
    """
    Update previous price in DynamoDB.

    Args:
        market_slug: Market slug
        outcome: "YES" or "NO"
        price: Current price to store
    """
    key = f"{market_slug}|{outcome}"
    now = datetime.now(pytz.UTC)
    ttl = int((now + timedelta(days=30)).timestamp())  # 30-day TTL

    table.put_item(Item={
        'key': key,
        'price': Decimal(str(price)),
        'updated_at': now.isoformat(),
        'ttl': ttl
    })
```

**MarketLag**: Uses this DynamoDB pattern for previous price storage.

---

## Minimum Viable Code

```python
import boto3
from decimal import Decimal
from datetime import datetime, timedelta
import pytz

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('polymarket_previous_prices')

def calculate_and_store_price_delta(market_slug, outcome, current_price):
    """
    Calculate price delta and update DynamoDB.

    Args:
        market_slug: Market slug
        outcome: "YES" or "NO"
        current_price: Current price from API

    Returns:
        float: Price delta
    """
    # Get previous price
    key = f"{market_slug}|{outcome}"
    response = table.get_item(Key={'key': key})
    prev_price = response.get('Item', {}).get('price', None)

    # Calculate delta
    if prev_price is None:
        price_delta = 0.0  # First time
    else:
        price_delta = float(current_price) - float(prev_price)

    # Update DynamoDB with current price
    now = datetime.now(pytz.UTC)
    ttl = int((now + timedelta(days=30)).timestamp())

    table.put_item(Item={
        'key': key,
        'price': Decimal(str(current_price)),
        'updated_at': now.isoformat(),
        'ttl': ttl
    })

    return price_delta

# Usage in Lambda
current_price = 0.65  # From Polymarket API
price_delta = calculate_and_store_price_delta(
    "fed-hike-january",
    "YES",
    current_price
)

# Send to Kafka
send_to_kafka({
    'market_slug': 'fed-hike-january',
    'outcome': 'YES',
    'price': current_price,
    'price_delta': price_delta,
    'event_time': datetime.now(pytz.UTC).isoformat()
})
```

---

## Common Mistakes

1. **Not handling first-time case**:
   - ❌ `price_delta = current_price - prev_price` when prev_price is None (error)
   - ✅ Check for None: `if prev_price is None: delta = 0.0`

2. **Not updating DynamoDB**:
   - ❌ Calculate delta but forget to store current price
   - ✅ Always update DynamoDB after calculation

3. **Wrong key format**:
   - ❌ Using just market_slug (can't distinguish YES/NO)
   - ✅ Use `{market_slug}|{outcome}` format

4. **Not setting TTL**:
   - ❌ DynamoDB items never expire (costs grow)
   - ✅ Set TTL (e.g., 30 days) for automatic cleanup

5. **Type conversion errors**:
   - ❌ Mixing Decimal and float (DynamoDB uses Decimal)
   - ✅ Convert to Decimal for DynamoDB: `Decimal(str(price))`

---

## Mind Trigger: When to Think About This

Think about price delta calculation when:
- **Implementing Lambda producer**: MarketLag calculates price_delta in Lambda
- **Managing state**: Using DynamoDB for previous price storage
- **First-time handling**: Setting delta = 0 for first data point
- **Lag detection**: Section 12.1 uses price_delta in algorithm
- **Computation placement**: Section 7.3 covers why producer-side

**In MarketLag project**: Calculates price_delta in Lambda producer using DynamoDB for previous prices. First-time sets delta = 0. Price delta is used in lag detection algorithm (section 12.1). Understanding price delta calculation is essential for data preparation.

---

## Summary

Price delta calculation computes change between current and previous prices. MarketLag calculates price_delta in Lambda producer (not Flink). Uses DynamoDB to store previous prices with key format `{market_slug}|{outcome}`. First-time handling sets delta = 0. Understanding price delta calculation is essential for data preparation before Flink processing.

