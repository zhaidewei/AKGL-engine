# Flink CEP (Complex Event Processing)

**Learning Point**: 14.1 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.2 (DataStream API), understanding of pattern matching
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Flink CEP (Complex Event Processing)**: A library for detecting event patterns in data streams. Enables pattern-based event detection.

**Pattern Definition**: Defining event sequences to detect (e.g., "signal increase followed by price stagnation").

**Pattern Matching**: Flink CEP matches patterns against event streams and emits matches.

**Why Not Used in MVP**: MarketLag uses SQL-based approach instead of CEP for lag detection. CEP is an alternative approach.

---

## Plain Language Explanation

Think of Flink CEP like a pattern detector:

- **Pattern Definition** = Pattern template: "Detect this sequence of events"
- **Pattern Matching** = Pattern detector: "Find matches in the stream"
- **Alternative Approach** = Different method: "CEP vs SQL-based approach"

**Why Not Used**: MarketLag uses SQL (simpler) instead of CEP (more complex) for lag detection.

---

## Analogy

If you know **regex pattern matching** (which you do), Flink CEP is similar:
- Regex pattern = CEP pattern (both define patterns)
- Regex matching = CEP matching (both find matches)
- String matching = Event stream matching (both match against data)

Key difference: CEP matches event sequences in streams, not text patterns.

---

## Relationship to Already Learned Topics

- **1.2 DataStream API**: CEP uses DataStream API
- **12.1 Lag Detection**: CEP could be used for lag detection (alternative to SQL)
- **Pattern Matching**: You already know pattern matching - CEP extends it to streams

---

## Pattern Definition: Detecting Event Sequences

### Basic Pattern

**Pattern**: "Signal increase followed by price stagnation"

**CEP Definition**:
```java
Pattern<Event, ?> pattern = Pattern.<Event>begin("signal_increase")
    .where(new SimpleCondition<Event>() {
        @Override
        public boolean filter(Event event) {
            return event.getSignalDelta() > 1.0;
        }
    })
    .next("price_stagnation")
    .where(new SimpleCondition<Event>() {
        @Override
        public boolean filter(Event event) {
            return Math.abs(event.getPriceDelta()) < 0.02;
        }
    });
```

**MarketLag**: Could use this pattern for lag detection (not used in MVP).

---

## Pattern Matching: Detecting Lag Patterns

### CEP Pattern for Lag Detection

**Pattern**: "High signal_delta AND low price_delta"

**Implementation**:
```java
Pattern<JoinedEvent, ?> lagPattern = Pattern.<JoinedEvent>begin("high_signal")
    .where(new SimpleCondition<JoinedEvent>() {
        @Override
        public boolean filter(JoinedEvent event) {
            return event.getSignalDelta() > 1.0;
        }
    })
    .next("low_price_change")
    .where(new SimpleCondition<JoinedEvent>() {
        @Override
        public boolean filter(JoinedEvent event) {
            return Math.abs(event.getPriceDelta()) < 0.02;
        }
    })
    .within(Time.hours(1));  // Within 1 hour

// Apply pattern to stream
PatternStream<JoinedEvent> patternStream = CEP.pattern(joinedStream, lagPattern);

// Process matches
DataStream<LagSignal> lagSignals = patternStream.select(new PatternSelectFunction<JoinedEvent, LagSignal>() {
    @Override
    public LagSignal select(Map<String, List<JoinedEvent>> pattern) {
        JoinedEvent highSignal = pattern.get("high_signal").get(0);
        JoinedEvent lowPrice = pattern.get("low_price_change").get(0);
        return new LagSignal(highSignal.getMarket(), true);
    }
});
```

**MarketLag**: Could use CEP for lag detection (not used in MVP, uses SQL instead).

---

## Why Not Used in MVP: SQL-Based Approach

### SQL Approach (MarketLag Uses)

**Advantages**:
- **Simpler**: SQL is easier to write and maintain
- **Declarative**: Expresses intent clearly
- **Less Code**: Less boilerplate than CEP

**MarketLag**: Uses SQL for lag detection:
```sql
SELECT
    market_slug,
    signal_delta,
    price_delta,
    CASE
        WHEN signal_delta > 1.0 AND ABS(price_delta) < 0.02 THEN true
        ELSE false
    END as lag_flag
FROM joined_events
```

### CEP Approach (Alternative)

**Advantages**:
- **Pattern-Based**: Natural for complex event sequences
- **Temporal Patterns**: Better for time-based patterns
- **Flexible**: More control over pattern matching

**Disadvantages**:
- **More Complex**: Requires more code
- **Less Familiar**: Team may not know CEP

**MarketLag**: Did not use CEP (chose SQL for simplicity).

---

## Minimum Viable Code

```java
import org.apache.flink.cep.PatternStream;
import org.apache.flink.cep.pattern.Pattern;
import org.apache.flink.cep.pattern.conditions.SimpleCondition;

public class CEPLagDetection {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // Create stream
        DataStream<JoinedEvent> stream = ...;

        // Define pattern
        Pattern<JoinedEvent, ?> pattern = Pattern.<JoinedEvent>begin("high_signal")
            .where(new SimpleCondition<JoinedEvent>() {
                @Override
                public boolean filter(JoinedEvent event) {
                    return event.getSignalDelta() > 1.0;
                }
            })
            .next("low_price")
            .where(new SimpleCondition<JoinedEvent>() {
                @Override
                public boolean filter(JoinedEvent event) {
                    return Math.abs(event.getPriceDelta()) < 0.02;
                }
            })
            .within(Time.hours(1));

        // Apply pattern
        PatternStream<JoinedEvent> patternStream = CEP.pattern(stream, pattern);

        // Process matches
        DataStream<LagSignal> lagSignals = patternStream.select(new PatternSelectFunction<JoinedEvent, LagSignal>() {
            @Override
            public LagSignal select(Map<String, List<JoinedEvent>> pattern) {
                // Create lag signal
                return new LagSignal(...);
            }
        });

        env.execute("CEP Lag Detection");
    }
}
```

---

## Common Mistakes

1. **Using CEP when SQL is sufficient**:
   - ❌ Over-engineering with CEP for simple patterns
   - ✅ Use SQL for simple patterns, CEP for complex sequences

2. **Not understanding pattern semantics**:
   - ❌ Wrong pattern definition (doesn't match intended pattern)
   - ✅ Understand CEP pattern semantics (begin, next, within)

3. **Not handling pattern timeouts**:
   - ❌ Patterns never complete (missing within clause)
   - ✅ Use within() to set pattern timeout

4. **Not testing patterns**:
   - ❌ Patterns not tested, may not match correctly
   - ✅ Test patterns with known data

5. **Not considering performance**:
   - ❌ Complex patterns may be slow
   - ✅ Consider performance implications

---

## Mind Trigger: When to Think About This

Think about Flink CEP when:
- **Complex event sequences**: Need to detect complex event patterns
- **Temporal patterns**: Patterns with time constraints
- **Alternative approach**: Consider CEP as alternative to SQL
- **Pattern-based logic**: Natural fit for pattern-based detection
- **Not used in MVP**: MarketLag uses SQL instead of CEP

**In MarketLag project**: CEP could be used for lag detection (alternative to SQL), but not used in MVP. Understanding CEP helps evaluate alternative approaches. CEP is optional but helpful for complex event processing scenarios.

---

## Summary

Flink CEP enables pattern-based event detection in streams. Define patterns to detect event sequences. Match patterns against streams. MarketLag could use CEP for lag detection (alternative to SQL), but chose SQL for simplicity. CEP is optional but helpful for complex event processing scenarios. Understanding CEP helps evaluate alternative approaches.

