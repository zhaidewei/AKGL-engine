# Flink Async I/O

**Learning Point**: 14.2 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.2 (DataStream API), understanding of asynchronous programming
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Flink Async I/O**: Asynchronous I/O operations for enriching data streams with external lookups (APIs, databases). Improves throughput by not blocking on I/O.

**AsyncFunction**: Interface for implementing asynchronous lookups. Returns Future for non-blocking I/O.

**Async I/O Configuration**: Configuring capacity (concurrent requests), timeout, and retry settings.

**Why Not Used in MVP**: MarketLag doesn't need external API lookups in Flink (data enrichment happens in Lambda producers). Async I/O is useful if needing to enrich data with external APIs.

---

## Plain Language Explanation

Think of Async I/O like ordering food while cooking:

- **Synchronous I/O** = Wait for order: "Order food, wait, then cook"
- **Async I/O** = Order while cooking: "Order food while cooking, don't wait"

**Why Not Used**: MarketLag enriches data in Lambda (before Kafka), not in Flink, so Async I/O not needed.

---

## Analogy

If you know **asynchronous programming** (which you do), Flink Async I/O is similar:
- Async/await = AsyncFunction (both enable non-blocking I/O)
- Promise/Future = Future return (both represent async results)
- Non-blocking = Async I/O (both don't block threads)

Key difference: Flink Async I/O is integrated with Flink's streaming model.

---

## Relationship to Already Learned Topics

- **1.2 DataStream API**: Async I/O uses DataStream API
- **7.3 Computation Placement**: MarketLag enriches data in Lambda, not Flink
- **Asynchronous Programming**: You already know async - Flink extends it

---

## AsyncFunction for External Lookups

### Basic AsyncFunction

**Purpose**: Enrich stream records with data from external APIs or databases.

**Interface**:
```java
public abstract class AsyncFunction<IN, OUT> implements Function {
    public abstract void asyncInvoke(IN input, ResultFuture<OUT> resultFuture) throws Exception;
}
```

**Example**: Enriching events with external API data.

```java
public class EnrichmentAsyncFunction extends AsyncFunction<Event, EnrichedEvent> {
    private transient AsyncHttpClient httpClient;

    @Override
    public void open(Configuration config) {
        httpClient = new AsyncHttpClient();
    }

    @Override
    public void asyncInvoke(Event event, ResultFuture<EnrichedEvent> resultFuture) {
        // Async HTTP request
        httpClient.prepareGet("https://api.example.com/enrich/" + event.getId())
            .execute(new AsyncCompletionHandler<Response>() {
                @Override
                public Response onCompleted(Response response) {
                    // Parse response
                    EnrichmentData data = parseResponse(response);
                    EnrichedEvent enriched = new EnrichedEvent(event, data);
                    resultFuture.complete(Collections.singleton(enriched));
                    return response;
                }

                @Override
                public void onThrowable(Throwable t) {
                    resultFuture.completeExceptionally(t);
                }
            });
    }
}
```

**MarketLag**: Could use Async I/O if needing to enrich data in Flink (not needed in MVP).

---

## Async I/O Configuration: Capacity, Timeout

### Configuration

**Capacity**: Maximum number of concurrent async requests.

**Timeout**: Maximum time to wait for async request.

**Retry**: Retry policy for failed requests.

```java
AsyncDataStream.orderedWait(
    stream,
    new EnrichmentAsyncFunction(),
    1000,  // Timeout: 1 second
    TimeUnit.MILLISECONDS,
    100    // Capacity: 100 concurrent requests
);
```

**MarketLag**: Would configure capacity and timeout if using Async I/O.

---

## Why Not Used in MVP: Data Enrichment in Lambda

### MarketLag Architecture

**Data Enrichment**: Happens in Lambda producers (before Kafka), not in Flink.

**Why**:
- **Simpler**: Lambda handles API calls, Flink processes pre-enriched data
- **Separation**: Lambda = data preparation, Flink = processing
- **No Need**: Flink doesn't need to call external APIs

**MarketLag**: Enriches data in Lambda (RSS processing, Polymarket API), sends enriched data to Kafka.

### When to Use Async I/O

**Use Cases**:
- Enriching data in Flink (not in producer)
- Real-time lookups during processing
- External API calls from Flink

**MarketLag**: Not needed (data already enriched in Lambda).

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.datastream.AsyncDataStream;
import org.apache.flink.streaming.api.functions.async.AsyncFunction;
import org.apache.flink.streaming.api.functions.async.ResultFuture;

public class AsyncIODemo {
    public static class EnrichmentAsyncFunction extends AsyncFunction<Event, EnrichedEvent> {
        @Override
        public void asyncInvoke(Event event, ResultFuture<EnrichedEvent> resultFuture) {
            // Async lookup
            CompletableFuture.supplyAsync(() -> {
                // Call external API
                EnrichmentData data = callExternalAPI(event.getId());
                return new EnrichedEvent(event, data);
            }).thenAccept(enriched -> {
                resultFuture.complete(Collections.singleton(enriched));
            }).exceptionally(throwable -> {
                resultFuture.completeExceptionally(throwable);
                return null;
            });
        }
    }

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        DataStream<Event> stream = ...;

        // Apply Async I/O
        DataStream<EnrichedEvent> enriched = AsyncDataStream.orderedWait(
            stream,
            new EnrichmentAsyncFunction(),
            1000,  // Timeout
            TimeUnit.MILLISECONDS,
            100    // Capacity
        );

        env.execute("Async I/O Demo");
    }
}
```

---

## Common Mistakes

1. **Using Async I/O when not needed**:
   - ❌ Using Async I/O for simple lookups (over-engineering)
   - ✅ Use Async I/O only when enriching data in Flink

2. **Not configuring capacity**:
   - ❌ Too many concurrent requests (overwhelm external API)
   - ✅ Set appropriate capacity based on API limits

3. **Not setting timeout**:
   - ❌ Requests hang indefinitely
   - ✅ Set timeout to prevent hanging

4. **Not handling errors**:
   - ❌ Async failures not handled
   - ✅ Handle errors in asyncInvoke

5. **Not considering ordering**:
   - ❌ Using unorderedWait when order matters
   - ✅ Use orderedWait if order is important

---

## Mind Trigger: When to Think About This

Think about Flink Async I/O when:
- **Enriching data in Flink**: Need to call external APIs from Flink
- **Real-time lookups**: Need to lookup data during processing
- **Not used in MVP**: MarketLag enriches data in Lambda, not Flink
- **Alternative approach**: Consider Async I/O if moving enrichment to Flink
- **Performance**: Async I/O improves throughput for I/O-bound operations

**In MarketLag project**: Async I/O not used in MVP (data enrichment happens in Lambda). Understanding Async I/O helps evaluate if enrichment should move to Flink. Async I/O is optional but helpful if needing to enrich data with external APIs.

---

## Summary

Flink Async I/O enables asynchronous I/O operations for enriching data streams with external lookups. Use AsyncFunction for implementing async lookups. Configure capacity and timeout. MarketLag doesn't use Async I/O in MVP (data enrichment happens in Lambda). Async I/O is useful if needing to enrich data with external APIs in Flink. Understanding Async I/O helps evaluate enrichment strategies.

