# Flink State Types

**Learning Point**: 1.7 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.2 (DataStream API), understanding of key-value stores
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Flink State**: Mutable data stored per key (keyed state) or per operator (operator state) that persists across record processing. State enables stateful stream processing where operator behavior depends on previously seen data.

**ValueState**: Stores a single value per key. The value can be read and updated.

**ListState**: Stores a list of values per key. Values can be appended, and the entire list can be retrieved.

**MapState**: Stores a key-value map per key. Supports put, get, and contains operations on the map.

**ReducingState**: Stores a single aggregated value per key. New values are combined with existing value using a reduce function.

**Keyed State**: State scoped to a key, accessible only in keyed streams (after keyBy).

**Operator State**: State scoped to an operator instance, accessible in non-keyed streams.

---

## Plain Language Explanation

Think of Flink state like a memory bank for each processing unit:

- **ValueState** = A single storage box per key: "Store the last price for market X"
- **ListState** = A list storage box per key: "Store all prices seen for market X"
- **MapState** = A dictionary storage box per key: "Store max_signal_delta for each outcome of market X" (used in MarketLag Job 3)
- **ReducingState** = An accumulator box per key: "Keep running sum for market X"

**Keyed State**: Each key (e.g., market_slug) has its own state. Events with same key access same state.

**Operator State**: One state per operator instance, shared across all keys.

---

## Analogy

If you know **Redis** or **DynamoDB** (which you do from AWS experience), Flink state is similar:
- Redis key-value store = Flink ValueState (one value per key)
- Redis hash = Flink MapState (key-value map per key)
- Redis list = Flink ListState (list per key)

Key difference: Flink state is automatically managed, checkpointed, and restored on failures.

---

## Relationship to Already Learned Topics

- **1.2 DataStream API**: State is accessed in ProcessFunctions (section 4.1)
- **1.8 State Backend**: State is stored in state backends (RocksDB in MarketLag)
- **1.9 State Access**: How to read/write state (covered next)
- **1.10 Checkpoints**: State is included in checkpoints for fault tolerance
- **Key-Value Stores**: Similar concepts to DynamoDB, Redis you already know

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// ValueState (simplified)
interface ValueState<T> {
    T value();  // Get current value
    void update(T value);  // Update value
    void clear();  // Clear state
}

// MapState (simplified) - Used in MarketLag Job 3
interface MapState<UK, UV> {
    UV get(UK key);  // Get value for map key
    void put(UK key, UV value);  // Put value for map key
    boolean contains(UK key);  // Check if key exists
    void remove(UK key);  // Remove key
    Iterable<Map.Entry<UK, UV>> entries();  // Get all entries
}

// ListState (simplified)
interface ListState<T> {
    void add(T value);  // Add to list
    Iterable<T> get();  // Get all values
    void update(List<T> values);  // Replace entire list
    void clear();  // Clear list
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-runtime/src/main/java/org/apache/flink/runtime/state/ValueState.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-runtime/src/main/java/org/apache/flink/runtime/state/ValueState.java

**Key Classes**:
- `ValueState`: Single value state
- `MapState`: Key-value map state (used in MarketLag)
- `ListState`: List state
- `ReducingState`: Aggregated state

---

## ValueState: Single Value Per Key

**Use Case**: Store latest value, previous value, or single aggregated result.

**Example**: Store last price for each market
```java
public class PriceTracker extends KeyedProcessFunction<String, Event, Result> {
    private ValueState<Double> lastPriceState;

    @Override
    public void open(Configuration config) {
        ValueStateDescriptor<Double> descriptor =
            new ValueStateDescriptor<>("lastPrice", Double.class);
        lastPriceState = getRuntimeContext().getState(descriptor);
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        Double lastPrice = lastPriceState.value();  // Get current state
        if (lastPrice != null) {
            double delta = event.getPrice() - lastPrice;
            out.collect(new Result(event.getMarket(), delta));
        }
        lastPriceState.update(event.getPrice());  // Update state
    }
}
```

---

## ListState: List of Values Per Key

**Use Case**: Store history of values, maintain ordered list.

**Example**: Store last N prices for each market
```java
private ListState<Double> priceHistoryState;

@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    ListState<Double> history = priceHistoryState;
    history.add(event.getPrice());  // Append to list

    // Keep only last 10
    List<Double> prices = new ArrayList<>();
    for (Double price : history.get()) {
        prices.add(price);
    }
    if (prices.size() > 10) {
        prices = prices.subList(prices.size() - 10, prices.size());
        history.update(prices);
    }
}
```

---

## MapState: Key-Value Map Per Key (MarketLag Job 3 Uses This)

**Use Case**: Store multiple values keyed by a secondary key. **MarketLag stores max_signal_delta for each outcome of each market**.

**Example**: Store max signal delta per outcome
```java
public class ConfidenceCalculator extends KeyedProcessFunction<String, Event, Result> {
    private MapState<String, Double> maxSignalDeltaState;  // outcome -> max_delta

    @Override
    public void open(Configuration config) {
        MapStateDescriptor<String, Double> descriptor =
            new MapStateDescriptor<>("maxSignalDelta", String.class, Double.class);
        maxSignalDeltaState = getRuntimeContext().getMapState(descriptor);
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        String outcome = event.getOutcome();  // e.g., "YES" or "NO"
        Double currentMax = maxSignalDeltaState.get(outcome);  // Get current max

        double signalDelta = event.getSignalDelta();
        if (currentMax == null || signalDelta > currentMax) {
            maxSignalDeltaState.put(outcome, signalDelta);  // Update max
        }

        // Use for confidence calculation (section 12.2)
        double confidence = calculateConfidence(signalDelta, currentMax);
        out.collect(new Result(event.getMarket(), confidence));
    }
}
```

**MarketLag Job 3**: Uses MapState to store `max_signal_delta` keyed by `market_slug|outcome` for confidence score calculation.

---

## ReducingState: Aggregated Value Per Key

**Use Case**: Maintain running aggregate (sum, min, max) without storing all values.

**Example**: Running sum of prices
```java
private ReducingState<Double> sumState;

@Override
public void open(Configuration config) {
    ReducingStateDescriptor<Double> descriptor =
        new ReducingStateDescriptor<>("sum",
            (a, b) -> a + b,  // Reduce function
            Double.class);
    sumState = getRuntimeContext().getReducingState(descriptor);
}

@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    sumState.add(event.getPrice());  // Automatically reduces with existing value
    Double currentSum = sumState.get();
    out.collect(new Result(event.getMarket(), currentSum));
}
```

---

## Keyed State vs Operator State

### Keyed State
- **Scope**: Per key (after keyBy)
- **Access**: Only in keyed streams (KeyedProcessFunction, etc.)
- **Partitioning**: State is partitioned by key, each key's state on one subtask
- **Use Case**: Most common - per-key aggregations, per-key history

```java
// Keyed state - each market_slug has its own state
stream.keyBy(Event::getMarketSlug)
    .process(new KeyedProcessFunction<...>() {
        private ValueState<Double> state;  // One state per market_slug
    });
```

### Operator State
- **Scope**: Per operator instance
- **Access**: In any operator (non-keyed)
- **Partitioning**: State is distributed across operator instances
- **Use Case**: Rare - operator-level metadata, source offsets

```java
// Operator state - shared across all keys
stream.process(new ProcessFunction<...>() {
    private ListState<String> operatorState;  // One state per operator instance
});
```

**MarketLag Project**: Uses keyed state (MapState keyed by market_slug|outcome).

---

## Minimum Viable Code

```java
import org.apache.flink.api.common.state.*;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;

public class StateTypesDemo {
    public static class StatefulProcessor extends KeyedProcessFunction<String, Event, Result> {
        private ValueState<Double> lastValue;
        private MapState<String, Integer> counts;

        @Override
        public void open(Configuration config) {
            // ValueState
            ValueStateDescriptor<Double> valueDesc =
                new ValueStateDescriptor<>("lastValue", Double.class);
            lastValue = getRuntimeContext().getState(valueDesc);

            // MapState
            MapStateDescriptor<String, Integer> mapDesc =
                new MapStateDescriptor<>("counts", String.class, Integer.class);
            counts = getRuntimeContext().getMapState(mapDesc);
        }

        @Override
        public void processElement(Event event, Context ctx, Collector<Result> out) {
            // Read ValueState
            Double prev = lastValue.value();
            if (prev != null) {
                double delta = event.getValue() - prev;
                out.collect(new Result(event.getKey(), "delta", delta));
            }
            lastValue.update(event.getValue());

            // Read/Write MapState
            String category = event.getCategory();
            Integer count = counts.get(category);
            if (count == null) count = 0;
            counts.put(category, count + 1);

            out.collect(new Result(event.getKey(), "count", (double)count));
        }
    }
}
```

---

## State Type Selection Guide

| State Type | Use When | MarketLag Example |
|------------|----------|-------------------|
| **ValueState** | Single value per key | Last price, previous signal |
| **ListState** | History of values | Last N prices, event history |
| **MapState** | Multiple values keyed by secondary key | **max_signal_delta per outcome** (Job 3) |
| **ReducingState** | Running aggregate | Running sum, min, max |
| **AggregatingState** | Complex aggregation | Custom aggregation logic |

**MarketLag Job 3**: Uses MapState to store `max_signal_delta` for each `market_slug|outcome` combination.

---

## Common Mistakes

1. **Wrong state type**:
   - ❌ Using ListState when ValueState suffices (wasteful)
   - ✅ Choose simplest state type that meets requirements

2. **Not checking null**:
   - ❌ `state.value()` without null check
   - ✅ Always check: `if (state.value() != null) { ... }`

3. **State not initialized**:
   - ❌ Accessing state before open() called
   - ✅ Initialize state in open() method

4. **Keyed state in non-keyed stream**:
   - ❌ Using keyed state without keyBy
   - ✅ Keyed state requires keyBy() first

5. **State size growing unbounded**:
   - ❌ Not cleaning up old state
   - ✅ Use State TTL (section 4.2) to expire old state

---

## Mind Trigger: When to Think About This

Think about Flink state types when:
- **Storing per-key data**: Need to remember information for each key
- **Implementing stateful logic**: Section 4.1 ProcessFunction uses state
- **Choosing state type**: MapState for MarketLag Job 3 (max_signal_delta per outcome)
- **State backend selection**: Section 1.8 covers where state is stored
- **State access patterns**: Section 1.9 covers how to read/write state

**In MarketLag project**: Job 3 uses MapState to store historical max_signal_delta for confidence calculation. State is keyed by market_slug|outcome, with 7-day TTL (section 4.2).

---

## Summary

Flink provides multiple state types: ValueState (single value), ListState (list), MapState (key-value map - used in MarketLag), and ReducingState (aggregate). State can be keyed (per key) or operator-level. MapState is used in MarketLag Job 3 to store max_signal_delta per outcome. Understanding state types helps choose the right one for each use case and optimize state size and access patterns.

