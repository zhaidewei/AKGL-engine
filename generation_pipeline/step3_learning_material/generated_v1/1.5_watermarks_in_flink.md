# Watermarks in Flink

**Learning Point**: 1.5 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.4 (Time Concepts), understanding of event-time processing
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Watermark**: A special timestamp that flows through the data stream, indicating that no events with timestamps earlier than the watermark should arrive. Watermarks enable Flink to determine when a time window can be closed and its results emitted.

**Watermark Delay**: The maximum amount of time Flink waits for late-arriving events. Events arriving after the watermark are considered "late" and handled according to the allowed lateness policy.

**Watermark Generation**: The process of creating watermarks, either periodically (at fixed intervals) or punctuated (based on data characteristics).

---

## Plain Language Explanation

Think of watermarks like a "no late entries" deadline:

- **Watermark** = A marker saying "we've received all events up to this time"
- **Watermark Delay** = How long we wait before declaring "no more late events" (e.g., wait 5 minutes for late data)
- **Late Data** = Events that arrive after the watermark (like submitting homework after the deadline)

**Why Needed**: In distributed systems, events can arrive out of order. A watermark tells Flink "we're confident we've seen all events for time T, so we can close the window for time T and emit results."

---

## Analogy

Imagine a restaurant kitchen preparing hourly meal batches:

- **Watermark** = Kitchen timer: "We've received all orders for the 2pm batch, start cooking"
- **Watermark Delay (5 min)** = Grace period: "Wait 5 more minutes in case someone calls with a late order"
- **Late Orders** = Orders arriving after the grace period: "Sorry, that batch is already cooking"

Without watermarks, the kitchen would wait forever, never knowing when to start cooking. With watermarks, it knows "we've waited long enough, start cooking."

---

## Relationship to Already Learned Topics

- **1.4 Time Concepts**: Watermarks work with event time - they're timestamps in the event-time domain
- **1.6 Windows**: Windows use watermarks to determine when to trigger (close and emit results)
- **Kafka**: Out-of-order data from Kafka partitions requires watermarks for correct windowing
- **Distributed Systems**: Network delays cause out-of-order arrival - watermarks handle this

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// Watermark (simplified)
class Watermark {
    long timestamp;  // "Event-time progress: events <= this time are assumed complete (late may still arrive)"
}

// PeriodicWatermarkGenerator (bounded out-of-orderness)
class PeriodicWatermarkGenerator implements WatermarkGenerator<Event> {
    long maxTimestampSeen = Long.MIN_VALUE;
    long outOfOrderness = 5 * 60 * 1000;  // 5 minutes
    long lastEmittedWatermark = Long.MIN_VALUE;

    @Override
    public void onEvent(Event event, long eventTimestamp, WatermarkOutput output) {
        maxTimestampSeen = Math.max(maxTimestampSeen, eventTimestamp);
    }

    @Override
    public void onPeriodicEmit(WatermarkOutput output) {
        if (maxTimestampSeen == Long.MIN_VALUE) {
            return; // no events yet -> don't emit
        }

        long candidate = maxTimestampSeen - outOfOrderness;

        // ensure monotonic
        long wm = Math.max(lastEmittedWatermark, candidate);
        lastEmittedWatermark = wm;

        output.emitWatermark(new Watermark(wm));
    }
}

// Late w.r.t. watermark (simplified)
boolean isLate(Event e, long currentWatermark) {
    return e.getTimestamp() <= currentWatermark; // "<=" vs "<" is implementation-detail; concept is "behind watermark"
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/watermark/Watermark.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/watermark/Watermark.java

**Key Classes**:
- `Watermark`: The watermark timestamp
- `WatermarkGenerator`: Interface for generating watermarks
- `WatermarkStrategy`: Strategy for watermark generation

---

## Watermark Concept: What It Represents

A watermark with timestamp `T` means:
- "We believe all events with timestamp < T have been received"
- "Events with timestamp >= T may still arrive"
- "Windows ending before T can be closed and results emitted"

**Example**:
- Current watermark: 14:05:00
- This means: "We've seen all events up to 14:00:00 (14:05 - 5 min delay)"
- Window [14:00:00, 15:00:00) can be closed when watermark >= 15:00:00

---

## Watermark Generation Strategies

### 1. Periodic Watermarks (Most Common)

Generate watermarks at fixed intervals (e.g., every 200ms).

```java
WatermarkStrategy.<Event>forBoundedOutOfOrderness(Duration.ofMinutes(5))
    .withTimestampAssigner((event, timestamp) -> event.getEventTime());
```

**How it works**:
1. Track maximum event timestamp seen so far
2. Every 200ms, emit watermark = max_timestamp - delay
3. Continues indefinitely

**Use Case**: MarketLag project uses this - 5 minute delay for RSS events.

### 2. Punctuated Watermarks

Generate watermarks based on data characteristics (e.g., special marker events).

```java
// Punctuated watermark: only advance when we see an end-of-batch marker.
class PunctuatedWmGen implements WatermarkGenerator<Event> {
    long maxTsSeen = Long.MIN_VALUE;   // max event-time observed so far
    long lastWm = Long.MIN_VALUE;      // last emitted watermark (must be monotonic)

    void onEvent(Event e, long ts, WatermarkOutput out) {
        maxTsSeen = max(maxTsSeen, ts);

        if (e.isEndOfBatch()) {
            long wm = max(lastWm, maxTsSeen);  // ensure monotonic
            lastWm = wm;
            out.emitWatermark(new Watermark(wm));
        }
    }

    void onPeriodicEmit(WatermarkOutput out) {
        // do nothing (punctuated = no periodic emission)
    }
}

// strategy wiring (simplified)
WatermarkStrategy<Event> strat =
    WatermarkStrategy.forGenerator(ctx -> new PunctuatedWmGen())
        .withTimestampAssigner((e, ignored) -> e.getTimestamp());
```

**Use Case**: When you have explicit markers indicating "no more data for this time period."

---

## Watermark Propagation Through Operators

Watermarks flow through the operator graph:

```
Source → Map → Filter → Window → Sink
  WM1      WM1    WM1     WM1     WM1
```

**Key Points**:
- Watermarks are broadcast to all downstream operators
- Each operator forwards the minimum watermark from all inputs
- Operators can delay watermarks (e.g., buffering for joins)

**Example**:
- Source emits watermark 14:05
- Map operator receives it, processes events, forwards watermark 14:05
- Window operator receives it, checks if any windows can close

---


## Allowed Lateness and Late Data Handling

### Allowed Lateness

Even after a window **first fires**, Flink can still accept late data for a grace period:

```java
.window(TumblingEventTimeWindows.of(Time.hours(1)))
.allowedLateness(Time.minutes(10))  // Accept late data for 10 minutes after window end
````

**How it works**:

* For window `[14:00, 15:00)`:
* When `watermark >= 15:00`, the window **fires for the first time** and emits results
* Allowed lateness = 10 minutes
* Events with timestamps in `[14:00, 15:00)` arriving **before `watermark = 15:10`** are still accepted
* When such late events arrive, the window **re-fires and updates its results**
* When `watermark >= 15:10`, the window state is **cleaned up**

### Late Data Handling Options

1. **Update Results** (default behavior with allowed lateness):

   * Late events **within the allowed lateness period** are added to the window
   * The window **re-fires** and emits updated results
   * Results are emitted on the **main output**

2. **Side Output (late beyond allowed lateness)**:

   * Events that arrive **after the allowed lateness period** are considered *late beyond allowed lateness*
   * Such events do **not** enter the window and can be sent to a side output:

   ```java
   OutputTag<Event> lateTag = new OutputTag<Event>("late"){};
   windowedStream.sideOutputLateData(lateTag);
   ```

3. **Drop** (no allowed lateness and no side output):

   * Late data is silently dropped
   * Use when late data is not important

---

## Watermark Configuration in Flink SQL

### Basic Watermark Declaration

```sql
CREATE TABLE rss_events (
    title STRING,
    published_at TIMESTAMP(3),  -- Event time column
    source STRING,
    WATERMARK FOR published_at AS published_at - INTERVAL '5' MINUTE
) WITH (...);
```

**Syntax**: `WATERMARK FOR time_column AS time_column - INTERVAL 'N' MINUTE`

**MarketLag Project**: Uses 5-minute watermark delay:
```sql
WATERMARK FOR published_at AS published_at - INTERVAL '5' MINUTE
```

This means: "Wait 5 minutes after seeing an event before considering earlier windows complete."

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import java.time.Duration;

public class WatermarkDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // Create source with out-of-order events
        DataStream<Event> events = env.addSource(new SourceFunction<Event>() {
            @Override
            public void run(SourceContext<Event> ctx) throws Exception {
                // Events arrive out of order
                ctx.collectWithTimestamp(new Event("A", 1000L), 1000L);  // Time 1s
                ctx.collectWithTimestamp(new Event("C", 3000L), 3000L);  // Time 3s (early!)
                ctx.collectWithTimestamp(new Event("B", 2000L), 2000L);  // Time 2s (late!)
                ctx.collectWithTimestamp(new Event("D", 4000L), 4000L);  // Time 4s
            }
        });

        // Assign watermarks with 1 second delay
        DataStream<Event> withWatermarks = events.assignTimestampsAndWatermarks(
            WatermarkStrategy
                .<Event>forBoundedOutOfOrderness(Duration.ofSeconds(1))
                .withTimestampAssigner((event, timestamp) -> event.getTimestamp())
        );

        // Window aggregation (will trigger when watermark passes window end)
        withWatermarks
            .keyBy(Event::getKey)
            .window(TumblingEventTimeWindows.of(Time.seconds(2)))
            .sum("value")
            .print();

        env.execute("Watermark Demo");
    }
}
```

---

## Watermark Delay Tuning

### Too Small Delay
- ❌ Windows close too early, many late events
- ❌ Results incomplete, need frequent updates
- **Symptom**: High late data rate

### Too Large Delay
- ❌ Windows stay open too long, high latency
- ❌ Results delayed unnecessarily
- **Symptom**: High end-to-end latency

### Optimal Delay
- ✅ Balance between completeness and latency
- ✅ Based on data source characteristics (network delays, processing delays)
- **MarketLag Project**: 5 minutes is reasonable for RSS feeds (network delays, API polling intervals)

---

## Common Mistakes

1. **Not setting watermarks for event-time windows**:
   - ❌ Using event-time windows without watermarks
   - ✅ Always set watermarks when using event-time windows

2. **Wrong watermark delay**:
   - ❌ Using 0 delay (windows close immediately, miss late data)
   - ✅ Set delay based on data source characteristics (MarketLag uses 5 min)

3. **Watermark in SQL syntax errors**:
   - ❌ `WATERMARK FOR time_col AS time_col - 5 MINUTE` (missing INTERVAL)
   - ✅ `WATERMARK FOR time_col AS time_col - INTERVAL '5' MINUTE`

4. **Not handling late data**:
   - ❌ Ignoring late data, getting incomplete results
   - ✅ Use allowed lateness or side outputs for late data

5. **Watermark not propagating**:
   - ❌ Custom operators blocking watermarks
   - ✅ Ensure operators forward watermarks correctly

---

## Mind Trigger: When to Think About This

Think about watermarks when:
- **Setting up event-time windows**: Section 1.6 requires watermarks to trigger windows
- **Handling out-of-order data**: Kafka partitions, network delays cause out-of-order arrival
- **Tuning latency vs completeness**: Balance window latency with data completeness
- **Debugging window issues**: Windows not triggering? Check watermark generation
- **Configuring Flink SQL**: CREATE TABLE statements need WATERMARK declaration

**In MarketLag project**: All three jobs use 5-minute watermark delay. RSS events and Polymarket prices both have watermarks declared in their table definitions. Windows trigger when watermark passes window end time.

---

## Summary

Watermarks enable Flink to determine when event-time windows can close. They represent "no events before this time should arrive" and are generated periodically or punctuated. Watermark delay (5 minutes in MarketLag) balances latency and completeness. Watermarks are essential for event-time windowing (section 1.6) and must be declared in Flink SQL table definitions.

