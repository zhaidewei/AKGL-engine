# Flink SQL User-Defined Functions (UDFs)

**Learning Point**: 3.5 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.3 (Table API/SQL), Java/Python basics, understanding of functions
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**User-Defined Function (UDF)**: A custom function written by the user that can be used in Flink SQL queries. Extends Flink SQL with domain-specific logic.

**Scalar UDF**: A UDF that takes one or more input values and returns a single output value. Used for transformations (e.g., string manipulation, calculations).

**Table UDF**: A UDF that returns a table (multiple rows). Used for table-valued functions (e.g., splitting strings into rows).

**UDF Registration**: Registering UDFs with Flink TableEnvironment so they can be used in SQL queries.

**UDF Usage in SQL**: Calling registered UDFs in SQL queries like built-in functions.

---

## Plain Language Explanation

Think of UDFs like custom functions in SQL:

- **Scalar UDF** = Custom function: "Calculate confidence score" or "Format timestamp"
- **Table UDF** = Table generator: "Split string into rows" or "Generate time series"
- **Registration** = Making function available: "Register function so SQL can use it"

**Why Needed**: MarketLag may need UDFs for confidence calculation or signal processing if logic is too complex for SQL.

---

## Analogy

If you know **SQL UDFs** or **Python functions** (which you do), Flink UDFs are similar:
- SQL CREATE FUNCTION = Flink UDF registration
- Python def function = Flink UDF implementation

Key difference: Flink UDFs work over unbounded streams, processing records continuously.

---

## Relationship to Already Learned Topics

- **1.3 Table API/SQL**: UDFs extend Flink SQL capabilities
- **12.2 Confidence Score**: UDFs could implement confidence calculation
- **Java/Python**: UDFs are written in Java or Python
- **Functions**: You already know functions - UDFs are custom functions

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// Scalar UDF (simplified)
class ScalarFunction {
    Object eval(Object... args) {
        // Custom logic
        return result;
    }
}

// UDF registration (simplified)
tableEnv.createTemporaryFunction("my_udf", new MyScalarFunction());
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/functions/ScalarFunction.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/functions/ScalarFunction.java

---

## Scalar UDF: Simple Transformations

### Java Scalar UDF

```java
import org.apache.flink.table.functions.ScalarFunction;

public class ConfidenceUDF extends ScalarFunction {
    public double eval(double signalDelta, double maxSignalDelta,
                      double priceDelta, double sourceWeight) {
        // Confidence calculation (section 12.2)
        double signalFactor = (signalDelta / maxSignalDelta) * 0.5;
        double priceFactor = (1 - Math.abs(priceDelta)) * 0.3;
        double sourceFactor = sourceWeight * 0.2;
        return Math.min(1.0, signalFactor + priceFactor + sourceFactor);
    }
}
```

### Registration

```java
tableEnv.createTemporaryFunction("calculate_confidence", new ConfidenceUDF());
```

### Usage in SQL

```sql
SELECT
    market_slug,
    calculate_confidence(signal_delta, max_signal_delta, price_delta, source_weight) as confidence
FROM joined_data;
```

**MarketLag**: Could use UDF for confidence calculation if SQL becomes too complex.

---

## Table UDF: Table-Valued Functions

### Java Table UDF

```java
import org.apache.flink.table.functions.TableFunction;

public class SplitUDF extends TableFunction<Row> {
    public void eval(String str, String delimiter) {
        String[] parts = str.split(delimiter);
        for (String part : parts) {
            collect(Row.of(part));
        }
    }
}
```

### Registration

```java
tableEnv.createTemporaryFunction("split_string", new SplitUDF());
```

### Usage in SQL

```sql
SELECT
    market_slug,
    word
FROM events,
LATERAL TABLE(split_string(keywords, ',')) AS T(word);
```

---

## UDF Registration and Usage in SQL

### Registration Methods

**Temporary Function** (Session-scoped):
```java
tableEnv.createTemporaryFunction("my_udf", new MyUDF());
```

**Permanent Function** (Catalog-scoped):
```java
tableEnv.createFunction("my_udf", new MyUDF());
```

**MarketLag**: Uses temporary functions for project-specific logic.

### Usage in SQL

Once registered, use UDF like built-in function:

```sql
SELECT
    my_udf(column1, column2) as result
FROM table;
```

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;
import org.apache.flink.table.functions.ScalarFunction;

public class UDFDemo {
    // Define UDF
    public static class MultiplyUDF extends ScalarFunction {
        public double eval(double a, double b) {
            return a * b;
        }
    }

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);

        // Register UDF
        tableEnv.createTemporaryFunction("multiply", new MultiplyUDF());

        // Use in SQL
        tableEnv.executeSql(
            "SELECT " +
            "  value1," +
            "  value2," +
            "  multiply(value1, value2) as product " +
            "FROM input_table"
        );

        env.execute("UDF Demo");
    }
}
```

---

## Common Mistakes

1. **Not registering UDF**:
   - ❌ Using UDF in SQL without registration
   - ✅ Always register: `tableEnv.createTemporaryFunction(...)`

2. **Wrong function type**:
   - ❌ Using ScalarFunction for table-valued function
   - ✅ Use TableFunction for table-valued functions

3. **Type mismatches**:
   - ❌ UDF expects INT but receives STRING
   - ✅ Ensure types match: use correct Flink types

4. **Performance issues**:
   - ❌ Complex UDF logic causing performance problems
   - ✅ Optimize UDF logic, consider ProcessFunction for complex logic

5. **Not handling nulls**:
   - ❌ UDF crashes on NULL input
   - ✅ Handle NULL: `if (arg == null) return null;`

---

## Mind Trigger: When to Think About This

Think about UDFs when:
- **Complex calculations**: Confidence calculation may need UDF if SQL is too complex
- **Custom transformations**: Need transformations not available in SQL
- **Reusable logic**: Want to reuse logic across multiple queries
- **Signal processing**: MarketLag may need UDFs for signal processing
- **Alternative to ProcessFunction**: UDFs provide SQL-friendly alternative

**In MarketLag project**: May use UDFs for confidence calculation or signal processing if SQL becomes too complex. Alternatively, confidence calculation may be done in ProcessFunction (section 4.1) or kept in SQL if possible.

---

## Summary

Flink SQL UDFs enable custom functions in SQL queries. Scalar UDFs return single values, table UDFs return tables. UDFs must be registered before use. MarketLag may use UDFs for confidence calculation or signal processing. Understanding UDFs helps extend Flink SQL with domain-specific logic.

