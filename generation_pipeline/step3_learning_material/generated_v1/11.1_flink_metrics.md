# Flink Metrics

**Learning Point**: 11.1 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 6.4 (Confluent Cloud Monitoring), understanding of metrics
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Flink Metrics**: Built-in and custom metrics that provide insights into Flink job performance, health, and behavior.

**Built-in Metrics**: Flink-provided metrics including throughput (records/second), latency (end-to-end delay), checkpoint duration, and state size.

**Custom Metrics**: User-defined metrics (counters, gauges, histograms) for domain-specific monitoring.

**Metrics Export**: Sending Flink metrics to external systems (Prometheus, InfluxDB) for monitoring and alerting.

**Metrics Types**: Counters (incrementing values), Gauges (current values), Histograms (value distributions).

---

## Plain Language Explanation

Think of Flink metrics like a car's dashboard:

- **Built-in Metrics** = Standard gauges: "Speed, fuel level, engine temperature"
- **Custom Metrics** = Custom gauges: "Your specific measurements"
- **Metrics Export** = Dashboard display: "Show metrics on monitoring dashboard"

**Why Needed**: MarketLag needs to monitor job performance and health through metrics.

---

## Analogy

If you know **application metrics** (which you do), Flink metrics are similar:
- Application metrics = Flink metrics (both track performance)
- Prometheus = Metrics export (both export to monitoring systems)
- Custom metrics = Domain metrics (both track business-specific metrics)

Key difference: Flink metrics are built into the framework, automatically collected.

---

## Relationship to Already Learned Topics

- **6.4 Confluent Cloud Monitoring**: Confluent Cloud provides Flink metrics
- **11.2 Grafana**: Metrics visualized in Grafana dashboards
- **Monitoring**: You already know monitoring - Flink metrics extend it

---

## Built-in Metrics: Throughput, Latency, Checkpoint Duration

### Throughput

**Metric**: `numRecordsInPerSecond`, `numRecordsOutPerSecond`

**Meaning**: Records processed per second.

**Why Important**: Indicates job performance. Low throughput may indicate backpressure.

**MarketLag**: Monitors throughput for all three jobs.

### Latency

**Metric**: `latency` (p50, p95, p99)

**Meaning**: End-to-end delay from source to sink.

**Why Important**: Low latency is critical for real-time systems.

**MarketLag**: Monitors latency to ensure lag detection is timely.

### Checkpoint Duration

**Metric**: `checkpointDuration`

**Meaning**: Time taken to create checkpoint.

**Why Important**: Long checkpoint duration may indicate state too large or backpressure.

**MarketLag**: Monitors checkpoint duration (target: < 1 minute for 5-minute interval).

---

## Custom Metrics: Registering Custom Counters, Gauges

### Custom Counter

```java
import org.apache.flink.metrics.Counter;

public class MyProcessFunction extends KeyedProcessFunction<String, Event, Result> {
    private transient Counter lagDetectedCounter;

    @Override
    public void open(Configuration config) {
        lagDetectedCounter = getRuntimeContext()
            .getMetricGroup()
            .counter("lag_detected_count");
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        if (isLagDetected(event)) {
            lagDetectedCounter.inc();  // Increment counter
            out.collect(new LagSignal(event));
        }
    }
}
```

**MarketLag**: Can use custom counters to track lag detection count.

### Custom Gauge

```java
import org.apache.flink.metrics.Gauge;

public class MyProcessFunction extends KeyedProcessFunction<String, Event, Result> {
    private transient Gauge<Double> maxSignalDeltaGauge;
    private double currentMax = 0.0;

    @Override
    public void open(Configuration config) {
        maxSignalDeltaGauge = getRuntimeContext()
            .getMetricGroup()
            .gauge("max_signal_delta", new Gauge<Double>() {
                @Override
                public Double getValue() {
                    return currentMax;
                }
            });
    }
}
```

**MarketLag**: Can use custom gauges to track max_signal_delta values.

---

## Metrics Export: Prometheus, InfluxDB

### Prometheus Export

**Configuration**:
```yaml
metrics.reporter.prometheus.class: org.apache.flink.metrics.prometheus.PrometheusReporter
metrics.reporter.prometheus.port: 9249
```

**Access**: `http://flink-jobmanager:9249/metrics`

**MarketLag**: Can export metrics to Prometheus for Grafana visualization.

### InfluxDB Export

**Configuration**:
```yaml
metrics.reporter.influxdb.class: org.apache.flink.metrics.influxdb.InfluxdbReporter
metrics.reporter.influxdb.host: localhost
metrics.reporter.influxdb.port: 8086
```

**MarketLag**: Can export metrics to InfluxDB for time-series storage.

---

## Minimum Viable Code

```java
import org.apache.flink.metrics.Counter;
import org.apache.flink.metrics.Gauge;
import org.apache.flink.streaming.api.functions.ProcessFunction;

public class MetricsDemo {
    public static class MetricsProcessFunction extends ProcessFunction<Event, Result> {
        private transient Counter processedCounter;
        private transient Counter errorCounter;
        private transient Gauge<Long> stateSizeGauge;

        @Override
        public void open(Configuration config) {
            // Custom counter
            processedCounter = getRuntimeContext()
                .getMetricGroup()
                .counter("records_processed");

            // Custom counter for errors
            errorCounter = getRuntimeContext()
                .getMetricGroup()
                .counter("errors");

            // Custom gauge
            stateSizeGauge = getRuntimeContext()
                .getMetricGroup()
                .gauge("state_size", () -> getStateSize());
        }

        @Override
        public void processElement(Event event, Context ctx, Collector<Result> out) {
            try {
                processRecord(event);
                processedCounter.inc();
            } catch (Exception e) {
                errorCounter.inc();
            }
        }

        private long getStateSize() {
            // Calculate state size
            return 0L;
        }
    }
}
```

---

## Common Mistakes

1. **Not monitoring metrics**:
   - ❌ No metrics monitoring, issues unnoticed
   - ✅ Monitor key metrics (throughput, latency, checkpoints)

2. **Too many custom metrics**:
   - ❌ Creating too many metrics (overhead)
   - ✅ Create only necessary custom metrics

3. **Not exporting metrics**:
   - ❌ Metrics only in Flink UI (not accessible)
   - ✅ Export to Prometheus/InfluxDB for monitoring

4. **Not setting up alerts**:
   - ❌ Metrics collected but no alerts
   - ✅ Set up alerts on critical metrics

5. **Not understanding metric semantics**:
   - ❌ Misinterpreting metric values
   - ✅ Understand what each metric means

---

## Mind Trigger: When to Think About This

Think about Flink metrics when:
- **Monitoring jobs**: MarketLag monitors all three jobs
- **Performance tuning**: Metrics help identify bottlenecks
- **Troubleshooting**: Metrics help diagnose issues
- **Grafana dashboards**: Section 11.2 covers Grafana visualization
- **Alerting**: Section 11.3 covers alerting on metrics

**In MarketLag project**: Monitors built-in metrics (throughput, latency, checkpoint duration) and can add custom metrics (lag detection count). Exports metrics to Prometheus for Grafana visualization. Understanding Flink metrics is essential for monitoring and operations.

---

## Summary

Flink metrics provide insights into job performance and health. Built-in metrics include throughput, latency, and checkpoint duration. Custom metrics (counters, gauges) track domain-specific metrics. Export metrics to Prometheus or InfluxDB for monitoring. MarketLag monitors metrics for all jobs. Understanding Flink metrics is essential for monitoring and operations.

