# Exception Handling in Flink

**Learning Point**: 9.3 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.2 (DataStream API), 4.1 (ProcessFunction), understanding of exception handling
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Exception Handling in Flink**: Strategies for gracefully handling exceptions and errors in Flink operators without causing job failures.

**Try-Catch in Operators**: Using try-catch blocks in operator code to catch and handle exceptions locally.

**Side Outputs for Error Records**: Routing error records to a separate output stream (side output) instead of failing the job.

**Exception Handling in ProcessFunction**: Handling exceptions in ProcessFunction.processElement() and onTimer() methods.

**Graceful Degradation**: Continuing processing despite some record failures, rather than failing the entire job.

---

## Plain Language Explanation

Think of exception handling like error recovery:

- **Try-Catch** = Safety net: "If this fails, handle it gracefully"
- **Side Outputs** = Error bin: "Put errors in separate bin, continue processing"
- **Graceful Degradation** = Keep going: "Some records failed, but job continues"

**Why Needed**: MarketLag needs to handle malformed data gracefully without stopping the entire job.

---

## Analogy

If you know **error handling** (which you do), Flink exception handling is similar:
- Try-catch = Same concept (both catch exceptions)
- Error logging = Side outputs (both separate errors)
- Error recovery = Graceful degradation (both continue despite errors)

Key difference: Flink handles errors in streaming context (continuous processing).

---

## Relationship to Already Learned Topics

- **1.2 DataStream API**: Exceptions occur in DataStream operators
- **4.1 ProcessFunction**: Exceptions in ProcessFunction methods
- **9.1 Dead Letter Queue**: Side outputs can send to DLQ
- **9.2 Data Validation**: Validation failures handled as exceptions

---

## Try-Catch in Operators

### Basic Pattern

```java
stream.map(record -> {
    try {
        // Process record
        return processRecord(record);
    } catch (Exception e) {
        // Handle exception
        log.error("Error processing record: {}", e);
        return null;  // Or handle differently
    }
})
.filter(record -> record != null);  // Filter out nulls
```

**MarketLag**: Can use try-catch in custom operators.

### Flink SQL Exception Handling

```sql
-- Flink SQL handles some errors automatically
CREATE TABLE events (
    value DOUBLE
) WITH (
    'format' = 'json',
    'json.ignore-parse-errors' = 'true'  -- Skip malformed JSON
);
```

**MarketLag**: Uses `json.ignore-parse-errors` = 'true' to skip malformed JSON.

---

## Side Outputs for Error Records

### Side Output Pattern

```java
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.OutputTag;

// Define side output tag
OutputTag<String> errorTag = new OutputTag<String>("errors"){};

// Process with side output
DataStream<String> mainStream = stream.process(new ProcessFunction<String, String>() {
    @Override
    public void processElement(String value, Context ctx, Collector<String> out) {
        try {
            // Process record
            String result = processRecord(value);
            out.collect(result);
        } catch (Exception e) {
            // Send to side output
            ctx.output(errorTag, "Error: " + value + ", Exception: " + e.getMessage());
        }
    }
});

// Get error stream
DataStream<String> errorStream = mainStream.getSideOutput(errorTag);

// Send errors to DLQ
errorStream.sinkTo(dlqSink);
```

**MarketLag**: Can use side outputs to route errors to DLQ topics.

---

## Exception Handling in ProcessFunction

### ProcessFunction Exception Handling

```java
public class MyProcessFunction extends KeyedProcessFunction<String, Event, Result> {
    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        try {
            // Process event
            Result result = processEvent(event);
            out.collect(result);
        } catch (IllegalArgumentException e) {
            // Handle specific exception
            log.warn("Invalid event: {}", e.getMessage());
            // Optionally send to side output
        } catch (Exception e) {
            // Handle general exception
            log.error("Error processing event: {}", e);
            // Send to DLQ or side output
        }
    }

    @Override
    public void onTimer(long timestamp, OnTimerContext ctx, Collector<Result> out) {
        try {
            // Timer logic
        } catch (Exception e) {
            log.error("Error in timer: {}", e);
        }
    }
}
```

**MarketLag**: ProcessFunction (if used for confidence calculation) should handle exceptions gracefully.

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.OutputTag;

public class ExceptionHandlingDemo {
    // Define side output for errors
    private static final OutputTag<String> ERROR_TAG = new OutputTag<String>("errors"){};

    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        DataStream<String> stream = env.fromElements("1", "2", "invalid", "4");

        // Process with exception handling
        DataStream<String> mainStream = stream.process(new ProcessFunction<String, String>() {
            @Override
            public void processElement(String value, Context ctx, Collector<String> out) {
                try {
                    // Try to parse as integer
                    int num = Integer.parseInt(value);
                    out.collect("Processed: " + num);
                } catch (NumberFormatException e) {
                    // Send to side output
                    ctx.output(ERROR_TAG, "Invalid number: " + value);
                }
            }
        });

        // Get error stream
        DataStream<String> errorStream = mainStream.getSideOutput(ERROR_TAG);

        // Print errors
        errorStream.print("ERRORS");

        // Print main stream
        mainStream.print("MAIN");

        env.execute("Exception Handling Demo");
    }
}
```

---

## Common Mistakes

1. **Not handling exceptions**:
   - ❌ Exceptions cause job failures
   - ✅ Always handle exceptions gracefully

2. **Swallowing exceptions**:
   - ❌ Catching but not logging or handling
   - ✅ Log exceptions, send to DLQ or side output

3. **Not using side outputs**:
   - ❌ Dropping error records silently
   - ✅ Use side outputs to preserve error records

4. **Too broad catch**:
   - ❌ Catching all exceptions the same way
   - ✅ Handle specific exceptions appropriately

5. **Not handling timer exceptions**:
   - ❌ Exceptions in onTimer() cause job failures
   - ✅ Always handle exceptions in onTimer()

---

## Mind Trigger: When to Think About This

Think about exception handling when:
- **Processing data**: MarketLag needs to handle malformed data gracefully
- **Custom operators**: ProcessFunction and custom operators need exception handling
- **Error recovery**: Side outputs and DLQ for error records
- **Job reliability**: Exception handling prevents job failures
- **Data quality**: Section 9.2 covers validation, exceptions handle validation failures

**In MarketLag project**: Handles exceptions in Flink operators, uses side outputs for errors, sends errors to DLQ. Understanding exception handling is essential for reliable stream processing.

---

## Summary

Exception handling in Flink enables graceful error recovery without job failures. Use try-catch in operators, side outputs for error records, and exception handling in ProcessFunction. MarketLag handles exceptions gracefully, routes errors to DLQ. Understanding exception handling is essential for reliable stream processing.

