# ProcessFunction for Stateful Logic

**Learning Point**: 4.1 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.2 (DataStream API), 1.7 (State Types), 1.9 (State Access), Java basics
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**ProcessFunction**: A low-level Flink operator that provides fine-grained control over stream processing. Allows access to per-element processing, state, and timers.

**KeyedProcessFunction**: ProcessFunction for keyed streams. Provides access to keyed state (ValueState, MapState, etc.) scoped to the key.

**processElement**: Method called for each incoming record. Main processing logic goes here.

**onTimer**: Method called when a registered timer fires. Used for time-based processing (e.g., timeouts, periodic tasks).

**Timer Registration**: Registering timers to fire at specific timestamps (event time or processing time).

---

## Plain Language Explanation

Think of ProcessFunction like a custom operator with full control:

- **ProcessFunction** = Custom workstation: You control exactly what happens to each item
- **processElement** = Process each item: "When an event arrives, do this"
- **onTimer** = Timer callback: "When timer fires, do that"
- **State Access** = Memory: Remember information between events

**Why Needed**: MarketLag Job 3 may need ProcessFunction for confidence calculation with historical state (max_signal_delta stored in MapState).

---

## Analogy

If you know **Spark's mapPartitions** or **custom UDFs** (which you do), ProcessFunction is similar:
- Spark mapPartitions = Flink ProcessFunction (both provide fine-grained control)
- Custom UDF = ProcessFunction (both allow custom logic)

Key difference: ProcessFunction has built-in state and timer support, making it more powerful for stateful processing.

---

## Relationship to Already Learned Topics

- **1.2 DataStream API**: ProcessFunction is a DataStream operator
- **1.7 State Types**: ProcessFunction accesses state (ValueState, MapState)
- **1.9 State Access**: How to read/write state in ProcessFunction
- **1.6 Windows**: ProcessFunction provides alternative to windows for time-based processing

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// ProcessFunction interface (simplified)
abstract class ProcessFunction<IN, OUT> {
    void processElement(IN value, Context ctx, Collector<OUT> out);
    void onTimer(long timestamp, OnTimerContext ctx, Collector<OUT> out);
}

// KeyedProcessFunction (simplified)
abstract class KeyedProcessFunction<K, IN, OUT> extends ProcessFunction<IN, OUT> {
    RuntimeContext getRuntimeContext();  // Access to state
    TimerService timerService();  // Access to timers
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/ProcessFunction.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/ProcessFunction.java

---

## ProcessFunction Interface: processElement, onTimer

### processElement

Called for each incoming record:

```java
@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    // Process each event
    // Access state
    // Register timers
    // Emit results
}
```

**Parameters**:
- **event**: Incoming record
- **ctx**: Context (access to timestamp, timer service)
- **out**: Collector to emit results

### onTimer

Called when a registered timer fires:

```java
@Override
public void onTimer(long timestamp, OnTimerContext ctx, Collector<Result> out) {
    // Handle timer
    // Access state
    // Emit results
}
```

**Use Cases**: Timeouts, periodic tasks, cleanup.

---

## KeyedProcessFunction for Keyed State Access

### KeyedProcessFunction vs ProcessFunction

**KeyedProcessFunction**: For keyed streams (after keyBy), provides keyed state access.

```java
stream.keyBy(Event::getKey)
    .process(new KeyedProcessFunction<String, Event, Result>() {
        // Can access keyed state (ValueState, MapState, etc.)
    });
```

**ProcessFunction**: For non-keyed streams, provides operator state access.

```java
stream.process(new ProcessFunction<Event, Result>() {
    // Can access operator state (ListState, etc.)
});
```

**MarketLag Job 3**: Uses KeyedProcessFunction (keyed by market_slug|outcome) to access MapState.

---

## Timer Registration and Firing

### Registering Timers

```java
@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    // Register event-time timer
    long timerTime = event.getTimestamp() + 3600000;  // 1 hour later
    ctx.timerService().registerEventTimeTimer(timerTime);

    // Register processing-time timer
    ctx.timerService().registerProcessingTimeTimer(System.currentTimeMillis() + 3600000);
}
```

### Timer Firing

```java
@Override
public void onTimer(long timestamp, OnTimerContext ctx, Collector<Result> out) {
    // Timer fired at 'timestamp'
    // Access state
    // Emit results
}
```

**Use Cases**:
- Timeouts: Clean up state after inactivity
- Periodic tasks: Emit results periodically
- Delayed processing: Process after delay

---

## MarketLag Job 3 Pattern: Confidence Calculation

```java
public class ConfidenceCalculator extends KeyedProcessFunction<String, Event, Result> {
    private MapState<String, Double> maxSignalDeltaState;  // outcome -> max_delta

    @Override
    public void open(Configuration config) {
        MapStateDescriptor<String, Double> descriptor =
            new MapStateDescriptor<>("maxSignalDelta", String.class, Double.class);
        maxSignalDeltaState = getRuntimeContext().getMapState(descriptor);
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        String outcome = event.getOutcome();
        double signalDelta = event.getSignalDelta();

        // Read state
        Double currentMax = maxSignalDeltaState.get(outcome);

        // Update state
        if (currentMax == null || signalDelta > currentMax) {
            maxSignalDeltaState.put(outcome, signalDelta);
            currentMax = signalDelta;
        }

        // Calculate confidence (section 12.2)
        double confidence = calculateConfidence(signalDelta, currentMax,
                                                event.getPriceDelta(),
                                                event.getSourceWeightAvg());

        out.collect(new Result(event.getMarket(), confidence));
    }
}
```

**Note**: MarketLag may implement confidence calculation in Flink SQL instead of ProcessFunction, but ProcessFunction provides more control.

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.api.common.state.*;
import org.apache.flink.configuration.Configuration;

public class ProcessFunctionDemo {
    public static class MyProcessFunction extends KeyedProcessFunction<String, Event, Result> {
        private ValueState<Double> lastValue;

        @Override
        public void open(Configuration config) {
            ValueStateDescriptor<Double> descriptor =
                new ValueStateDescriptor<>("lastValue", Double.class);
            lastValue = getRuntimeContext().getState(descriptor);
        }

        @Override
        public void processElement(Event event, Context ctx, Collector<Result> out) {
            // Read state
            Double prev = lastValue.value();

            // Process
            if (prev != null) {
                double delta = event.getValue() - prev;
                out.collect(new Result(event.getKey(), delta));
            }

            // Update state
            lastValue.update(event.getValue());

            // Register timer (example)
            ctx.timerService().registerEventTimeTimer(event.getTimestamp() + 3600000);
        }

        @Override
        public void onTimer(long timestamp, OnTimerContext ctx, Collector<Result> out) {
            // Timer fired
            // Cleanup or periodic task
        }
    }
}
```

---

## Common Mistakes

1. **Not keying stream**:
   - ❌ Using KeyedProcessFunction without keyBy
   - ✅ Always key stream: `stream.keyBy(...).process(...)`

2. **State not initialized**:
   - ❌ Accessing state before open() called
   - ✅ Initialize state in open() method

3. **Not checking null**:
   - ❌ `state.value()` without null check
   - ✅ Always check: `if (state.value() != null) { ... }`

4. **Timer not registered**:
   - ❌ Expecting onTimer without registering timer
   - ✅ Register timer in processElement: `ctx.timerService().registerEventTimeTimer(...)`

5. **Wrong timer type**:
   - ❌ Using event-time timer with processing-time stream
   - ✅ Match timer type to time characteristic

---

## Mind Trigger: When to Think About This

Think about ProcessFunction when:
- **Custom stateful logic**: MarketLag Job 3 may use ProcessFunction for confidence calculation
- **Fine-grained control**: Need more control than SQL provides
- **Timer-based processing**: Need timeouts, periodic tasks
- **Complex state management**: Need to manage state manually (MapState for max_signal_delta)
- **Performance**: ProcessFunction can be more efficient than SQL for complex logic

**In MarketLag project**: Job 3 may use ProcessFunction to calculate confidence scores with MapState storing max_signal_delta. Alternatively, confidence calculation may be done in Flink SQL. ProcessFunction provides more control and flexibility.

---

## Summary

ProcessFunction provides fine-grained control over stream processing with access to state and timers. KeyedProcessFunction enables keyed state access. processElement processes each record, onTimer handles timer callbacks. MarketLag Job 3 may use ProcessFunction for confidence calculation with MapState. Understanding ProcessFunction is essential for custom stateful logic beyond SQL capabilities.

