# Flink SQL Equi-Join

**Learning Point**: 3.3 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.3 (Table API/SQL), SQL JOIN knowledge (you already have this)
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Equi-Join**: A join operation where the join condition uses equality (=) to match rows from two tables. Both sides of the join condition must have equal values for the join to succeed.

**INNER JOIN**: Returns only rows where there is a match in both tables.

**LEFT JOIN**: Returns all rows from the left table, and matching rows from the right table. If no match, right table columns are NULL.

**Join Condition**: The ON clause specifying how to match rows (e.g., `ON left.key = right.key`).

**Join Performance**: Equi-joins can be optimized using broadcast joins (small table) or regular joins (both tables large).

---

## Plain Language Explanation

Think of equi-join like matching records from two spreadsheets:

- **Equi-Join** = Match by exact value: "Find rows where market_slug matches"
- **INNER JOIN** = Both must match: Only return rows where both tables have matching market_slug
- **LEFT JOIN** = Left table priority: Return all rows from left, match right if available

**Why Needed**: MarketLag Job 3 joins RSS signals with Polymarket prices - both have market_slug, join them to combine signals and prices.

---

## Analogy

If you know **SQL JOINs** (which you do), Flink's equi-join is the same:
- SQL `INNER JOIN ... ON left.key = right.key` = Flink equi-join
- SQL `LEFT JOIN` = Flink LEFT JOIN

Key difference: Flink joins are over unbounded streams, so they're continuous and produce results as new data arrives.

---

## Relationship to Already Learned Topics

- **1.3 Table API/SQL**: Equi-join uses Flink SQL syntax
- **3.2 Temporal Joins**: Different join type (not used in MarketLag)
- **SQL**: You already know JOIN syntax - Flink uses same syntax
- **2.2 Kafka Table Connector**: Joins tables created from Kafka topics

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```sql
-- Equi-join (simplified parsing)
SELECT *
FROM left_table l
INNER JOIN right_table r
ON l.key = r.key
-- Parses to: EquiJoinOperator
-- Matches rows where left.key equals right.key
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecJoin.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecJoin.java

---

## Equi-Join Syntax: INNER JOIN, LEFT JOIN

### INNER JOIN

Returns only rows where there is a match in both tables:

```sql
SELECT
    l.market_slug,
    l.signal,
    r.price
FROM left_table l
INNER JOIN right_table r
ON l.market_slug = r.market_slug;
```

**MarketLag Job 3**: Uses INNER JOIN to combine RSS signals and prices.

### LEFT JOIN

Returns all rows from left table, matching rows from right:

```sql
SELECT
    l.market_slug,
    l.signal,
    r.price
FROM left_table l
LEFT JOIN right_table r
ON l.market_slug = r.market_slug;
```

**Use Case**: When you want all signals even if price is missing (MarketLag could use this for error handling).

---

## Join Conditions: ON Clause with Equality

### Single Key Join

```sql
ON left.market_slug = right.market_slug
```

Matches rows where market_slug values are equal.

### Multiple Key Join

```sql
ON left.market_slug = right.market_slug
   AND left.window_start = right.event_time
```

Matches rows where both conditions are true.

**MarketLag Job 3**: Uses both market_slug and window_start = event_time for join.

---

## Join Performance: Broadcast vs Regular Join

### Broadcast Join

When one table is small, Flink can broadcast it to all subtasks:

```sql
-- Flink automatically chooses broadcast if one table is small
SELECT *
FROM large_table l
INNER JOIN small_table s
ON l.key = s.key;
```

**Optimization**: Small table is broadcast to all subtasks, avoiding shuffle.

### Regular Join

When both tables are large, Flink uses regular join (both sides shuffled):

```sql
-- Both tables are large, regular join
SELECT *
FROM large_table1 l1
INNER JOIN large_table2 l2
ON l1.key = l2.key;
```

**MarketLag Job 3**: Both RSS signals and prices are large, uses regular join.

---

## MarketLag Job 3 Example

```sql
SELECT
    r.market_slug,
    r.window_start,
    r.source_weighted_signal as rss_signal,
    p.price,
    p.price_delta,
    (r.source_weighted_signal - LAG(r.source_weighted_signal)
      OVER (PARTITION BY r.market_slug ORDER BY r.window_start)) as signal_delta
FROM rss_signals_hourly r
INNER JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start = p.event_time
WHERE r.source_weighted_signal IS NOT NULL
  AND p.price IS NOT NULL;
```

**Key Points**:
- **INNER JOIN**: Only returns rows where both RSS signal and price exist
- **Join Keys**: `market_slug` (matches market) and `window_start = event_time` (matches time)
- **LAG Function**: Calculates signal_delta (section 3.4 covers this)

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;

public class EquiJoinDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);

        // Create left table
        tableEnv.executeSql(
            "CREATE TABLE signals (" +
            "  market_slug STRING," +
            "  window_start TIMESTAMP(3)," +
            "  signal DOUBLE" +
            ") WITH ('connector' = 'kafka', ...)"
        );

        // Create right table
        tableEnv.executeSql(
            "CREATE TABLE prices (" +
            "  market_slug STRING," +
            "  event_time TIMESTAMP(3)," +
            "  price DOUBLE" +
            ") WITH ('connector' = 'kafka', ...)"
        );

        // Equi-join
        tableEnv.executeSql(
            "CREATE TABLE joined AS " +
            "SELECT " +
            "  s.market_slug," +
            "  s.window_start," +
            "  s.signal," +
            "  p.price " +
            "FROM signals s " +
            "INNER JOIN prices p " +
            "ON s.market_slug = p.market_slug " +
            "  AND s.window_start = p.event_time"
        );

        env.execute("Equi-Join Demo");
    }
}
```

---

## Common Mistakes

1. **Join condition not equi-join**:
   - ❌ `ON left.time > right.time` (not equi-join, use interval join)
   - ✅ Use equality: `ON left.key = right.key`

2. **Missing join keys**:
   - ❌ Only joining on market_slug, missing time alignment
   - ✅ Join on both: `ON market_slug = market_slug AND window_start = event_time`

3. **NULL handling**:
   - ❌ Not handling NULL values in join keys
   - ✅ Filter NULLs: `WHERE market_slug IS NOT NULL`

4. **Join performance**:
   - ❌ Not understanding broadcast vs regular join
   - ✅ Understand when Flink chooses broadcast (small table)

5. **Streaming join semantics**:
   - ❌ Expecting all historical matches immediately
   - ✅ Streaming joins produce results as new data arrives

---

## Mind Trigger: When to Think About This

Think about equi-join when:
- **Joining streams**: MarketLag Job 3 joins RSS signals with prices
- **Matching by key**: Need to match rows from two tables by exact key value
- **Combining data sources**: Join data from different Kafka topics
- **Join performance**: Understanding broadcast vs regular join helps optimization
- **Error handling**: LEFT JOIN can handle missing data (section 9.4)

**In MarketLag project**: Job 3 uses INNER JOIN to combine RSS signals (rss_signals_hourly) with Polymarket prices (polymarket_price_hourly). Joins on market_slug and window_start = event_time. This is the core pattern for combining signals and prices for lag detection.

---

## Summary

Flink SQL equi-join matches rows from two tables using equality conditions. INNER JOIN returns only matching rows, LEFT JOIN returns all left rows. Join conditions use ON clause with equality. Flink optimizes joins using broadcast (small table) or regular join (both large). MarketLag Job 3 uses INNER JOIN to combine RSS signals and prices on market_slug and time alignment. Understanding equi-joins is essential for combining data from multiple streams.

