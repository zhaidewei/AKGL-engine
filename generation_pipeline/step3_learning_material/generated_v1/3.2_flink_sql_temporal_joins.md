# Flink SQL Temporal Joins

**Learning Point**: 3.2 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.3 (Table API/SQL), 3.3 (Equi-Join), understanding of time-based joins
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Temporal Join**: A join operation that uses time to match rows from two tables. Enables joining a stream with a versioned table (table that changes over time).

**Event-Time Temporal Join**: Join using event time (AS OF SYSTEM TIME). Matches stream events with table version at that event's timestamp.

**Interval Join**: Join within time bounds (e.g., ±5 minutes). Matches rows where timestamps are within a specified interval.

**Regular Join vs Temporal Join**: Regular join matches on keys only, temporal join matches on keys and time.

---

## Plain Language Explanation

Think of temporal join like time-travel matching:

- **Temporal Join** = Time-based matching: "Match with the version of the table at this event's time"
- **Event-Time Temporal Join** = Historical lookup: "What was the price at the time this event occurred?"
- **Interval Join** = Fuzzy time matching: "Match events within 5 minutes of each other"

**Why Needed**: MarketLag could use temporal joins, but actually uses equi-join because data is pre-aligned to hours.

---

## Analogy

If you know **SQL AS OF** (temporal queries), Flink temporal joins are similar:
- SQL `AS OF TIMESTAMP` = Flink event-time temporal join
- Both look up historical versions of tables

Key difference: Flink temporal joins work over unbounded streams continuously.

---

## Relationship to Already Learned Topics

- **1.3 Table API/SQL**: Temporal joins use Flink SQL syntax
- **3.3 Equi-Join**: Different join type (MarketLag uses equi-join, not temporal)
- **1.4 Time Concepts**: Temporal joins use event time
- **SQL**: You already know temporal queries - Flink extends this to streaming

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```sql
-- Event-time temporal join (simplified)
SELECT *
FROM stream_table s
LEFT JOIN versioned_table FOR SYSTEM_TIME AS OF s.event_time AS v
ON s.key = v.key
-- Matches stream event with table version at event's timestamp
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecTemporalJoin.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecTemporalJoin.java

---

## Regular Join vs Temporal Join

### Regular Join (Equi-Join)

Matches on keys only:

```sql
SELECT *
FROM table1 t1
INNER JOIN table2 t2
ON t1.key = t2.key
```

**Use Case**: When both tables are streams and you want exact key matches.

**MarketLag**: Uses regular equi-join (section 3.3) because data is pre-aligned.

### Temporal Join

Matches on keys and time:

```sql
SELECT *
FROM stream_table s
LEFT JOIN versioned_table FOR SYSTEM_TIME AS OF s.event_time AS v
ON s.key = v.key
```

**Use Case**: When joining stream with versioned table (table that changes over time).

**MarketLag**: Could use temporal join, but uses equi-join because prices are already aligned to hours.

---

## Event-Time Temporal Join (AS OF SYSTEM TIME)

### Syntax

```sql
SELECT *
FROM stream_table s
LEFT JOIN versioned_table FOR SYSTEM_TIME AS OF s.event_time AS v
ON s.key = v.key
```

**How It Works**:
1. For each stream event, get its event_time
2. Look up versioned_table version at that timestamp
3. Join on key

**Example**: Join stream events with price table version at event time.

### Use Case

When you have:
- **Stream**: Events with timestamps
- **Versioned Table**: Table that changes over time (e.g., price history)

**MarketLag**: Could use this if prices were stored as versioned table, but prices are in stream format.

---

## Interval Join: Joining Streams Within Time Bounds

### Syntax

```sql
SELECT *
FROM stream1 s1
JOIN stream2 s2
ON s1.key = s2.key
  AND s1.event_time BETWEEN s2.event_time - INTERVAL '5' MINUTE
                        AND s2.event_time + INTERVAL '5' MINUTE
```

**How It Works**: Matches rows where timestamps are within ±5 minutes.

**Use Case**: When data may be slightly misaligned (e.g., network delays).

**MarketLag**: Not used because data is pre-aligned to UTC hours.

---

## Why MarketLag Uses Equi-Join, Not Temporal Join

### Data Alignment

MarketLag data is pre-aligned:
- **RSS signals**: Aligned to UTC hour boundaries (window_start)
- **Polymarket prices**: Aligned to UTC hour boundaries (event_time)
- **Exact Match**: window_start = event_time (exact alignment)

**Result**: Equi-join works perfectly - no need for temporal join.

### If Data Were Misaligned

If prices weren't aligned:
- **Temporal Join**: Could use event-time temporal join
- **Interval Join**: Could use interval join with ±5 minutes

**But**: MarketLag aligns data, so equi-join is simpler and more efficient.

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;

public class TemporalJoinDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);

        // Create stream table
        tableEnv.executeSql(
            "CREATE TABLE events (" +
            "  key STRING," +
            "  event_time TIMESTAMP(3)," +
            "  value DOUBLE" +
            ") WITH ('connector' = 'kafka', ...)"
        );

        // Create versioned table
        tableEnv.executeSql(
            "CREATE TABLE prices (" +
            "  key STRING," +
            "  price DOUBLE," +
            "  update_time TIMESTAMP(3)," +
            "  PRIMARY KEY (key) NOT ENFORCED," +
            "  WATERMARK FOR update_time AS update_time" +
            ") WITH ('connector' = 'jdbc', ...)"
        );

        // Temporal join
        tableEnv.executeSql(
            "SELECT " +
            "  e.key," +
            "  e.event_time," +
            "  e.value," +
            "  p.price " +
            "FROM events e " +
            "LEFT JOIN prices FOR SYSTEM_TIME AS OF e.event_time AS p " +
            "ON e.key = p.key"
        );

        env.execute("Temporal Join Demo");
    }
}
```

---

## Common Mistakes

1. **Using temporal join when equi-join suffices**:
   - ❌ Using temporal join for pre-aligned data
   - ✅ Use equi-join when data is aligned (MarketLag pattern)

2. **Wrong time column**:
   - ❌ Using processing time instead of event time
   - ✅ Use event time for temporal joins

3. **Not understanding versioned tables**:
   - ❌ Using temporal join with regular table
   - ✅ Temporal join requires versioned table (changes over time)

4. **Interval too large**:
   - ❌ Using ±1 hour interval (too large, matches too many)
   - ✅ Use appropriate interval (e.g., ±5 minutes)

5. **Performance issues**:
   - ❌ Temporal join can be expensive
   - ✅ Use equi-join when possible (simpler, faster)

---

## Mind Trigger: When to Think About This

Think about temporal joins when:
- **Joining with versioned tables**: Need to join stream with table that changes over time
- **Data misalignment**: Data not perfectly aligned, need fuzzy matching
- **Historical lookups**: Need to look up table version at event time
- **Understanding join types**: Section 12.5 covers join type selection
- **MarketLag design**: Understanding why equi-join is used instead

**In MarketLag project**: Uses equi-join (section 3.3) instead of temporal join because data is pre-aligned to UTC hours. Understanding temporal joins helps understand why equi-join is the right choice.

---

## Summary

Flink SQL temporal joins enable time-based matching between streams and versioned tables. Event-time temporal join matches stream events with table version at event's timestamp. Interval join matches rows within time bounds. MarketLag uses equi-join instead of temporal join because data is pre-aligned. Understanding temporal joins helps choose the right join type (section 12.5).

