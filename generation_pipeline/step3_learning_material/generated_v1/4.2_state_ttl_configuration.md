# State TTL Configuration

**Learning Point**: 4.2 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.7 (State Types), 1.8 (State Backend), 1.9 (State Access)
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**State TTL (Time To Live)**: Configuration that automatically expires state after a specified duration. Prevents unbounded state growth by removing old state entries.

**TTL Update Strategy**: When to update the TTL timestamp:
- **OnCreateAndWrite**: TTL updated when state is created or written
- **OnReadAndWrite**: TTL updated on both read and write operations

**State Cleanup**: Automatic removal of expired state entries. Flink periodically cleans up expired state.

**TTL Configuration**: Setting TTL duration and update strategy for state descriptors.

---

## Plain Language Explanation

Think of State TTL like expiration dates:

- **TTL** = Expiration date: "This state expires after 7 days"
- **Update Strategy** = When to refresh: "Update expiration date when written" or "when read or written"
- **Cleanup** = Automatic removal: "Delete expired state automatically"

**Why Needed**: MarketLag stores max_signal_delta in MapState. Without TTL, state grows unbounded. 7-day TTL keeps only recent history.

---

## Analogy

If you know **Redis TTL** or **cache expiration** (which you do), Flink State TTL is similar:
- Redis TTL = Flink State TTL (both expire after duration)
- Cache expiration = State TTL (both prevent unbounded growth)

Key difference: Flink TTL is integrated with state backend and checkpoints.

---

## Relationship to Already Learned Topics

- **1.7 State Types**: TTL applies to all state types (ValueState, MapState, etc.)
- **1.8 State Backend**: TTL works with all state backends (RocksDB in MarketLag)
- **1.9 State Access**: TTL affects state access (expired state is not accessible)
- **State Management**: TTL is essential for preventing unbounded state growth

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// StateTtlConfig (simplified)
class StateTtlConfig {
    Time ttl;  // Duration (e.g., 7 days)
    UpdateType updateType;  // OnCreateAndWrite or OnReadAndWrite
    StateVisibility visibility;  // NeverReturnExpired or ReturnExpiredIfNotCleanedUp
}

// TTL state (simplified)
class TtlState<T> {
    T value;
    long expirationTime;

    boolean isExpired() {
        return System.currentTimeMillis() > expirationTime;
    }
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-runtime/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-runtime/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java

---

## TTL Configuration: When to Expire State

### Basic TTL Configuration

```java
StateTtlConfig ttlConfig = StateTtlConfig
    .newBuilder(Time.days(7))  // Expire after 7 days
    .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)
    .build();
```

**MarketLag Project**: Uses 7-day TTL for MapState storing max_signal_delta.

### TTL Duration Options

```java
Time.days(7)      // 7 days
Time.hours(24)    // 24 hours
Time.minutes(60)  // 60 minutes
Time.seconds(30)  // 30 seconds
```

**Choose based on**: How long you need historical data. MarketLag uses 7 days for historical baseline.

---

## TTL Update Strategies: OnCreateAndWrite, OnReadAndWrite

### OnCreateAndWrite (MarketLag Uses This)

TTL is updated only when state is created or written:

```java
.setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
```

**Behavior**:
- Create state → TTL set to now + 7 days
- Write state → TTL updated to now + 7 days
- Read state → TTL not updated (expires after 7 days from last write)

**Use Case**: When you want state to expire after inactivity (MarketLag pattern).

**Example**:
- Day 1: Write max_signal_delta = 2.0 → Expires Day 8
- Day 2: Read max_signal_delta → Still expires Day 8 (not updated)
- Day 5: Write max_signal_delta = 3.0 → Expires Day 12 (updated)

### OnReadAndWrite

TTL is updated on both read and write:

```java
.setUpdateType(StateTtlConfig.UpdateType.OnReadAndWrite)
```

**Behavior**:
- Create state → TTL set to now + 7 days
- Write state → TTL updated to now + 7 days
- Read state → TTL updated to now + 7 days (refreshed)

**Use Case**: When you want to keep frequently accessed state alive.

**Example**:
- Day 1: Write max_signal_delta = 2.0 → Expires Day 8
- Day 2: Read max_signal_delta → Expires Day 9 (updated)
- Day 5: Read max_signal_delta → Expires Day 12 (updated)

---

## State Cleanup: Expired State Removal

### Automatic Cleanup

Flink automatically cleans up expired state:
- **Periodic Cleanup**: Runs periodically to remove expired entries
- **Lazy Cleanup**: Checks expiration on access (may return expired if not cleaned yet)

### State Visibility

Controls whether expired state is returned:

```java
// Never return expired state (default)
.setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)

// Return expired if not cleaned up yet (for debugging)
.setStateVisibility(StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp)
```

**MarketLag Project**: Uses NeverReturnExpired (default).

---

## Example: Setting 7-Day TTL for MapState Storing max_signal_delta

### Complete Configuration

```java
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.time.Time;

public class MarketLagStateConfig {
    public static StateTtlConfig createTtlConfig() {
        return StateTtlConfig
            .newBuilder(Time.days(7))  // 7-day TTL
            .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)  // Update on write
            .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)  // Don't return expired
            .build();
    }

    public static MapStateDescriptor<String, Double> createMaxSignalDeltaDescriptor() {
        MapStateDescriptor<String, Double> descriptor =
            new MapStateDescriptor<>("maxSignalDelta", String.class, Double.class);
        descriptor.enableTimeToLive(createTtlConfig());  // Enable TTL
        return descriptor;
    }
}
```

### Usage in ProcessFunction

```java
public class ConfidenceCalculator extends KeyedProcessFunction<String, Event, Result> {
    private MapState<String, Double> maxSignalDeltaState;

    @Override
    public void open(Configuration config) {
        // Use descriptor with TTL
        MapStateDescriptor<String, Double> descriptor =
            MarketLagStateConfig.createMaxSignalDeltaDescriptor();
        maxSignalDeltaState = getRuntimeContext().getMapState(descriptor);
    }

    @Override
    public void processElement(Event event, Context ctx, Collector<Result> out) {
        String outcome = event.getOutcome();
        double signalDelta = event.getSignalDelta();

        // Read state (expired entries automatically not returned)
        Double currentMax = maxSignalDeltaState.get(outcome);

        // Update state (TTL refreshed)
        if (currentMax == null || signalDelta > currentMax) {
            maxSignalDeltaState.put(outcome, signalDelta);  // TTL set to now + 7 days
        }
    }
}
```

---

## Minimum Viable Code

```java
import org.apache.flink.api.common.state.*;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.time.Time;

public class TTLDemo {
    public static class TTLProcessFunction extends KeyedProcessFunction<String, Event, Result> {
        private MapState<String, Double> state;

        @Override
        public void open(Configuration config) {
            // Configure TTL
            StateTtlConfig ttlConfig = StateTtlConfig
                .newBuilder(Time.days(7))
                .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
                .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)
                .build();

            // Create descriptor with TTL
            MapStateDescriptor<String, Double> descriptor =
                new MapStateDescriptor<>("state", String.class, Double.class);
            descriptor.enableTimeToLive(ttlConfig);

            state = getRuntimeContext().getMapState(descriptor);
        }

        @Override
        public void processElement(Event event, Context ctx, Collector<Result> out) {
            // State automatically expires after 7 days from last write
            Double value = state.get(event.getKey());
            if (value == null) {
                state.put(event.getKey(), event.getValue());  // TTL set
            }
        }
    }
}
```

---

## Common Mistakes

1. **Not setting TTL**:
   - ❌ State grows unbounded
   - ✅ Always set TTL for state that can grow (MapState, ListState)

2. **Wrong TTL duration**:
   - ❌ Too short (loses needed history) or too long (wastes memory)
   - ✅ Choose based on use case (MarketLag uses 7 days)

3. **Wrong update strategy**:
   - ❌ Using OnReadAndWrite when OnCreateAndWrite is needed
   - ✅ Understand difference: OnCreateAndWrite expires after inactivity

4. **TTL not enabled**:
   - ❌ Creating descriptor without enableTimeToLive()
   - ✅ Always call: `descriptor.enableTimeToLive(ttlConfig)`

5. **Expecting immediate cleanup**:
   - ❌ Expecting expired state removed immediately
   - ✅ Cleanup is periodic, may have delay

---

## Mind Trigger: When to Think About This

Think about State TTL when:
- **Storing historical data**: MarketLag stores max_signal_delta with 7-day TTL
- **Preventing unbounded growth**: MapState, ListState can grow without TTL
- **State management**: Section 1.7 (state types), section 1.9 (state access)
- **Memory optimization**: TTL helps manage state size
- **Historical baseline**: MarketLag uses 7-day history for confidence calculation

**In MarketLag project**: Uses 7-day TTL for MapState storing max_signal_delta per outcome. TTL prevents unbounded state growth while keeping recent history for confidence score normalization. TTL is configured with OnCreateAndWrite strategy.

---

## Summary

State TTL automatically expires state after a specified duration, preventing unbounded growth. TTL update strategies: OnCreateAndWrite (update on write) or OnReadAndWrite (update on read/write). Flink automatically cleans up expired state. MarketLag uses 7-day TTL for MapState storing max_signal_delta. Understanding TTL is essential for managing state size and memory in long-running streaming applications.

