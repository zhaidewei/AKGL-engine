# Join Type Selection: Equi-Join vs Interval Join

**Learning Point**: 12.5 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 3.2 (Temporal Joins), 3.3 (Equi-Join), understanding of join semantics
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Equi-Join**: A join operation that matches rows using exact equality on join keys. Both sides of the join condition must have equal values for the join to succeed.

**Interval Join**: A join operation that matches rows within a time interval (e.g., ±5 minutes). Rows are matched if their timestamps are within the specified interval.

**Data Alignment**: The degree to which timestamps from different sources are aligned to the same boundaries (e.g., UTC hour boundaries).

**Join Type Selection**: Choosing the appropriate join type based on data characteristics and requirements.

---

## Plain Language Explanation

Think of join types like matching strategies:

- **Equi-Join** = Exact match: "Match rows where keys are exactly equal"
- **Interval Join** = Fuzzy match: "Match rows where timestamps are within 5 minutes"
- **Data Alignment** = How well timestamps line up: "Are timestamps aligned to same boundaries?"

**Why It Matters**: MarketLag uses equi-join because data is pre-aligned to UTC hours. Understanding when to use which join type helps make the right choice.

---

## Analogy

If you know **database joins** (which you do), Flink join types are similar:
- SQL INNER JOIN = Flink equi-join (both exact matches)
- SQL time-based join = Flink interval join (both fuzzy time matching)

Key difference: Flink joins work over unbounded streams continuously.

---

## Relationship to Already Learned Topics

- **3.3 Equi-Join**: MarketLag uses equi-join (covered in section 3.3)
- **3.2 Temporal Joins**: Different join type (not used in MarketLag)
- **1.4 Time Concepts**: Data alignment affects join type choice
- **SQL Joins**: You already know joins - Flink extends to streaming

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```sql
-- Equi-join (simplified)
SELECT *
FROM table1 t1
INNER JOIN table2 t2
ON t1.key = t2.key
  AND t1.time = t2.time  -- Exact match
-- Matches only when keys and times are exactly equal

-- Interval join (simplified)
SELECT *
FROM table1 t1
JOIN table2 t2
ON t1.key = t2.key
  AND t1.time BETWEEN t2.time - INTERVAL '5' MINUTE
                  AND t2.time + INTERVAL '5' MINUTE
-- Matches when keys match and times are within ±5 minutes
```

---

## Source Code References

**Project Design**: `generation_pipeline/step1_output_project_design/output_project_design_v5.md`

**Implementation**: MarketLag Job 3 uses equi-join (section 3.3).

---

## Equi-Join: Exact Match on Join Keys

### Characteristics

- **Exact Match**: Both join keys must be exactly equal
- **Efficient**: Simple, fast, can be optimized
- **Deterministic**: Always produces same results

### MarketLag Pattern

```sql
SELECT *
FROM rss_signals_hourly r
INNER JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start = p.event_time
```

**Key Points**:
- **market_slug**: Exact match (same market)
- **window_start = event_time**: Exact match (both aligned to UTC hours)

**Why It Works**: Data is pre-aligned to UTC hour boundaries, so exact match is possible.

---

## Interval Join: Join Within Time Bounds

### Characteristics

- **Fuzzy Match**: Timestamps within interval (e.g., ±5 minutes)
- **Handles Misalignment**: Works when data is not perfectly aligned
- **More Complex**: Requires interval calculation

### Example

```sql
SELECT *
FROM stream1 s1
JOIN stream2 s2
ON s1.key = s2.key
  AND s1.event_time BETWEEN s2.event_time - INTERVAL '5' MINUTE
                        AND s2.event_time + INTERVAL '5' MINUTE
```

**Use Case**: When data may be slightly misaligned (network delays, processing delays).

**MarketLag**: Not used because data is pre-aligned.

---

## Decision Factor: Data Alignment

### Pre-Aligned Data (MarketLag Pattern)

**Characteristics**:
- Timestamps aligned to boundaries (UTC hours)
- Exact matches possible
- Predictable join results

**Choice**: **Equi-Join** (simpler, more efficient)

**MarketLag**:
- RSS signals: window_start aligned to UTC hours
- Polymarket prices: event_time aligned to UTC hours
- **Result**: Equi-join works perfectly

### Misaligned Data

**Characteristics**:
- Timestamps not perfectly aligned
- Slight variations (seconds, minutes)
- Exact matches may miss valid pairs

**Choice**: **Interval Join** (handles misalignment)

**Example**: If prices arrived 2 minutes after signals, interval join would still match them.

---

## Pros and Cons

### Equi-Join

**Pros**:
- Simple, efficient
- Exact matching
- Deterministic results
- Easy to understand

**Cons**:
- Requires pre-aligned data
- Misses matches if data misaligned

**MarketLag**: Uses equi-join because data is pre-aligned.

### Interval Join

**Pros**:
- Handles slight misalignment
- More flexible
- Works with network delays

**Cons**:
- More complex
- May match unintended pairs
- Performance overhead

**MarketLag**: Not used because data is pre-aligned.

---

## Minimum Viable Code

```sql
-- Equi-join (MarketLag pattern)
SELECT
    r.market_slug,
    r.window_start,
    r.source_weighted_signal as rss_signal,
    p.price,
    p.price_delta
FROM rss_signals_hourly r
INNER JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start = p.event_time  -- Exact match
WHERE r.source_weighted_signal IS NOT NULL
  AND p.price IS NOT NULL;

-- Interval join (alternative, not used in MarketLag)
SELECT
    r.market_slug,
    r.window_start,
    r.source_weighted_signal as rss_signal,
    p.price,
    p.price_delta
FROM rss_signals_hourly r
JOIN polymarket_price_hourly p
ON r.market_slug = p.market_slug
  AND r.window_start BETWEEN p.event_time - INTERVAL '5' MINUTE
                          AND p.event_time + INTERVAL '5' MINUTE
WHERE r.source_weighted_signal IS NOT NULL
  AND p.price IS NOT NULL;
```

---

## Common Mistakes

1. **Using interval join when equi-join suffices**:
   - ❌ Using interval join for pre-aligned data
   - ✅ Use equi-join when data is aligned (MarketLag pattern)

2. **Using equi-join when data misaligned**:
   - ❌ Using equi-join for misaligned data (misses matches)
   - ✅ Use interval join when data is not perfectly aligned

3. **Not understanding data alignment**:
   - ❌ Not checking if data is aligned
   - ✅ Verify data alignment before choosing join type

4. **Wrong interval size**:
   - ❌ Using ±1 hour interval (too large, matches too many)
   - ✅ Use appropriate interval (e.g., ±5 minutes)

5. **Performance concerns**:
   - ❌ Not considering performance implications
   - ✅ Equi-join is more efficient, use when possible

---

## Mind Trigger: When to Think About This

Think about join type selection when:
- **Designing joins**: MarketLag Job 3 joins signals with prices
- **Data alignment**: Understanding if data is pre-aligned
- **Choosing join type**: Equi-join vs interval join decision
- **Performance optimization**: Equi-join is more efficient
- **Understanding MarketLag design**: Why equi-join is used

**In MarketLag project**: Uses equi-join because RSS signals (window_start) and Polymarket prices (event_time) are both aligned to UTC hour boundaries. Exact match is possible and more efficient than interval join. Understanding join type selection helps understand MarketLag's design decisions.

---

## Summary

Join type selection depends on data alignment. Equi-join matches on exact equality, efficient for pre-aligned data. Interval join matches within time bounds, handles misalignment. MarketLag uses equi-join because data is pre-aligned to UTC hours. Understanding join type selection helps choose the right join for each use case.

