# Confidence Score Calculation Formula

**Learning Point**: 12.2 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 12.1 (Lag Detection), 1.7 (State Types), 1.9 (State Access), understanding of weighted formulas
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Confidence Score**: A numerical value [0, 1] that quantifies the reliability of a lag signal. Higher confidence indicates more reliable lag detection.

**Confidence Formula**: Weighted combination of three factors:
- Signal delta normalization: `(signal_delta / max_signal_delta) * 0.5`
- Price stability: `(1 - |price_delta|) * 0.3`
- Source credibility: `source_weight_avg * 0.2`

**Max Signal Delta**: Historical maximum signal delta for normalization. Stored in MapState (section 1.7) with 7-day TTL (section 4.2).

**Factor Normalization**: Scaling each factor to [0, 1] range before weighting.

---

## Plain Language Explanation

Think of confidence score like a quality rating:

- **Signal Delta Factor** (50% weight): "How significant is this signal change compared to historical max?"
- **Price Stability Factor** (30% weight): "How stable is the price? (More stable = higher confidence)"
- **Source Credibility Factor** (20% weight): "How credible are the news sources?"

**The Formula**: Combines these three factors with weights to produce a confidence score from 0 to 1.

---

## Analogy

Imagine rating a restaurant:
- **Food Quality** (50%): How good is the food? (signal delta)
- **Service** (30%): How consistent is service? (price stability)
- **Ambiance** (20%): How nice is the atmosphere? (source credibility)

Confidence score is like an overall rating combining all factors.

---

## Relationship to Already Learned Topics

- **12.1 Lag Detection**: Confidence score quantifies lag signals
- **1.7 State Types**: Uses MapState to store max_signal_delta
- **1.9 State Access**: Reads/writes max_signal_delta from state
- **4.2 State TTL**: 7-day TTL for historical state
- **Weighted Formulas**: Similar to weighted averages you already know

---

## Pseudocode (From Project Design)

Based on MarketLag project design:

```java
// Confidence calculation (simplified)
double calculateConfidence(
    double signalDelta,
    double maxSignalDelta,
    double priceDelta,
    double sourceWeightAvg
) {
    // Factor 1: Signal delta normalization (50% weight)
    double signalFactor = (signalDelta / maxSignalDelta) * 0.5;

    // Factor 2: Price stability (30% weight)
    double priceFactor = (1 - Math.abs(priceDelta)) * 0.3;

    // Factor 3: Source credibility (20% weight)
    double sourceFactor = sourceWeightAvg * 0.2;

    // Sum and cap at 1.0
    double confidence = Math.min(1.0, signalFactor + priceFactor + sourceFactor);

    return confidence;
}
```

---

## Source Code References

**Project Design**: `generation_pipeline/step1_output_project_design/output_project_design_v5.md`

**Implementation**: This formula is implemented in MarketLag Job 3, likely in a ProcessFunction (section 4.1) that accesses MapState (section 1.9).

---

## Confidence Score Calculation Formula

### Complete Formula

```
confidence = min(1.0,
    (signal_delta / max_signal_delta) * 0.5 +
    (1 - |price_delta|) * 0.3 +
    (source_weight_avg) * 0.2
)
```

### Formula Breakdown

1. **Signal Delta Factor** (50% weight):
   ```
   (signal_delta / max_signal_delta) * 0.5
   ```
   - Normalizes signal_delta by historical max
   - Higher signal_delta relative to max → Higher confidence

2. **Price Stability Factor** (30% weight):
   ```
   (1 - |price_delta|) * 0.3
   ```
   - More stable price (smaller |price_delta|) → Higher confidence
   - Price delta = 0 → Full 0.3 points
   - Price delta = 1 → 0 points

3. **Source Credibility Factor** (20% weight):
   ```
   source_weight_avg * 0.2
   ```
   - Higher source credibility → Higher confidence
   - Reuters (1.0) → Full 0.2 points
   - Others (0.7) → 0.14 points

4. **Final Score**:
   ```
   min(1.0, sum_of_factors)
   ```
   - Caps confidence at 1.0
   - Sum of factors can exceed 1.0, so min() ensures [0, 1] range

---

## Factor Normalization: Scaling to [0,1] Range

### Signal Delta Normalization

**Problem**: signal_delta can be any value, need to normalize to [0, 1].

**Solution**: Divide by max_signal_delta (historical maximum).

**Example**:
- signal_delta = 2.0
- max_signal_delta = 4.0
- Normalized = 2.0 / 4.0 = 0.5

**Edge Case**: If max_signal_delta = 0 (no history), use signal_delta directly or default to 0.

### Price Delta Normalization

**Problem**: |price_delta| can be > 1, need to normalize.

**Solution**: `1 - |price_delta|`, but this can be negative if |price_delta| > 1.

**Fix**: Use `max(0, 1 - |price_delta|)` to ensure non-negative.

**Example**:
- price_delta = 0.01
- Normalized = 1 - 0.01 = 0.99

### Source Weight Normalization

**Already Normalized**: source_weight_avg is already [0, 1] (Reuters=1.0, others=0.7).

---

## Historical Baseline: Using max_signal_delta for Normalization

### Storing max_signal_delta in MapState

```java
// In ProcessFunction (section 4.1)
private MapState<String, Double> maxSignalDeltaState;  // outcome -> max_delta

@Override
public void processElement(Event event, Context ctx, Collector<Result> out) {
    String outcome = event.getOutcome();
    double signalDelta = event.getSignalDelta();

    // Read current max
    Double currentMax = maxSignalDeltaState.get(outcome);

    // Update if current is larger
    if (currentMax == null || signalDelta > currentMax) {
        maxSignalDeltaState.put(outcome, signalDelta);
        currentMax = signalDelta;
    }

    // Use for confidence calculation
    double confidence = calculateConfidence(signalDelta, currentMax, ...);
}
```

**MarketLag Project**: Stores max_signal_delta per outcome (YES/NO) in MapState with 7-day TTL.

---

## Minimum Viable Code

```java
public class ConfidenceCalculator {
    public double calculateConfidence(
            double signalDelta,
            double maxSignalDelta,
            double priceDelta,
            double sourceWeightAvg) {

        // Factor 1: Signal delta normalization (50%)
        double signalFactor = 0.0;
        if (maxSignalDelta > 0) {
            signalFactor = (signalDelta / maxSignalDelta) * 0.5;
        }

        // Factor 2: Price stability (30%)
        double priceFactor = Math.max(0, 1 - Math.abs(priceDelta)) * 0.3;

        // Factor 3: Source credibility (20%)
        double sourceFactor = sourceWeightAvg * 0.2;

        // Sum and cap at 1.0
        double confidence = Math.min(1.0, signalFactor + priceFactor + sourceFactor);

        return confidence;
    }
}
```

---

## Example Calculations

### Example 1: High Confidence

- signal_delta = 3.0
- max_signal_delta = 4.0
- price_delta = 0.01
- source_weight_avg = 1.0 (Reuters)

**Calculation**:
- Signal factor: (3.0 / 4.0) * 0.5 = 0.375
- Price factor: (1 - 0.01) * 0.3 = 0.297
- Source factor: 1.0 * 0.2 = 0.2
- Confidence: min(1.0, 0.375 + 0.297 + 0.2) = **0.872**

### Example 2: Medium Confidence

- signal_delta = 1.5
- max_signal_delta = 3.0
- price_delta = 0.015
- source_weight_avg = 0.7

**Calculation**:
- Signal factor: (1.5 / 3.0) * 0.5 = 0.25
- Price factor: (1 - 0.015) * 0.3 = 0.2955
- Source factor: 0.7 * 0.2 = 0.14
- Confidence: min(1.0, 0.25 + 0.2955 + 0.14) = **0.686**

### Example 3: Low Confidence

- signal_delta = 1.2
- max_signal_delta = 5.0
- price_delta = 0.03
- source_weight_avg = 0.7

**Calculation**:
- Signal factor: (1.2 / 5.0) * 0.5 = 0.12
- Price factor: (1 - 0.03) * 0.3 = 0.291
- Source factor: 0.7 * 0.2 = 0.14
- Confidence: min(1.0, 0.12 + 0.291 + 0.14) = **0.551**

---

## Common Mistakes

1. **Division by zero**:
   - ❌ `signal_delta / max_signal_delta` when max_signal_delta = 0
   - ✅ Check: `if (max_signal_delta > 0) { ... }`

2. **Negative price factor**:
   - ❌ `(1 - |price_delta|)` when |price_delta| > 1
   - ✅ Use: `max(0, 1 - |price_delta|)`

3. **Not updating max_signal_delta**:
   - ❌ Using stale max_signal_delta
   - ✅ Always update MapState when signal_delta > current max

4. **Wrong weights**:
   - ❌ Using equal weights (0.33 each)
   - ✅ Use correct weights: 0.5, 0.3, 0.2

5. **Not capping at 1.0**:
   - ❌ Confidence > 1.0
   - ✅ Always use `min(1.0, sum)`

---

## Mind Trigger: When to Think About This

Think about confidence score when:
- **Implementing Job 3**: Confidence calculation is part of lag detection
- **Storing max_signal_delta**: Section 1.7 (MapState), section 1.9 (state access)
- **State TTL**: Section 4.2 - 7-day TTL for historical state
- **ProcessFunction**: Section 4.1 - confidence calculated in ProcessFunction
- **Tuning weights**: 0.5, 0.3, 0.2 are tunable parameters

**In MarketLag project**: Confidence score quantifies reliability of lag signals. Calculated in Job 3 using MapState to store max_signal_delta. Stored with lag signals in Supabase for filtering and ranking.

---

## Summary

Confidence score quantifies lag signal reliability using a weighted formula: signal delta normalization (50%), price stability (30%), and source credibility (20%). Max_signal_delta is stored in MapState for normalization. Formula caps confidence at 1.0. This is implemented in MarketLag Job 3, likely in a ProcessFunction that accesses MapState. Understanding confidence scoring helps filter and rank lag signals.

