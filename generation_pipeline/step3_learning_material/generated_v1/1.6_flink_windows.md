# Flink Windows

**Learning Point**: 1.6 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.4 (Time Concepts), 1.5 (Watermarks), understanding of aggregations
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**Window**: A mechanism to group unbounded stream data into finite buckets based on time or count. Windows enable aggregations over time-bounded subsets of the stream.

**Tumbling Window**: Non-overlapping, fixed-size windows where each event belongs to exactly one window. Window size equals window slide.

**Sliding Window**: Overlapping windows where events can belong to multiple windows. Window slide is smaller than window size.

**Session Window**: Windows that group events by activity periods. Windows close when no events arrive for a specified gap duration.

**Window Assignment**: The process of determining which window(s) an event belongs to based on its timestamp.

**Window Function**: The computation applied to events within a window (aggregate, process, reduce).

---

## Plain Language Explanation

Think of windows like time buckets for streaming data:

- **Tumbling Window** = Non-overlapping buckets: [0-1hr), [1-2hr), [2-3hr) - each event goes in exactly one bucket
- **Sliding Window** = Overlapping buckets: [0-1hr), [0.5-1.5hr), [1-2hr) - events can be in multiple buckets
- **Session Window** = Activity-based buckets: Group events that arrive close together, close bucket when gap appears

**Why Needed**: Streams are infinite - you can't aggregate "all data ever." Windows let you aggregate "all data in the last hour" or "all data in this 5-minute period."

---

## Analogy

If you know **SQL window functions** (which you do), Flink windows are similar but for streaming:
- SQL `OVER (PARTITION BY ... ORDER BY ... ROWS BETWEEN ...)` = Flink windows
- SQL aggregates over partitions = Flink aggregates over windows

Key difference: SQL windows are over bounded data, Flink windows are over unbounded streams that continuously produce results.

---

## Relationship to Already Learned Topics

- **1.4 Time Concepts**: Windows use event time (or processing time) to assign events
- **1.5 Watermarks**: Windows use watermarks to determine when to close and emit results
- **1.3 Table API/SQL**: Flink SQL has window functions (TUMBLE, HOP, SESSION)
- **Aggregations**: You know aggregations from SQL - windows enable aggregations over time

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// Window (simplified)
class TumblingWindow {
    long windowSize;  // e.g., 1 hour

    long getWindowStart(long timestamp) {
        // Align to window boundary
        return (timestamp / windowSize) * windowSize;
    }

    long getWindowEnd(long timestamp) {
        return getWindowStart(timestamp) + windowSize;
    }

    boolean belongsToWindow(Event event, long windowStart) {
        long eventTime = event.getTimestamp();
        return eventTime >= windowStart && eventTime < windowStart + windowSize;
    }
}

// Window assignment (simplified)
class WindowAssigner {
    List<Window> assignWindows(Event event, long timestamp) {
        long windowStart = alignToWindow(timestamp);
        return Collections.singletonList(new TimeWindow(windowStart, windowStart + size));
    }
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/windows/TimeWindow.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/windows/TimeWindow.java

**Key Classes**:
- `TimeWindow`: Represents a time-based window
- `WindowAssigner`: Assigns events to windows
- `WindowFunction`: Function applied to window contents

---

## Window Types

### 1. Tumbling Windows (MarketLag Project Uses This)

**Definition**: Fixed-size, non-overlapping windows.

**Example**: 1-hour tumbling windows
- Window 1: [00:00, 01:00)
- Window 2: [01:00, 02:00)
- Window 3: [02:00, 03:00)

**MarketLag Use Case**: RSS signal aggregation - aggregate all RSS events in each hour.

```java
// DataStream API
stream.keyBy(Event::getKey)
    .window(TumblingEventTimeWindows.of(Time.hours(1)))
    .aggregate(new MyAggregateFunction());
```

```sql
-- Flink SQL (MarketLag Job 1)
SELECT
    market_slug,
    TUMBLE_START(published_at, INTERVAL '1' HOUR) as window_start,
    TUMBLE_END(published_at, INTERVAL '1' HOUR) as window_end,
    COUNT(*) as mention_count,
    SUM(keyword_score) as keyword_score
FROM rss_events
GROUP BY market_slug, TUMBLE(published_at, INTERVAL '1' HOUR);
```

### 2. Sliding Windows

**Definition**: Fixed-size windows that slide by a smaller interval (overlapping).

**Example**: 1-hour windows sliding every 30 minutes
- Window 1: [00:00, 01:00)
- Window 2: [00:30, 01:30)
- Window 3: [01:00, 02:00)

**Use Case**: Moving averages, trend analysis.

```java
stream.keyBy(Event::getKey)
    .window(SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(30)))
    .aggregate(new MyAggregateFunction());
```

### 3. Session Windows

**Definition**: Windows that group events by activity periods, close when gap exceeds threshold.

**Example**: Session gap = 5 minutes
- Events at 10:00, 10:02, 10:03 → One session
- Gap of 6 minutes
- Events at 10:09 → New session

**Use Case**: User session analysis, grouping related events.

```java
stream.keyBy(Event::getUserId)
    .window(EventTimeSessionWindows.withGap(Time.minutes(5)))
    .aggregate(new MyAggregateFunction());
```

---

## Tumbling Window Configuration and Semantics

### Window Size

Window size determines how events are grouped:
- **1 hour**: All events in same UTC hour → one window
- **5 minutes**: All events in same 5-minute period → one window

### Window Alignment

Windows align to time boundaries:
- **Hour-aligned**: Windows start at :00 minutes (00:00, 01:00, 02:00...)
- **Custom alignment**: Can offset (e.g., start at :15 minutes)

**MarketLag Project**: 1-hour windows aligned to UTC hour boundaries (00:00, 01:00, 02:00...).

### Window Semantics

- **Inclusive start, exclusive end**: Window [14:00, 15:00) includes 14:00:00 but not 15:00:00
- **Event assignment**: Event with timestamp T belongs to window [floor(T/windowSize)*windowSize, floor(T/windowSize)*windowSize + windowSize)

---

## Window Assignment: How Events Are Assigned to Windows

### Event-Time Windows

1. Extract event timestamp from event
2. Calculate window start: `windowStart = floor(timestamp / windowSize) * windowSize`
3. Assign event to window [windowStart, windowStart + windowSize)

**Example**:
- Event timestamp: 14:30:00
- Window size: 1 hour
- Window start: floor(14:30 / 1hr) * 1hr = 14:00
- Assigned to: [14:00, 15:00)

### Processing-Time Windows

1. Use current processing time (system clock)
2. Calculate window start based on processing time
3. Assign event to window

**Note**: Processing-time windows are non-deterministic (results vary with processing speed).

---

## Window Functions: Aggregate, Process, Reduce

### 1. Aggregate Function

Incremental aggregation - maintains accumulator, efficient for large windows.

```java
public class CountAggregate implements AggregateFunction<Event, Long, Long> {
    @Override
    public Long createAccumulator() {
        return 0L;
    }

    @Override
    public Long add(Event value, Long accumulator) {
        return accumulator + 1;
    }

    @Override
    public Long getResult(Long accumulator) {
        return accumulator;
    }

    @Override
    public Long merge(Long a, Long b) {
        return a + b;
    }
}
```

### 2. Process Window Function

Full window access - receives all events in window, more flexible but less efficient.

```java
public class MyProcessWindowFunction
    extends ProcessWindowFunction<Event, Result, String, TimeWindow> {

    @Override
    public void process(String key, Context ctx,
                       Iterable<Event> elements,
                       Collector<Result> out) {
        // Process all events in window
        long count = 0;
        for (Event e : elements) {
            count++;
        }
        out.collect(new Result(key, ctx.window().getStart(), count));
    }
}
```

### 3. Reduce Function

Simple reduction - combines two events into one, incremental.

```java
stream.window(...)
    .reduce((e1, e2) -> new Event(
        e1.getKey(),
        e1.getValue() + e2.getValue()
    ));
```

**MarketLag Project**: Uses aggregate functions (COUNT, SUM, AVG) in Flink SQL.

---

## Window Triggers and Eviction Policies

### Triggers

Determine when window results are emitted:

- **Event-time trigger**: Fires when watermark passes window end
- **Processing-time trigger**: Fires at fixed intervals
- **Count trigger**: Fires when N events in window
- **Custom trigger**: User-defined logic

**Default**: Event-time windows trigger when watermark >= window end.

### Eviction Policies

Remove events from window buffer:

- **Time-based**: Remove events older than X
- **Count-based**: Keep only last N events
- **Custom**: User-defined logic

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.api.common.functions.AggregateFunction;

public class WindowDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        DataStream<Event> events = env.fromElements(
            new Event("A", 1000L, 10),
            new Event("A", 2000L, 20),
            new Event("A", 3000L, 30),
            new Event("B", 1500L, 15),
            new Event("B", 2500L, 25)
        );

        // Assign timestamps and watermarks
        DataStream<Event> withTimestamps = events.assignTimestampsAndWatermarks(
            WatermarkStrategy
                .<Event>forBoundedOutOfOrderness(Duration.ofSeconds(1))
                .withTimestampAssigner((e, ts) -> e.getTimestamp())
        );

        // 2-second tumbling windows
        withTimestamps
            .keyBy(Event::getKey)
            .window(TumblingEventTimeWindows.of(Time.seconds(2)))
            .aggregate(new AggregateFunction<Event, Long, Long>() {
                @Override
                public Long createAccumulator() { return 0L; }

                @Override
                public Long add(Event value, Long acc) { return acc + value.getValue(); }

                @Override
                public Long getResult(Long acc) { return acc; }

                @Override
                public Long merge(Long a, Long b) { return a + b; }
            })
            .print();

        env.execute("Window Demo");
    }
}
```

---

## Common Mistakes

1. **Wrong window type**:
   - ❌ Using sliding window when tumbling is needed
   - ✅ Use tumbling for non-overlapping aggregations (MarketLag uses this)

2. **Not setting watermarks for event-time windows**:
   - ❌ Event-time windows without watermarks never trigger
   - ✅ Always set watermarks (section 1.5)

3. **Window alignment issues**:
   - ❌ Events in wrong windows due to misalignment
   - ✅ Ensure timestamps are aligned to window boundaries (section 1.4)

4. **Confusing window start/end**:
   - ❌ Using inclusive end instead of exclusive
   - ✅ Remember: [start, end) - inclusive start, exclusive end

5. **Inefficient window functions**:
   - ❌ Using ProcessWindowFunction when AggregateFunction suffices
   - ✅ Use AggregateFunction for simple aggregations (more efficient)

---

## Mind Trigger: When to Think About This

Think about Flink windows when:
- **Aggregating over time**: MarketLag Job 1 aggregates RSS events hourly
- **Grouping streaming data**: Need to group unbounded stream into finite buckets
- **Window functions in SQL**: Section 3.1 covers TUMBLE window syntax
- **Window alignment**: Ensure events go to correct windows
- **Performance tuning**: Window size affects latency and state size

**In MarketLag project**: Job 1 uses 1-hour tumbling windows to aggregate RSS signals. Windows align to UTC hour boundaries. Results are emitted when watermark passes window end time.

---

## Summary

Windows group unbounded streams into finite time buckets. Tumbling windows (used in MarketLag) are non-overlapping and fixed-size. Events are assigned to windows based on their timestamps. Window functions (aggregate, process, reduce) compute results. Windows trigger when watermarks pass window end. Understanding windows is essential for time-based aggregations in streaming applications.

