# Flink SQL Window Aggregations with LAG

**Learning Point**: 3.4 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.3 (Table API/SQL), 3.1 (Window Functions), SQL window functions knowledge
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**LAG Function**: A Flink SQL window function that accesses the value of a previous row within a window. Returns the value from N rows before the current row.

**LAG with OVER Clause**: LAG function used with OVER clause to define the window for accessing previous rows. Includes PARTITION BY and ORDER BY.

**PARTITION BY**: Divides rows into groups (partitions) for window function calculation. LAG is calculated separately for each partition.

**ORDER BY**: Specifies the ordering of rows within each partition. Required for LAG to determine "previous" row.

**Windowed Lag Calculation**: Using LAG to calculate the difference between current and previous values (e.g., signal_delta = current - previous).

---

## Plain Language Explanation

Think of LAG function like looking back in time:

- **LAG** = Previous value: "What was the signal value in the previous hour?"
- **PARTITION BY** = Group by: "Calculate LAG separately for each market"
- **ORDER BY** = Time order: "Order by time to find previous hour"
- **Delta Calculation** = Current - Previous: "How much did the signal change?"

**Why Needed**: MarketLag Job 3 uses LAG to calculate signal_delta - the change in signal from previous window to current window.

---

## Analogy

If you know **SQL LAG function** (which you do), Flink's LAG is the same:
- SQL `LAG(value) OVER (PARTITION BY key ORDER BY time)` = Flink LAG
- Both access previous row values within partitions

Key difference: Flink LAG works over unbounded streams, continuously producing results as new data arrives.

---

## Relationship to Already Learned Topics

- **1.3 Table API/SQL**: LAG is a Flink SQL function
- **3.1 Window Functions**: LAG is used with window aggregations
- **12.1 Lag Detection**: LAG calculates signal_delta for lag detection
- **SQL Window Functions**: You already know LAG from SQL

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```sql
-- LAG function (simplified)
LAG(value, offset, default) OVER (
    PARTITION BY key
    ORDER BY time
)
-- Returns: value from 'offset' rows before current row
-- Default: value to return if no previous row exists
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/functions/WindowFunction.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/functions/WindowFunction.java

---

## LAG Function: Accessing Previous Row Values

### Basic LAG Syntax

```sql
LAG(column, offset, default) OVER (
    PARTITION BY partition_key
    ORDER BY order_key
)
```

**Parameters**:
- **column**: Column to access previous value from
- **offset**: Number of rows to look back (default: 1)
- **default**: Value to return if no previous row exists (default: NULL)

### Simple LAG Example

```sql
SELECT
    market_slug,
    window_start,
    signal,
    LAG(signal) OVER (
        PARTITION BY market_slug
        ORDER BY window_start
    ) as prev_signal
FROM rss_signals_hourly;
```

**Result**:
- Row 1: signal=2.5, prev_signal=NULL (no previous row)
- Row 2: signal=4.0, prev_signal=2.5 (previous row's signal)
- Row 3: signal=3.5, prev_signal=4.0

---

## LAG with OVER Clause: Windowed Lag Calculation

### OVER Clause Components

1. **PARTITION BY**: Groups rows (e.g., by market_slug)
2. **ORDER BY**: Orders rows within partition (e.g., by window_start)

### MarketLag Job 3 Pattern

```sql
SELECT
    market_slug,
    window_start,
    signal,
    LAG(signal) OVER (
        PARTITION BY market_slug
        ORDER BY window_start
    ) as prev_signal,
    -- Calculate delta
    signal - LAG(signal) OVER (
        PARTITION BY market_slug
        ORDER BY window_start
    ) as signal_delta
FROM rss_signals_hourly;
```

**This is the exact pattern used in MarketLag Job 3**.

---

## PARTITION BY and ORDER BY in Window Functions

### PARTITION BY

Divides rows into groups. LAG is calculated separately for each group.

```sql
PARTITION BY market_slug
```

**Effect**: LAG calculates previous value per market, not across all markets.

**Example**:
- Market A, Window 1: signal=2.5, prev_signal=NULL
- Market A, Window 2: signal=4.0, prev_signal=2.5 (Market A's previous)
- Market B, Window 1: signal=1.0, prev_signal=NULL (Market B's first, not Market A's)

### ORDER BY

Specifies ordering within partition. Required for LAG to determine "previous".

```sql
ORDER BY window_start
```

**Effect**: Orders by time, so LAG gets previous time window's value.

**Important**: Must order by time column for time-based LAG.

---

## Windowed Lag Calculation: signal_delta = current - previous

### Complete Pattern

```sql
SELECT
    market_slug,
    window_start,
    signal,
    -- Calculate delta
    signal - LAG(signal) OVER (
        PARTITION BY market_slug
        ORDER BY window_start
    ) as signal_delta
FROM rss_signals_hourly;
```

### How It Works

1. **PARTITION BY market_slug**: Calculate separately per market
2. **ORDER BY window_start**: Order by time
3. **LAG(signal)**: Get previous window's signal
4. **signal - LAG(signal)**: Calculate delta (current - previous)

### Handling NULL (First Row)

First row has no previous row, so LAG returns NULL. Delta calculation:

```sql
-- Option 1: Use COALESCE to default to 0
COALESCE(signal - LAG(signal) OVER (...), 0) as signal_delta

-- Option 2: Filter out NULL
WHERE signal_delta IS NOT NULL
```

**MarketLag Job 3**: Likely filters out NULL or uses COALESCE.

---

## Minimum Viable Code

```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;

public class LagFunctionDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);

        // Create table
        tableEnv.executeSql(
            "CREATE TABLE signals (" +
            "  market_slug STRING," +
            "  window_start TIMESTAMP(3)," +
            "  signal DOUBLE" +
            ") WITH ('connector' = 'kafka', ...)"
        );

        // LAG calculation
        tableEnv.executeSql(
            "CREATE TABLE with_delta AS " +
            "SELECT " +
            "  market_slug," +
            "  window_start," +
            "  signal," +
            "  LAG(signal) OVER (" +
            "    PARTITION BY market_slug" +
            "    ORDER BY window_start" +
            "  ) as prev_signal," +
            "  signal - LAG(signal) OVER (" +
            "    PARTITION BY market_slug" +
            "    ORDER BY window_start" +
            "  ) as signal_delta " +
            "FROM signals"
        );

        env.execute("LAG Function Demo");
    }
}
```

---

## Common Mistakes

1. **Missing ORDER BY**:
   - ❌ `LAG(signal) OVER (PARTITION BY market_slug)` (no ORDER BY)
   - ✅ Always include ORDER BY: `ORDER BY window_start`

2. **Wrong PARTITION BY**:
   - ❌ Not partitioning (mixes markets)
   - ✅ Always partition by key: `PARTITION BY market_slug`

3. **NULL handling**:
   - ❌ Not handling NULL from LAG (first row)
   - ✅ Use COALESCE or filter: `COALESCE(..., 0)`

4. **Multiple LAG calls**:
   - ❌ Calling LAG multiple times (inefficient)
   - ✅ Calculate once, reuse: `WITH prev AS (LAG(...)) SELECT ..., prev`

5. **Wrong offset**:
   - ❌ Using LAG(signal, 2) when you want previous (offset=1)
   - ✅ Use LAG(signal) or LAG(signal, 1) for previous row

---

## Mind Trigger: When to Think About This

Think about LAG function when:
- **Calculating deltas**: MarketLag Job 3 uses LAG for signal_delta
- **Time series analysis**: Need to compare current vs previous values
- **Window functions**: LAG is a window function, works with PARTITION BY and ORDER BY
- **NULL handling**: First row has no previous, handle NULL appropriately
- **Performance**: LAG requires ordering, can be expensive for large partitions

**In MarketLag project**: Job 3 uses LAG to calculate signal_delta (current signal - previous signal) for lag detection. LAG is partitioned by market_slug and ordered by window_start. This enables detecting when signal changes significantly between consecutive windows.

---

## Summary

Flink SQL LAG function accesses previous row values within a window. LAG with OVER clause uses PARTITION BY to group rows and ORDER BY to order them. MarketLag Job 3 uses LAG to calculate signal_delta (current - previous) for lag detection. Understanding LAG is essential for time series analysis and delta calculations in streaming SQL.

