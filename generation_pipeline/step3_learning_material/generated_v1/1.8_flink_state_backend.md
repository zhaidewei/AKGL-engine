# Flink State Backend

**Learning Point**: 1.8 from knowledge_and_skills_needed_v2.md
**Prerequisites**: 1.7 (State Types), understanding of storage systems
**Version**: Flink 2.2.0

---

## Definition (Engineering Language)

**State Backend**: The storage system and mechanism Flink uses to store and manage operator state. State backends determine where state is stored (memory, filesystem, database) and how it's accessed.

**MemoryStateBackend**: Stores state in Java heap memory. Fast but limited by available memory. State is lost on job failure.

**FsStateBackend**: Stores state in filesystem (local or distributed). State is persisted to disk, survives TaskManager restarts but not JobManager failures.

**RocksDBStateBackend**: Stores state in RocksDB (embedded key-value store). State is persisted to disk, supports large state sizes, used in production. **MarketLag project uses this in Confluent Cloud**.

**State TTL (Time To Live)**: Configuration to automatically expire state after a specified duration. Prevents unbounded state growth.

---

## Plain Language Explanation

Think of state backends like different storage options for your data:

- **MemoryStateBackend** = RAM: Fast but temporary, lost when power goes out
- **FsStateBackend** = Local hard drive: Persistent but slower, survives restarts
- **RocksDBStateBackend** = Database: Persistent, handles large amounts, production-ready

**Why It Matters**: Your state can grow large (e.g., storing max_signal_delta for many markets). You need a backend that can handle the size and persist state for fault tolerance.

---

## Analogy

If you know **Redis vs PostgreSQL** (which you do), state backends are similar:
- MemoryStateBackend = Redis (in-memory, fast, limited size)
- FsStateBackend = Local file storage (persistent, medium speed)
- RocksDBStateBackend = PostgreSQL (persistent, handles large data, production-ready)

Key difference: Flink manages state backends automatically - you just configure which one to use.

---

## Relationship to Already Learned Topics

- **1.7 State Types**: State backends store the state (ValueState, MapState, etc.)
- **1.10 Checkpoints**: State backends determine how state is checkpointed
- **RocksDB**: You may know RocksDB from other systems - Flink uses it embedded
- **Storage Systems**: Similar concepts to S3, filesystems you already know

---

## Pseudocode (From Source Code)

Based on Flink 2.2.0 source code:

```java
// StateBackend interface (simplified)
interface StateBackend {
    <K, V> KeyedStateBackend<K> createKeyedStateBackend(...);
    OperatorStateBackend createOperatorStateBackend(...);
}

// RocksDBStateBackend (simplified) - Used in MarketLag
class RocksDBStateBackend implements StateBackend {
    String dbPath;  // Where RocksDB stores data

    @Override
    public KeyedStateBackend createKeyedStateBackend(...) {
        // Create RocksDB instance
        RocksDB db = RocksDB.open(dbPath);
        return new RocksDBKeyedStateBackend(db);
    }
}
```

---

## Source Code References

**Local Path**: `generation_pipeline/step0_context/source_codes/flink/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateBackend.java`

**GitHub URL**: https://github.com/apache/flink/blob/release-2.2/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateBackend.java

**Key Classes**:
- `RocksDBStateBackend`: RocksDB-based state backend
- `FsStateBackend`: Filesystem-based state backend
- `MemoryStateBackend`: Memory-based state backend

---

## State Backend Types

### 1. MemoryStateBackend

**Storage**: Java heap memory
**Persistence**: Lost on failure
**Size Limit**: Limited by heap memory
**Use Case**: Development, testing, small state

```java
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
env.setStateBackend(new MemoryStateBackend());
```

**Limitations**:
- State lost on TaskManager crash
- Limited by available heap memory
- Not suitable for production

### 2. FsStateBackend

**Storage**: Filesystem (local or distributed like HDFS)
**Persistence**: Survives TaskManager restarts
**Size Limit**: Limited by disk space
**Use Case**: Medium state, local deployments

```java
env.setStateBackend(new FsStateBackend("hdfs://namenode:port/flink/checkpoints"));
```

**Characteristics**:
- State persisted to filesystem
- Faster than RocksDB for small state
- Still limited by memory for active state access

### 3. RocksDBStateBackend (MarketLag Uses This)

**Storage**: RocksDB (embedded key-value store) + filesystem
**Persistence**: Survives failures, checkpointed to S3 in Confluent Cloud
**Size Limit**: Very large (limited by disk)
**Use Case**: Production, large state

```java
env.setStateBackend(new RocksDBStateBackend("file:///path/to/rocksdb"));
```

**Characteristics**:
- Supports very large state (GBs to TBs)
- Spills to disk when state exceeds memory
- Used in Confluent Cloud automatically
- **MarketLag Project**: Uses this in Confluent Cloud for storing MapState (max_signal_delta)

---

## State Backend Selection: When to Use Which

| Backend | State Size | Persistence | Use Case |
|---------|------------|-------------|----------|
| **MemoryStateBackend** | < 100 MB | No | Development, testing |
| **FsStateBackend** | < 10 GB | Yes (local) | Medium state, local deployments |
| **RocksDBStateBackend** | > 10 GB | Yes (distributed) | **Production, large state (MarketLag)** |

**MarketLag Project**: Uses RocksDBStateBackend in Confluent Cloud because:
- State can grow large (MapState for many markets/outcomes)
- Needs persistence for fault tolerance
- Confluent Cloud automatically configures RocksDB

---

## RocksDB Configuration (Confluent Cloud)

Confluent Cloud automatically configures RocksDB, but understanding configuration helps:

### Memory Configuration

```java
// RocksDB memory settings (Confluent Cloud handles this)
RocksDBStateBackend backend = new RocksDBStateBackend("s3://checkpoints");
backend.setDbStoragePath("/tmp/rocksdb");  // Local RocksDB data
// Memory managed by Confluent Cloud based on CFU allocation
```

**Confluent Cloud**: Allocates RocksDB memory based on CFU (Compute Flink Unit) allocation. 2 CFU for MVP provides sufficient memory for state.

### Write Buffers

RocksDB uses write buffers to batch writes:
- **Write Buffer Size**: How much data to buffer before writing
- **Write Buffer Count**: Number of write buffers
- **Confluent Cloud**: Optimizes these automatically

---

## State TTL (Time To Live) Configuration

State TTL automatically expires old state to prevent unbounded growth.

### TTL Configuration

```java
// Configure TTL for state (MarketLag uses 7 days)
StateTtlConfig ttlConfig = StateTtlConfig
    .newBuilder(Time.days(7))  // Expire after 7 days
    .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)  // Update TTL on write
    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)  // Don't return expired
    .build();

// Apply to state descriptor
MapStateDescriptor<String, Double> descriptor =
    new MapStateDescriptor<>("maxSignalDelta", String.class, Double.class);
descriptor.enableTimeToLive(ttlConfig);
```

**MarketLag Project**: Uses 7-day TTL for MapState storing max_signal_delta. Old state expires after 7 days.

### TTL Update Strategies

1. **OnCreateAndWrite**: TTL updated when state is created or written
2. **OnReadAndWrite**: TTL updated on both read and write (keeps frequently accessed state alive)

**MarketLag Project**: Uses OnCreateAndWrite - TTL only extends when state is updated.

---

## Minimum Viable Code

```java
import org.apache.flink.contrib.streaming.state.RocksDBStateBackend;
import org.apache.flink.runtime.state.StateBackend;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.time.Time;

public class StateBackendDemo {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // Configure RocksDB state backend
        RocksDBStateBackend rocksDB = new RocksDBStateBackend("file:///tmp/rocksdb");
        env.setStateBackend(rocksDB);

        // Configure state with TTL
        StateTtlConfig ttlConfig = StateTtlConfig
            .newBuilder(Time.days(7))
            .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
            .build();

        // Use in ProcessFunction
        stream.keyBy(...)
            .process(new KeyedProcessFunction<...>() {
                private MapState<String, Double> state;

                @Override
                public void open(Configuration config) {
                    MapStateDescriptor<String, Double> descriptor =
                        new MapStateDescriptor<>("state", String.class, Double.class);
                    descriptor.enableTimeToLive(ttlConfig);
                    state = getRuntimeContext().getMapState(descriptor);
                }
            });

        env.execute("State Backend Demo");
    }
}
```

---

## State Backend in Flink SQL

In Flink SQL, state backend is configured at environment level:

```sql
-- State backend configured in table environment, not in SQL
-- Set via: tableEnv.getConfig().getConfiguration().setString("state.backend", "rocksdb");
```

**Confluent Cloud**: Automatically uses RocksDBStateBackend - no configuration needed.

---

## Common Mistakes

1. **Using MemoryStateBackend in production**:
   - ❌ State lost on failures
   - ✅ Use RocksDBStateBackend for production (Confluent Cloud does this)

2. **Not configuring TTL**:
   - ❌ State grows unbounded
   - ✅ Always set TTL for state that can grow (MarketLag uses 7 days)

3. **Insufficient memory for RocksDB**:
   - ❌ OOM errors with large state
   - ✅ Allocate sufficient CFU in Confluent Cloud (2 CFU for MVP)

4. **Wrong state backend for use case**:
   - ❌ Using FsStateBackend for very large state
   - ✅ Use RocksDBStateBackend for large state (MarketLag pattern)

5. **Not understanding checkpoint storage**:
   - ❌ Confusing state backend storage with checkpoint storage
   - ✅ State backend = where active state lives, checkpoint storage = where snapshots are saved (S3 in Confluent Cloud)

---

## Mind Trigger: When to Think About This

Think about state backends when:
- **Deploying to production**: MarketLag uses RocksDB in Confluent Cloud
- **State size planning**: Estimate state size to choose appropriate backend
- **Configuring TTL**: Section 4.2 covers TTL configuration for MarketLag
- **Checkpoint configuration**: Section 1.10 - state backends affect checkpoint performance
- **Troubleshooting state issues**: OOM, slow state access - check backend configuration

**In MarketLag project**: Confluent Cloud automatically uses RocksDBStateBackend. State (MapState for max_signal_delta) is stored in RocksDB, checkpointed to S3. 7-day TTL prevents unbounded growth.

---

## Summary

Flink provides three state backends: MemoryStateBackend (development), FsStateBackend (medium state), and RocksDBStateBackend (production, large state). MarketLag uses RocksDBStateBackend in Confluent Cloud, which automatically configures it. State TTL (7 days in MarketLag) prevents unbounded state growth. Understanding state backends helps with state size planning, performance tuning, and fault tolerance configuration.

